(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ScribeOCR"] = factory();
	else
		root["ScribeOCR"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 2542:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* unused harmony export mupdf */
// Copyright (C) 2004-2021 Artifex Software, Inc.
//
// This file is part of MuPDF.
//
// MuPDF is free software: you can redistribute it and/or modify it under the
// terms of the GNU Affero General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// MuPDF is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
// details.
//
// You should have received a copy of the GNU Affero General Public License
// along with MuPDF. If not, see <https://www.gnu.org/licenses/agpl-3.0.en.html>
//
// Alternative licensing terms are available from the licensor.
// For commercial licensing, see <https://www.artifex.com/> or contact
// Artifex Software, Inc., 1305 Grant Avenue - Suite 200, Novato,
// CA 94945, U.S.A., +1(415)492-9861, for further information.

const parentPort = typeof process === 'undefined' ? globalThis : (await __webpack_require__.e(/* import() */ 448).then(__webpack_require__.t.bind(__webpack_require__, 1448, 19))).parentPort;
if (!parentPort) throw new Error('This file must be run in a worker');

// Copied from https://gist.github.com/jonleighton/958841
function arrayBufferToBase64(arrayBuffer) {
  let base64 = '';
  const encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  const bytes = new Uint8Array(arrayBuffer);
  const byteLength = bytes.byteLength;
  const byteRemainder = byteLength % 3;
  const mainLength = byteLength - byteRemainder;

  let a;
  let b;
  let c;
  let d;
  let chunk;

  // Main loop deals with bytes in chunks of 3
  for (let i = 0; i < mainLength; i += 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
    d = chunk & 63; // 63       = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder == 1) {
    chunk = bytes[mainLength];

    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3) << 4; // 3   = 2^2 - 1

    base64 += `${encodings[a] + encodings[b]}==`;
  } else if (byteRemainder == 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15) << 2; // 15    = 2^4 - 1

    base64 += `${encodings[a] + encodings[b] + encodings[c]}=`;
  }

  return base64;
}

const mupdf = {};
let ready = false;

if (typeof process === 'object') {
  // @ts-ignore
  globalThis.self = globalThis;
  // @ts-ignore
  const { createRequire } = await __webpack_require__.e(/* import() */ 240).then(__webpack_require__.t.bind(__webpack_require__, 7240, 19));
  globalThis.require = createRequire("file:///Users/aswinck/Documents/01022025/scribe.js/mupdf/mupdf-worker.js");
  const { fileURLToPath } = await Promise.all(/* import() */[__webpack_require__.e(835), __webpack_require__.e(634)]).then(__webpack_require__.t.bind(__webpack_require__, 8835, 19));
  const { dirname } = await __webpack_require__.e(/* import() */ 975).then(__webpack_require__.t.bind(__webpack_require__, 7975, 19));
  globalThis.__dirname = dirname(fileURLToPath("file:///Users/aswinck/Documents/01022025/scribe.js/mupdf/mupdf-worker.js"));
}

const { Module, FS } = await __webpack_require__.e(/* import() */ 894).then(__webpack_require__.bind(__webpack_require__, 1894));

globalThis.Module = Module;
globalThis.FS = FS;

let wasm_pageText0;
let wasm_checkNativeText;
let wasm_extractAllFonts;
let wasm_pdfSaveDocument;
let wasm_runPDF;
let wasm_convertImageStart;
let wasm_convertImageAddPage;
let wasm_convertImageEnd;

Module.onRuntimeInitialized = function () {
  Module.ccall('initContext');
  mupdf.openDocumentFromBuffer = Module.cwrap('openDocumentFromBuffer', 'number', ['string', 'number', 'number']);
  mupdf.freeDocument = Module.cwrap('freeDocument', 'null', ['number']);
  mupdf.documentTitle = Module.cwrap('documentTitle', 'string', ['number']);
  mupdf.countPages = Module.cwrap('countPages', 'number', ['number']);
  mupdf.pageWidth = Module.cwrap('pageWidth', 'number', ['number', 'number', 'number']);
  mupdf.pageHeight = Module.cwrap('pageHeight', 'number', ['number', 'number', 'number']);
  mupdf.pageLinksJSON = Module.cwrap('pageLinks', 'string', ['number', 'number', 'number']);
  mupdf.doDrawPageAsPNG = Module.cwrap('doDrawPageAsPNG', 'null', ['number', 'number', 'number', 'number']);
  mupdf.doDrawPageAsPNGGray = Module.cwrap('doDrawPageAsPNGGray', 'null', ['number', 'number', 'number', 'number']);
  wasm_convertImageStart = Module.cwrap('convertImageStart', 'null', ['number']);
  wasm_convertImageAddPage = Module.cwrap('convertImageAddPage', 'null', ['number', 'number', 'number', 'number', 'number']);
  wasm_convertImageEnd = Module.cwrap('convertImageEnd', 'null', ['number']);
  wasm_runPDF = Module.cwrap('runPDF', 'null', ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
  wasm_pdfSaveDocument = Module.cwrap('pdfSaveDocument', 'null', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
  mupdf.getLastDrawData = Module.cwrap('getLastDrawData', 'number', []);
  mupdf.getLastDrawSize = Module.cwrap('getLastDrawSize', 'number', []);
  wasm_extractAllFonts = Module.cwrap('extractAllFonts', 'number', ['number']);
  wasm_pageText0 = Module.cwrap('pageText', 'PageTextResults', ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
  mupdf.overlayDocuments = Module.cwrap('pdfOverlayDocuments', 'null', ['number', 'number']);
  mupdf.subsetPages = Module.cwrap('pdfSubsetPages', 'null', ['number', 'number', 'number']);
  mupdf.searchJSON = Module.cwrap('search', 'string', ['number', 'number', 'number', 'string']);
  mupdf.loadOutline = Module.cwrap('loadOutline', 'number', ['number']);
  mupdf.freeOutline = Module.cwrap('freeOutline', null, ['number']);
  mupdf.outlineTitle = Module.cwrap('outlineTitle', 'string', ['number']);
  mupdf.outlinePage = Module.cwrap('outlinePage', 'number', ['number', 'number']);
  mupdf.outlineDown = Module.cwrap('outlineDown', 'number', ['number']);
  mupdf.outlineNext = Module.cwrap('outlineNext', 'number', ['number']);
  wasm_checkNativeText = Module.cwrap('checkNativeText', 'number', ['number', 'number']);
  mupdf.writeDocument = Module.cwrap('writeDocument', 'null', []);
  parentPort.postMessage('READY');
  ready = true;
};

/**
 *
 * @param {number} doc - Ignored (included as boilerplate for consistency with other functions).
 * @param {Object} args
 * @param {number} args.doc1 - Document to write.
 * @param {number} [args.minpage=0] - First page to include in the output PDF. Default is 0.
 * @param {number} [args.maxpage=-1] - Last page to include in the output PDF. Default is -1 (all pages).
 * @param {number} [args.pagewidth=-1] - Width of the pages in the output PDF. Default is -1 (same as input).
 * @param {number} [args.pageheight=-1] - Height of the pages in the output PDF. Default is -1 (same as input).
 * @param {Boolean} [args.humanReadable=false]
 * @param {Boolean} [args.skipTextInvis=false]
 * @param {Boolean} [args.delGarbage=true]
 * @returns
 */
mupdf.save = function (doc, {
  doc1, minpage = 0, maxpage = -1, pagewidth = -1, pageheight = -1, humanReadable = false, skipTextInvis = false, delGarbage = true,
}) {
  wasm_pdfSaveDocument(doc1, minpage, maxpage, pagewidth, pageheight, humanReadable, skipTextInvis, delGarbage);
  const content = FS.readFile('/download.pdf');

  FS.unlink('/download.pdf');
  return content;
};

/**
 *
 * @param {number} doc
 * @param {Object} args
 * @param {number} args.page
 * @param {number} [args.dpi = 72]
 * @param {'text'|'txt'|'html'|'xhtml'|'xml'|'json'} [args.format = 'text']
 * @param {boolean} [args.skipTextInvis=false]
 * @param {boolean} [args.calcStats=false]
 * @returns {{letterCountTotal: number, letterCountVis: number, content: string}}
 */
mupdf.pageText = function (doc, {
  page, dpi = 72, format = 'text', skipTextInvis = false, calcStats = false,
}) {
  const formatCode = {
    txt: 0,
    text: 0,
    html: 1,
    xhtml: 2,
    xml: 3,
    json: 4,
  }[format];

  const structPtr = wasm_pageText0(doc, page, dpi, formatCode, skipTextInvis, calcStats, true);

  const letterCountTotal = Module.getValue(structPtr, 'i32');
  const letterCountVis = Module.getValue(structPtr + 4, 'i32');
  const dataPtr = Module.getValue(structPtr + 8, 'i32');

  const content = Module.UTF8ToString(dataPtr);

  Module._free(dataPtr);

  return {
    letterCountTotal,
    letterCountVis,
    content,
  };
};

/**
 *
 * @param {number} doc
 */
mupdf.extractAllFonts = function (doc) {
  const fontCount = wasm_extractAllFonts(doc);

  const fontArr = [];
  for (let i = 0; i < fontCount; i++) {
    const fontFile = `font-${String(i + 1).padStart(4, '0')}.ttf`;
    fontArr.push(FS.readFile(fontFile));
    FS.unlink(fontFile);
  }

  return fontArr;
};

/**
 *
 * @param {number} doc
 */
mupdf.checkNativeText = function (doc) {
  return wasm_checkNativeText(doc, false);
};

/**
 *
 * @param {number} doc
 */
mupdf.detectExtractText = function (doc) {
  const res = wasm_checkNativeText(doc, true);
  let text = FS.readFile('/download.txt', { encoding: 'utf8' });

  // Sometimes mupdf makes files with an excessive number of newlines.
  // Therefore, a maximum of 2 newlines is allowed.
  if (typeof text === 'string') {
    text = text.replace(/(\n\s*){3,}/g, '\n\n').trim();
  }
  FS.unlink('/download.txt');

  const type = ['Text native', 'Image + OCR text', 'Image native'][res];

  return {
    type,
    text,
  };
};

mupdf.cleanFile = function (data) {
  FS.writeFile('test_1.pdf', data);
  // Module.FS_createDataFile("/", "test_1.pdf", data, 1, 1, 1)
  mupdf.writeDocument();
  const content = FS.readFile('/test_2.pdf');

  FS.unlink('/test_1.pdf');
  FS.unlink('/test_2.pdf');
  return content;
};

/**
 *
 * @param {number} doc
 * @param {Object} args
 * @param {Boolean} args.humanReadable
 */
mupdf.convertImageStart = function (doc, { humanReadable = false }) {
  wasm_convertImageStart(humanReadable);
};

/**
 *
 * @param {number} doc - doc is ignored (the active document is always the first argument, although not used here)
 * @param {Object} args
 * @param {string} args.image
 * @param {number} args.i
 * @param {number} args.pagewidth
 * @param {number} args.pageheight
 * @param {number} [args.angle=0] - Angle in degrees to rotate the image counter-clockwise.
 */
mupdf.convertImageAddPage = function (doc, {
  image, i, pagewidth, pageheight, angle = 0,
}) {
  const imgData = new Uint8Array(atob(image.split(',')[1])
    .split('')
    .map((c) => c.charCodeAt(0)));

  // Despite the images being named as PNG, they can be any format supported by mupdf.
  Module.FS_createDataFile('/', `${String(i)}.png`, imgData, 1, 1, 1);

  wasm_convertImageAddPage(i, pagewidth, pageheight, angle);

  FS.unlink(`${String(i)}.png`);
};

mupdf.convertImageEnd = function () {
  wasm_convertImageEnd();
  const content = FS.readFile('/download.pdf');
  FS.unlink('/download.pdf');
  return content;
};

/**
 *
 * @param {number} doc - Ignored (included as boilerplate for consistency with other functions).
 * @param {Object} args
 * @param {number} args.doc1 - Document to write.
 * @param {number} [args.minpage=0] - First page to include in the output PDF. Default is 0.
 * @param {number} [args.maxpage=-1] - Last page to include in the output PDF. Default is -1 (all pages).
 * @param {number} [args.pagewidth=-1] - Width of the pages in the output PDF. Default is -1 (same as input).
 * @param {number} [args.pageheight=-1] - Height of the pages in the output PDF. Default is -1 (same as input).
 * @param {Boolean} [args.humanReadable=false]
 * @returns
 */
mupdf.run = function (doc, {
  doc1, minpage = 0, maxpage = -1, pagewidth = -1, pageheight = -1, humanReadable = false,
}) {
  wasm_runPDF(doc1, minpage, maxpage, pagewidth, pageheight, humanReadable);
  const content = FS.readFile('/download.pdf');

  FS.unlink('/download.pdf');
  return content;
};

mupdf.openDocument = function (data, magic) {
  const n = data.byteLength;
  const ptr = Module._malloc(n);
  const src = new Uint8Array(data);
  Module.HEAPU8.set(src, ptr);
  return mupdf.openDocumentFromBuffer(magic, ptr, n);
};

/**
 *
 * @param {number} doc
 * @param {Object} args
 * @param {number} args.page
 * @param {number} args.dpi
 * @param {boolean} [args.color=true]
 * @param {boolean} [args.skipText=false]
 * @returns
 */
mupdf.drawPageAsPNG = function (doc, {
  page, dpi, color = true, skipText = false,
}) {
  if (color) {
    mupdf.doDrawPageAsPNG(doc, page, dpi, skipText);
  } else {
    mupdf.doDrawPageAsPNGGray(doc, page, dpi, skipText);
  }

  const n = mupdf.getLastDrawSize();
  const p = mupdf.getLastDrawData();
  return `data:image/png;base64,${arrayBufferToBase64(Module.HEAPU8.buffer.slice(p, p + n))}`;
};

mupdf.documentOutline = function (doc) {
  function makeOutline(node) {
    const list = [];
    while (node) {
      const entry = {
        title: mupdf.outlineTitle(node),
        page: mupdf.outlinePage(doc, node),
      };
      const down = mupdf.outlineDown(node);
      if (down) entry.down = makeOutline(down);
      list.push(entry);
      node = mupdf.outlineNext(node);
    }
    return list;
  }
  const root = mupdf.loadOutline(doc);
  if (root) {
    let list = null;
    try {
      list = makeOutline(root);
    } finally {
      mupdf.freeOutline(root);
    }
    return list;
  }
  return null;
};

mupdf.pageSizes = function (doc, dpi) {
  const list = [];
  const n = mupdf.countPages(doc);
  for (let i = 1; i <= n; ++i) {
    const w = mupdf.pageWidth(doc, i, dpi);
    const h = mupdf.pageHeight(doc, i, dpi);
    list[i] = [w, h];
  }
  return list;
};

mupdf.pageLinks = function (doc, page, dpi) {
  return JSON.parse(mupdf.pageLinksJSON(doc, page, dpi));
};

mupdf.search = function (doc, page, dpi, needle) {
  return JSON.parse(mupdf.searchJSON(doc, page, dpi, needle));
};

const handleMessage = (data) => {
  const [func, args, id] = data;
  if (!ready) {
    parentPort.postMessage(['ERROR', id, { name: 'NotReadyError', message: 'WASM module is not ready yet' }]);
    return;
  }
  try {
    const result = mupdf[func](...args);
    if (result instanceof ArrayBuffer) parentPort.postMessage(['RESULT', id, result], [result]);
    else if (result?.buffer instanceof ArrayBuffer) {
      parentPort.postMessage(['RESULT', id, result], [result.buffer]);
    } else parentPort.postMessage(['RESULT', id, result]);
  } catch (error) {
    parentPort.postMessage(['ERROR', id, { name: error.name, message: error.message }]);
  }
};

if (typeof process === 'undefined') {
  onmessage = (event) => handleMessage(event.data);
} else {
  parentPort.on('message', handleMessage);
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".scribe.min.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			542: 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkScribeOCR"] = self["webpackChunkScribeOCR"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(2542);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
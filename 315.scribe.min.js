(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ScribeOCR"] = factory();
	else
		root["ScribeOCR"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 2848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "6268847f8e85d7daaa2d.js";

/***/ }),

/***/ 8264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "4ab27dba89df7d4d6803.js";

/***/ }),

/***/ 2400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "40c37e47b21784e97d41.js";

/***/ }),

/***/ 497:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ca: () => (/* binding */ ca)
/* harmony export */ });
/* harmony import */ var _utils_imageUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5968);


class ca {
  /** @type {import('canvaskit-wasm').CanvasKit} */
  static CanvasKit;

  static getCanvasKit = async () => {
    if (typeof process === 'undefined') {
      throw new Error('getCanvasKit is only available in Node.js');
    } else {
      if (!ca.CanvasKit) {
        // This weirdness is required for types to work for some reason.
        // https://stackoverflow.com/a/69694837
        const canvasKitImport = await Promise.all(/* import() */[__webpack_require__.e(468), __webpack_require__.e(479)]).then(__webpack_require__.t.bind(__webpack_require__, 9468, 19));
        const CanvasKitInit = canvasKitImport.default;
        ca.CanvasKit = await CanvasKitInit();
      }
      return ca.CanvasKit;
    }
  };

  /**
   *
   * @param {number} width
   * @param {number} height
   */
  static createCanvas = async (width, height) => {
    if (typeof process === 'undefined') {
      return new OffscreenCanvas(width, height);
    }
    const canvasKit = await ca.getCanvasKit();
    return canvasKit.MakeCanvas(width, height);
  };

  /**
   * Handles various image formats, always returns a ImageBitmap.
   *
   * @param {string|ImageBitmap|Promise<string>|Promise<ImageBitmap>} img
   * @returns {Promise<ImageBitmap>}
   */
  static getImageBitmap = async (img) => {
    img = await img;
    if (img === undefined) throw new Error('Input is undefined');
    if (img === null) throw new Error('Input is null');

    if (typeof img === 'string') {
      if (typeof process === 'undefined') {
        const imgBlob = (0,_utils_imageUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .imageStrToBlob */ .hP)(img);
        const imgBit = await createImageBitmap(imgBlob);
        return imgBit;
      }

      const imgData = new Uint8Array(atob(img.split(',')[1])
        .split('')
        .map((c) => c.charCodeAt(0)));

      const canvasKit = await ca.getCanvasKit();

      const imgBit = await canvasKit.MakeImageFromEncoded(imgData);
      return imgBit;
    }

    // In Node.js the input is assumed to be already compatible with the `canvas.drawImage` method.
    // Additionally, `ImageBitmap` does not exist within the Node canvas package.
    // Second condition exists for type detection purposes.
    if (!(typeof process === 'undefined') && (typeof img !== 'string') && (typeof img !== 'number')) return img;

    return img;
  };

  static dummyCanvasPromise = ca.createCanvas(1, 1);

  /**
   *
   * @param {FontContainerFont} fontObj
   */
  static registerFontObj = async (fontObj) => {
    if (typeof process === 'undefined') {
      throw new Error('registerFontObj is only available in Node.js');
    } else {
      const dummyCanvas = await ca.dummyCanvasPromise;

      const fs = await __webpack_require__.e(/* import() */ 158).then(__webpack_require__.t.bind(__webpack_require__, 9158, 19));
      const fontBuffer = typeof fontObj.src === 'string' ? fs.readFileSync(fontObj.src) : fontObj.src;

      dummyCanvas.loadFont(fontBuffer, {
        family: fontObj.fontFaceName,
        style: fontObj.fontFaceStyle,
        weight: fontObj.fontFaceWeight,
      });
    }
  };
}


/***/ }),

/***/ 7384:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ opt)
/* harmony export */ });
/* unused harmony export inputData */
class opt {
  static ligatures = true;

  static kerning = true;

  static omitNativeText = false;

  static extractText = false;

  static enableUpscale = false;

  static ignorePunct = false;

  static ignoreCap = false;

  static ignoreExtra = false;

  static confThreshHigh = 85;

  static confThreshMed = 75;

  static addOverlay = true;

  static standardizePageSize = false;

  static humanReadablePDF = false;

  static intermediatePDF = false;

  static reflow = true;

  static pageBreaks = true;

  /** @type {("invis"|"ebook"|"eval"|"proof")} */
  static displayMode = 'proof';

  /** @type {('color'|'gray'|'binary')} */
  static colorMode = 'color';

  static overlayOpacity = 80;

  static autoRotate = true;

  static enableLayout = false;

  static xlsxFilenameColumn = true;

  static xlsxPageNumberColumn = true;

  static saveDebugImages = false;

  static warningHandler = (x) => console.warn(x);

  static errorHandler = (x) => console.error(x);

  /** @param {ProgressMessage} x */
  // eslint-disable-next-line no-unused-vars
  static progressHandler = (x) => {};

  /** Generate debug visualizations when running OCR. */
  static debugVis = false;

  static extractPDFFonts = false;

  static calcSuppFontInfo = false;

  /**
   * How to use PDF text data extracted from input PDFs (if any).
   * The `native` option controls how native text data is used (i.e. visible text rendered by the PDF viewer),
   * while the `ocr` option controls how OCR text data is used (i.e. invisible text printed over an image).
   * If `main` is true, then the data will be used as the primary data source.
   * If `supp` is true, then the data will be used as a supplemental data source (may be used to correct errors in the primary data source).
   */
  static usePDFText = {
    native: {
      supp: true,
      main: true,
    },
    ocr: {
      supp: true,
      main: false,
    },
  };

  /**
   * Number of workers to use. Must be set prior to initialization.
   * If set to `null` (default), the number of workers will be set up to 6 (browser) or 8 (node),
   * if the system has enough resources.
   * @type {?number}
   */
  static workerN = null;
}

class inputData {
  /** `true` if OCR data exists (whether from upload or built-in engine) */
  static xmlMode = (/* unused pure expression or super */ null && ([]));

  /** `true` if user uploaded pdf */
  static pdfMode = (/* unused pure expression or super */ null && (false));

  /** @type {?('text'|'ocr'|'image')} */
  static pdfType = (/* unused pure expression or super */ null && (null));

  /** `true` if user uploaded image files (.png, .jpeg) */
  static imageMode = (/* unused pure expression or super */ null && (false));

  /** `true` if user re-uploaded HOCR data created by Scribe OCR */
  static resumeMode = (/* unused pure expression or super */ null && (false));

  /** `true` if ground truth data is uploaded */
  static evalMode = (/* unused pure expression or super */ null && (false));

  static inputFileNames = (/* unused pure expression or super */ null && ([]));

  static defaultDownloadFileName = (/* unused pure expression or super */ null && (''));

  static pageCount = (/* unused pure expression or super */ null && (0));

  static clear = (/* unused pure expression or super */ null && (() => {
    inputData.xmlMode.length = 0;
    inputData.pdfMode = false;
    inputData.imageMode = false;
    inputData.resumeMode = false;
    inputData.evalMode = false;
    inputData.inputFileNames = [];
    inputData.defaultDownloadFileName = '';
    inputData.pageCount = 0;
  }));
}


/***/ }),

/***/ 3695:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cs: () => (/* binding */ loadFontsFromSource),
/* harmony export */   a4: () => (/* binding */ FontCont)
/* harmony export */ });
/* unused harmony exports checkMultiFontMode, loadOpentype, loadFontFace, loadFont, FontContainerFont, loadFontContainerFamily */
/* harmony import */ var _lib_opentype_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8742);
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2961);
/* harmony import */ var _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(497);
// File summary:
// Utility functions used for loading fonts.
// To make sure what the user sees on the canvas matches the final pdf output,
// all fonts should have an identical OpenType.js and FontFace version.

// Node.js case




if (typeof process === 'object') {
  // @ts-ignore
  globalThis.self = globalThis;
  // @ts-ignore
  const { createRequire } = await __webpack_require__.e(/* import() */ 504).then(__webpack_require__.t.bind(__webpack_require__, 9504, 19));
  globalThis.require = createRequire("file:///Users/aswinck/Documents/01022025/scribe.js/js/containers/fontContainer.js");
  const { fileURLToPath } = await Promise.all(/* import() */[__webpack_require__.e(835), __webpack_require__.e(634)]).then(__webpack_require__.t.bind(__webpack_require__, 8835, 19));
  const { dirname } = await __webpack_require__.e(/* import() */ 975).then(__webpack_require__.t.bind(__webpack_require__, 7975, 19));
  globalThis.__dirname = dirname(fileURLToPath("file:///Users/aswinck/Documents/01022025/scribe.js/js/containers/fontContainer.js"));
}

/**
 * Checks whether `multiFontMode` should be enabled or disabled.
 * @param {Object.<string, FontMetricsFamily>} fontMetricsObj
 *
 * Usually (including when the built-in OCR engine is used) we will have metrics for individual font families,
 * which are used to optimize the appropriate fonts ("multiFontMode" is `true` in this case).
 * However, it is possible for the user to upload input data with character-level positioning information
 * but no font identification information for most or all words.
 * If this is encountered the "default" metric is applied to the default font ("multiFontMode" is `false` in this case).
 */
function checkMultiFontMode(fontMetricsObj) {
  let defaultFontObs = 0;
  let namedFontObs = 0;
  if (fontMetricsObj.Default?.obs) { defaultFontObs += (fontMetricsObj.Default?.obs || 0); }
  if (fontMetricsObj.SerifDefault?.obs) { namedFontObs += (fontMetricsObj.SerifDefault?.obs || 0); }
  if (fontMetricsObj.SansDefault?.obs) { namedFontObs += (fontMetricsObj.SansDefault?.obs || 0); }

  return namedFontObs > defaultFontObs;
}

/**
 * @param {string|ArrayBuffer} src
 * @param {?Object.<string, number>} [kerningPairs=null]
 */
async function loadOpentype(src, kerningPairs = null) {
  const font = typeof (src) === 'string' ? await _lib_opentype_module_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].load */ .Ay.load(src) : await _lib_opentype_module_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].parse */ .Ay.parse(src, { lowMemory: false });
  font.tables.gsub = null;
  // Re-apply kerningPairs object so when toArrayBuffer is called on this font later (when making a pdf) kerning data will be included
  if (kerningPairs) font.kerningPairs = kerningPairs;
  return font;
}

const fontFaceObj = {};

/**
 * Load font as FontFace and add to the document FontFaceSet.
 * If a FontFace already exists with the same name, it is deleted and replaced.
 *
 * @param {string} fontFamily - Font family name
 * @param {string} fontStyle - Font style.  May only be "normal" or "italic",
 *   as small-caps fonts should be loaded as a "normal" variant with a different font name.
 * @param {string} fontWeight
 * @param {string|ArrayBuffer} src - Font source
 */
function loadFontFace(fontFamily, fontStyle, fontWeight, src) {
  const src1 = typeof (src) === 'string' ? `url(${src})` : src;

  const fontFace = new FontFace(fontFamily, src1, { style: fontStyle, weight: fontWeight });

  if (fontFace.status === 'error') throw new Error(`FontFace failed to load: ${fontFamily} ${fontStyle} ${fontWeight}`);

  // Fonts are stored in `document.fonts` for the main thread and `WorkerGlobalScope.fonts` for workers
  const fontSet = globalThis.document ? globalThis.document.fonts : globalThis.fonts;

  // As FontFace objects are added to the document fonts as a side effect,
  // they need to be kept track of and manually deleted to correctly replace.
  if (typeof (fontFaceObj[fontFamily]) === 'undefined') {
    fontFaceObj[fontFamily] = {};
  }

  if (typeof (fontFaceObj[fontFamily][fontStyle]) === 'undefined') {
    fontFaceObj[fontFamily][fontStyle] = {};
  }

  // Delete font if it already exists
  if (typeof (fontFaceObj[fontFamily][fontStyle][fontWeight]) !== 'undefined') {
    fontSet.delete(fontFaceObj[fontFamily][fontStyle][fontWeight]);
  }

  // Stored font for future, so it can be deleted if needed
  fontFaceObj[fontFamily][fontStyle][fontWeight] = fontFace;

  // Force loading to occur now
  fontFace.load();

  // Add font to document
  fontSet.add(fontFace);

  return fontFace;
}

/**
 * Load font from source and return a FontContainerFont object.
 * This function is used to load the Chinese font.
 * @param {string} family
 * @param {string} style
 * @param {("sans"|"serif")} type
 * @param {ArrayBuffer} src
 * @param {boolean} opt
 *
 */
async function loadFont(family, style, type, src, opt) {
  const fontObj = await loadOpentype(src);
  return new FontContainerFont(family, style, src, opt, fontObj);
}

/**
 *
 * @param {string} family
 * @param {string} style
 * @param {ArrayBuffer} src
 * @param {boolean} opt
 * @param {opentype.Font} opentypeObj - Kerning paris to re-apply
 * @property {string} family -
 * @property {string} style -
 * @property {ArrayBuffer} src
 * @property {opentype.Font} opentype -
 * @property {string} fontFaceName -
 * @property {string} fontFaceStyle -
 * @property {boolean} opt -
 * @property {string} type -
 *
 * A FontFace object is created and added to the document FontFaceSet, however this FontFace object is intentionally not included in the `fontContainerFont` object.
 * First, it is not necessary.  Setting the font on a canvas (the only reason loading a `FontFace` is needed) is done through refering `fontFaceName` and `fontFaceStyle`.
 * Second, it results in errors being thrown when used in Node.js, as `FontFace` will be undefined in this case.
 */
function FontContainerFont(family, style, src, opt, opentypeObj) {
  // As FontFace objects are included in the document FontFaceSet object,
  // they need to all have unique names.
  let fontFaceName = family;
  if (opt) fontFaceName += ' Opt';

  /** @type {string} */
  this.family = family;
  /** @type {string} */
  this.style = style;
  /** @type {boolean} */
  this.opt = opt;
  /** @type {ArrayBuffer} */
  this.src = src;
  /** @type {opentype.Font} */
  this.opentype = opentypeObj;
  /** @type {string} */
  this.fontFaceName = fontFaceName;
  /** @type {('normal'|'italic')} */
  this.fontFaceStyle = this.style === 'italic' ? 'italic' : 'normal';
  /** @type {('normal'|'bold')} */
  this.fontFaceWeight = this.style === 'bold' ? 'bold' : 'normal';
  /** @type {("sans"|"serif")} */
  this.type = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .determineSansSerif */ .Mw)(this.family) === 'SansDefault' ? 'sans' : 'serif';
  this.smallCapsMult = 0.75;
  /**
   * @type {boolean} - Disable font. This is used to prevent a flawed font extracted from a PDF from being used.
   */
  this.disable = false;

  if (typeof FontFace !== 'undefined') {
    loadFontFace(this.fontFaceName, this.fontFaceStyle, this.fontFaceWeight, this.src);
  } else {
    _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_2__.ca.registerFontObj(this);
  }
}

/**
 *
 * @param {string} family
 * @param {fontSrcBuiltIn|fontSrcUpload} src
 * @param {boolean} opt
 * @returns {Promise<FontContainerFamily>}
 */
async function loadFontContainerFamily(family, src, opt = false) {
  /** @type {FontContainerFamily} */
  const res = {
    normal: null,
    italic: null,
    bold: null,
  };

  /**
   *
   * @param {('normal'|'bold'|'italic')} type
   * @returns
   */
  const loadType = (type) => new Promise((resolve) => {
    const srcType = (src[type]);
    if (!srcType) {
      resolve(false);
      return;
    }
    // const scrNormal = typeof srcType === 'string' ? getFontAbsPath(srcType) : srcType;
    loadOpentype(srcType).then((font) => {
      res[type] = new FontContainerFont(family, type, srcType, opt, font);
      resolve(true);
    });
  });

  Promise.allSettled([loadType('normal'), loadType('italic'), loadType('bold')]);

  return res;
}

/**
 * @param {Object<string, fontSrcBuiltIn|fontSrcUpload>} srcObj
 * @param {boolean} opt
 * @returns
 */
async function loadFontsFromSource(srcObj, opt = false) {
  /** @type {Object<string, Promise<FontContainerFamily>>} */
  const fontObjPromise = {};
  for (const [family, src] of Object.entries(srcObj)) {
    fontObjPromise[family] = loadFontContainerFamily(family, src, opt);
  }
  /** @type {Object<string, FontContainerFamily>} */
  const fontObj = {};
  for (const [key, value] of Object.entries(fontObjPromise)) {
    fontObj[key] = await value;
  }
  return fontObj;
}

// FontCont must contain no font data when initialized, and no data should be defined in this file.
// This is because this file is run both from the main thread and workers, and fonts are defined different ways in each.
// In the main thread, "raw" fonts are loaded from fetch requests, however in workers they are loaded from the main thread.
class FontCont {
  /** @type {?FontContainer} */
  static raw = null;

  /** @type {?FontContainer} */
  static opt = null;

  /** @type {?Object<string, FontContainerFamilyUpload>} */
  static doc = null;

  /** @type {?FontContainer} */
  static export = null;

  static supp = {
    /** @type {?FontContainerFont} */
    chi_sim: null,
  };

  /** Optimized fonts will be used when believed to improve quality. */
  static enableOpt = false;

  /** Optimized fonts will always be used when they exist, even if believed to reduce quality. */
  static forceOpt = false;

  /** @type {?Awaited<ReturnType<import('../fontEval.js').evaluateFonts>>} */
  static rawMetrics = null;

  /** @type {?Awaited<ReturnType<import('../fontEval.js').evaluateFonts>>} */
  static optMetrics = null;

  static defaultFontName = 'SerifDefault';

  static serifDefaultName = 'NimbusRomNo9L';

  static sansDefaultName = 'NimbusSans';

  /**
   * If `false`, 'Courier' will not be cleaned to Nimbus Mono.
   * This setting is useful because Tesseract sometimes misidentifies fonts as Courier, and when not the document default, Nimbus Mono is almost always incorrect.
   * Even with this setting `false`, Nimbus Mono will still be used when the font is exactly 'NimbusMono' and Nimbus Mono can still be the document default font.
   */
  static enableCleanToNimbusMono = false;

  /** @type {?('latin'|'all')} */
  static glyphSet = null;

  /**
   * Load fonts from an ArrayBuffer containing arbitrary font data.
   * Supports .ttf, .otf, and .woff formats.
   * This function should only be used for fonts we do not provide, such as user-uploaded fonts.
   * @param {ArrayBuffer} src
   */
  static addFontFromFile = async (src) => {
    let fontObj;
    let fontData;
    try {
      fontObj = await loadOpentype(src);
      // It is common for raw fonts embedded in PDFs to be invalid and rejected by the OTS, but running them through opentype.js fixes them.
      // This appears to be because of the way that fonts are subsetted in PDFs.
      fontData = fontObj.toArrayBuffer();
    } catch (error) {
      console.error('Error loading font.');
      console.error(error);
      return;
    }

    const fontNameEmbedded = fontObj.names.postScriptName.en;

    let fontStyle = 'normal';
    if (fontNameEmbedded.match(/italic/i)) {
      fontStyle = 'italic';
    } else if (fontNameEmbedded.match(/bold/i)) {
      fontStyle = 'bold';
    }

    // mupdf makes changes to font names, so we need to do the same.
    // Font names in the form `MEDJCO+CenturySchoolbook` are changed to `CenturySchoolbook`.
    // Spaces are replaced with underscores.
    const fontName = fontNameEmbedded.replace(/[^+]+\+/g, '').replace(/\s/g, '_');

    if (!FontCont.doc?.[fontName]?.[fontStyle]) {
      try {
        const fontContainer = new FontContainerFont(fontName, fontStyle, fontData, false, fontObj);

        if (!FontCont.doc) {
          FontCont.doc = {};
        }

        if (!FontCont.doc[fontName]) {
          FontCont.doc[fontName] = {};
        }

        FontCont.doc[fontName][fontStyle] = fontContainer;
      } catch (error) {
        console.error(`Error loading font ${fontName} ${fontStyle}.`);
      }
    } else {
      console.warn(`Font ${fontName} ${fontStyle} already exists.`);
    }
  };

  /**
   * Decide whether to use the optimized version of a font family.
   * Note that even when this function returns `true`, optimized versions of every style will not exist.
   * @param {string} family - Font family name.
   */
  static useOptFamily = (family) => {
    const raw = FontCont.raw?.[family]?.normal;
    if (!raw) return false;
    const opt = FontCont.opt?.[family]?.normal;
    if (opt && FontCont.forceOpt) {
      return true;
    // If optimized fonts are enabled (but not forced), the optimized version of a font will be used if:
    // (1) The optimized version exists
    // (2) The optimized version has a better metric (so quality should improve).
    // (3) The optimized version of the default sans/serif font also has a better metric.
    // This last condition avoids font optimization being enabled in the UI when it only improves an unused font.
    } if (opt && FontCont.enableOpt) {
      const defaultFamily = raw.type === 'serif' ? FontCont.serifDefaultName : FontCont.sansDefaultName;

      const rawMetricDefault = FontCont.rawMetrics?.[defaultFamily];
      const optMetricDefault = FontCont.optMetrics?.[defaultFamily];

      const rawMetric = FontCont.rawMetrics?.[family];
      const optMetric = FontCont.optMetrics?.[family];
      if (rawMetric && optMetric && optMetric < rawMetric && optMetricDefault < rawMetricDefault) {
        return true;
      }
    }
    return false;
  };

  /**
   * Gets a font object.  Unlike accessing the font containers directly,
   * this method allows for special values 'Default', 'SansDefault', and 'SerifDefault' to be used.
   *
   * @param {('Default'|'SansDefault'|'SerifDefault'|string)} family - Font family name.
   * @param {('normal'|'italic'|'bold'|string)} [style='normal']
   * @param {string} [lang='eng']
   * @returns {FontContainerFont}
   */
  static getFont = (family, style = 'normal', lang = 'eng') => {
    if (FontCont.doc?.[family]?.[style] && !FontCont.doc?.[family]?.[style]?.disable) {
      return FontCont.doc[family][style];
    }

    if (lang === 'chi_sim') {
      if (!FontCont.supp.chi_sim) throw new Error('chi_sim font does not exist.');
      return FontCont.supp.chi_sim;
    }

    if (!FontCont.raw) throw new Error('Raw fonts not yet initialized.');

    // Option 1: If we have access to the font, use it.
    // Option 2: If we do not have access to the font, but it closely resembles a built-in font, use the built-in font.
    if (!FontCont.raw?.[family]?.[style]) {
      if (/Times/i.test(family)) {
        family = 'NimbusRomNo9L';
      } else if (/Helvetica/i.test(family)) {
        family = 'NimbusSans';
      } else if (/Arial/i.test(family)) {
        family = 'NimbusSans';
      } else if (/Century/i.test(family)) {
        family = 'Century';
      } else if (/Palatino/i.test(family)) {
        family = 'Palatino';
      } else if (/Garamond/i.test(family)) {
        family = 'Garamond';
      } else if (/Carlito/i.test(family)) {
        family = 'Carlito';
      } else if (/Calibri/i.test(family)) {
        family = 'Carlito';
      } else if (/Courier/i.test(family) && FontCont.enableCleanToNimbusMono) {
        family = 'NimbusMono';
      }
    }

    // Option 3: If the font still is not identified, use the default sans/serif font.
    if (!FontCont.raw?.[family]?.[style]) {
      family = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .determineSansSerif */ .Mw)(family);
    }

    // This needs to come first as `defaultFontName` maps to either 'SerifDefault' or 'SansDefault'.
    if (family === 'Default') family = FontCont.defaultFontName;

    if (family === 'SerifDefault') family = FontCont.serifDefaultName;
    if (family === 'SansDefault') family = FontCont.sansDefaultName;

    /** @type {FontContainerFont} */
    let fontRes = FontCont.raw?.[family]?.[style];
    if (!fontRes) throw new Error(`Font container does not contain ${family} (${style}).`);

    const opt = FontCont.opt?.[family]?.[style];
    const useOpt = FontCont.useOptFamily(family);
    if (opt && useOpt) fontRes = opt;

    return fontRes;
  };

  /**
   *
   * @param {OcrWord} word
   */
  static getWordFont = (word) => {
    const wordFontFamily = word.font || FontCont.defaultFontName;
    return FontCont.getFont(wordFontFamily, word.style, word.lang);
  };

  /**
   * Reset font container to original state but do not unload default resources.
   */
  static clear = () => {
    FontCont.opt = null;
    FontCont.rawMetrics = null;
    FontCont.optMetrics = null;

    FontCont.enableCleanToNimbusMono = false;

    FontCont.defaultFontName = 'SerifDefault';
    FontCont.serifDefaultName = 'NimbusRomNo9L';
    FontCont.sansDefaultName = 'NimbusSans';
  };

  static terminate = () => {
    FontCont.clear();
    FontCont.raw = null;
    FontCont.glyphSet = null;
  };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 6757:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ convertPageAbbyy)
/* harmony export */ });
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7193);
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2961);
/* harmony import */ var _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5663);
/* harmony import */ var _convertPageShared_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5847);







const abbyyDropCapRegex = /<par dropCapCharsCount=['"](\d*)/i;
const abbyyLineBoxRegex = /<line baseline=['"](\d*)['"] l=['"](\d*)['"] t=['"](\d*)['"] r=['"](\d*)['"] b=['"](\d*)['"]>/i;
const abbyySplitRegex = /(?:<charParams[^>]*>\s*<\/charParams>)|(?:<\/formatting>\s*(?=<formatting))/ig;

const abbyyCharRegex = /(<formatting[^>]+>\s*)?<charParams l=['"](\d*)['"] t=['"](\d*)['"] r=['"](\d*)['"] b=['"](\d*)['"](?: suspicious=['"](\w*)['"])?[^>]*>([^<]*)<\/charParams>/ig;

const debugMode = false;

/**
 * @param {Object} params
 * @param {string} params.ocrStr
 * @param {number} params.n
 */
async function convertPageAbbyy({ ocrStr, n }) {
  // Return early if character-level data is not detected.
  // Unlike Tesseract HOCR (which by default returns word-level data which we can still use), Abbyy XML returns line-level data that is not usable.
  const pageAttrStr = ocrStr.match(/<page[^>]*>/);
  const widthStr = pageAttrStr?.[0].match(/width=['"](\d+)['"]/)?.[1];
  const heightStr = pageAttrStr?.[0].match(/height=['"](\d+)['"]/)?.[1];
  const rotationStr = pageAttrStr?.[0].match(/rotation=['"](\w+)['"]/)?.[1];

  if (!widthStr || !heightStr) throw new Error('Failed to parse page dimensions.');

  // Note: `RotatedClockwise`/`RotatedCounterclockwise` are swapped versus what one might expect, and are the oppose of how line orientation is handled below.
  // Per the Abbyy documentation, the page `rotation` is defined as "the type of rotation applied to the original page image" which implies it is the opposite of the rotation of the text.
  let pageOrientation = 0;
  if (rotationStr === 'RotatedClockwise') {
    pageOrientation = 3;
  } else if (rotationStr === 'RotatedUpsidedown') {
    pageOrientation = 2;
  } else if (rotationStr === 'RotatedCounterclockwise') {
    pageOrientation = 1;
  }

  const pageDims = { height: parseInt(heightStr), width: parseInt(widthStr) };

  const pageObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrPage */ .Ay.OcrPage(n, pageDims);

  // This condition is met for actual character errors (xml data lacks character-level data), as well as for empty pages.
  // However, the error is only shown to the user if there are no pages with valid character data.
  if (!/<charParams/i.test(ocrStr)) {
    const warn = { char: 'char_error' };

    return {
      pageObj, fontMetricsObj: {}, dataTables: new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataTablePage */ .Cd(n), warn,
    };
  }

  const tablesPage = convertTableLayoutAbbyy(n, ocrStr);

  /** @type {Array<number>} */
  const angleRisePage = [];

  function convertTextAbbyy(xmlText) {
    const textAttrStr = xmlText.match(/<text[^>]*>/);
    const textOrientationStr = textAttrStr?.[0].match(/orientation=['"](\w+)['"]/)?.[1];

    let textOrientation = 0;
    if (textOrientationStr === 'RotatedClockwise') {
      textOrientation = 1;
    } else if (textOrientationStr === 'RotatedUpsidedown') {
      textOrientation = 2;
    } else if (textOrientationStr === 'RotatedCounterclockwise') {
      textOrientation = 3;
    }

    const textOrientationFinal = (pageOrientation + textOrientation) % 4;

    function convertParAbbyy(xmlPar) {
      /** @type {Array<OcrLine>} */
      const parLineArr = [];

      function convertLineAbbyy(xmlLine) {
        const stylesLine = {};

        // Unlike Tesseract HOCR, Abbyy XML does not provide accurate metrics for determining font size, so they are calculated here.
        // Strangely, while Abbyy XML does provide a "baseline" attribute, it is often wildly incorrect (sometimes falling outside of the bounding box entirely).
        // One guess as to why is that coordinates calculated pre-dewarping are used along with a baseline calculated post-dewarping.
        // Regardless of the reason, baseline is recalculated here.
        const baselineSlopeArr = /** @type {Array<Number>} */ ([]);
        const baselineFirst = /** @type {Array<Number>} */ ([]);

        const xmlLinePreChar = xmlLine.match(/^[\s\S]*?(?=<charParams)/)?.[0];
        const xmlLineFormatting = xmlLinePreChar?.match(/<formatting[^>]+/)?.[0];
        const fontName = xmlLineFormatting?.match(/ff=['"]([^'"]*)/)?.[1];

        let dropCap = false;
        const dropCapMatch = xmlLine.match(abbyyDropCapRegex);
        if (dropCapMatch != null && parseInt(dropCapMatch[1]) > 0) {
          dropCap = true;
        }

        let lineBoxArr = xmlLine.match(abbyyLineBoxRegex);
        if (lineBoxArr == null) return;
        lineBoxArr = [...lineBoxArr].map((x) => parseInt(x));

        // Unlike Tesseract, Abbyy XML does not have a native "word" unit (it provides only lines and letters).
        // Therefore, lines are split into words on either (1) a space character or (2) a change in formatting.

        // TODO: Investigate possible fix for too many words issue:
        // The reason for splitting letters at every formatting change is (1) this splits up superscripts from
        // the words they are attached to and (2) to split up normal and italic parts of text (even if not separated by a space),
        // as the canvas GUI currently only supports one font style per word.
        // Unfortunately, in some documents Abbyy has the nonsensical habbit of using formatting tags just to change font size
        // on a specific character (e.g. switching from font size 10.5 to 11 for a single period).
        // When this happens, the heuristic here results in too many words being created--not sure if there's an easy fix.

        // Replace character identified as tab with space (so it is split into separate word)
        // For whatever reason many non-tab values can be found in elements where isTab is true (e.g. "_", "....")
        xmlLine = xmlLine.replaceAll(/isTab=['"](?:1|true)['"][^>]*>[^<]+/ig, '> ');

        // These regex remove blank characters that occur next to changes in formatting to avoid making too many words.
        // Note: Abbyy is inconsistent regarding where formatting elements are placed.
        // Sometimes the <format> comes after the space between words, and sometimes it comes before the space between words.
        xmlLine = xmlLine.replaceAll(/(<\/formatting><formatting[^>]*>\s*)<charParams[^>]*>\s*<\/charParams>/ig, '$1');
        xmlLine = xmlLine.replaceAll(/<charParams[^>]*>\s*<\/charParams>(\s*<\/formatting><formatting[^>]*>\s*)/ig, '$1');

        // xmlLine = xmlLine.replaceAll(/(\<\/formatting\>\<formatting[^\>]*\>)(\s*<charParams[^\>]*\>\.\<\/charParams\>)\<\/formatting\>/ig, "$1")

        const wordStrArr1 = xmlLine.split(abbyySplitRegex);

        // Account for special cases:
        // 1. Filter off any array elements that do not have a character.
        //    (This can happen ocassionally, for example when multiple spaces are next to eachother.)
        //    TODO: This will drop formatting information in edge cases--e.g. if a formatting element is followed by multiple spaces.
        //    However, hopefully these are uncommon enough that they should not be a big issue.
        // 2. Period with its own "word" due to being wrapped in separate <formatting> tags
        //    This odd behavior appears around to superscripts, and makes sense when normal text is followed by a superscript followed by a period.
        //    However, it also happens when normal text is followed by a period followed by a superscript (the normal behavior),
        //    and it does not make sense for a period to get its own word in this case.

        const wordStrArr = [];
        for (let i = 0; i < wordStrArr1.length; i++) {
          const wordStrArrI = wordStrArr1[i];
          const wordMatch = wordStrArrI.match(/>([^<>]+?)(?=<\/charParams>)/g)?.map((x) => x.substring(1));
          if (!wordMatch) {
            continue;
          } else if (wordMatch.length === 1) {
            if (wordMatch[0] === '.') {
              if (wordStrArr.length > 0 && !/superscript=['"](1|true)/i.test(wordStrArr[wordStrArr.length - 1])) {
                wordStrArr[wordStrArr.length - 1] = wordStrArr[wordStrArr.length - 1] + wordStrArrI.replace(/(<formatting[^>]+>\s*)/i, '');
                continue;
              }
            }
          }
          wordStrArr.push(wordStrArrI);
        }

        if (wordStrArr.length === 0) return;

        /** @type {Array<Array<bbox>>} */
        const bboxes = Array(wordStrArr.length);
        let text = Array(wordStrArr.length);

        /** @type {Array<Array<OcrChar>>} */
        const charObjArrLine = Array(wordStrArr.length);
        text = text.fill('');
        let styleArr = Array(wordStrArr.length);
        styleArr = styleArr.fill('normal');
        /** @type {Array<boolean>} */
        const smallCapsArr = Array(wordStrArr.length).fill(false);
        /** @type {Array<boolean>} */
        const wordSusp = Array(wordStrArr.length).fill(false);

        for (let i = 0; i < wordStrArr.length; i++) {
          const wordStr = wordStrArr[i];
          const letterArr = [...wordStr.matchAll(abbyyCharRegex)];

          if (typeof (letterArr[0][1]) !== 'undefined') {
            if (dropCap && i === 0) {
              styleArr[i] = 'dropcap';
            } else if (/superscript=['"](1|true)/i.test(letterArr[0][1])) {
              styleArr[i] = 'sup';
            } else if (/italic=['"](1|true)/i.test(letterArr[0][1])) {
              styleArr[i] = 'italic';
              stylesLine.italic = true;
            } else {
              styleArr[i] = 'normal';
              stylesLine.normal = true;
            }

            if (/smallcaps=['"](1|true)/i.test(letterArr[0][1])) {
              smallCapsArr[i] = true;
            }
          } else if (i > 0) {
            if (styleArr[i - 1] === 'dropcap') {
              styleArr[i] = 'normal';
              smallCapsArr[i] = false;
            } else {
              styleArr[i] = styleArr[i - 1];
              smallCapsArr[i] = smallCapsArr[i - 1];
            }
          }

          // Abbyy will sometimes misidentify capital letters immediately following drop caps as small caps,
          // when they are only small in relation to the drop cap (rather than the main text).
          let dropCapFix = false;
          if (dropCap && i === 1 && smallCapsArr[i]) {
            smallCapsArr[i] = false;
            dropCapFix = true;
          }

          bboxes[i] = [];

          charObjArrLine[i] = [];

          for (let j = 0; j < letterArr.length; j++) {
            // Skip letters placed at coordinate 0 (not sure why this happens)
            if (letterArr[j][2] === '0') { continue; }

            const bboxRaw = {
              l: parseInt(letterArr[j][2]),
              t: parseInt(letterArr[j][3]),
              r: parseInt(letterArr[j][4]),
              b: parseInt(letterArr[j][5]),
            };

            let bbox;
            if (textOrientationFinal === 1) {
              bbox = {
                left: Math.round(bboxRaw.t),
                top: Math.round(pageDims.width - Math.max(bboxRaw.r, bboxRaw.l)),
                right: Math.round(bboxRaw.b),
                bottom: Math.round(pageDims.width - Math.min(bboxRaw.l, bboxRaw.l)),
              };
            } else if (textOrientationFinal === 2) {
              bbox = {
                left: Math.round(pageDims.width - bboxRaw.r),
                top: Math.round(pageDims.height - bboxRaw.b),
                right: Math.round(pageDims.width - bboxRaw.l),
                bottom: Math.round(pageDims.height - bboxRaw.t),
              };
            } else if (textOrientationFinal === 3) {
              bbox = {
                left: Math.round(pageDims.height - bboxRaw.b),
                top: Math.round(Math.min(bboxRaw.l, bboxRaw.l)),
                right: Math.round(pageDims.height - bboxRaw.t),
                bottom: Math.round(Math.max(bboxRaw.r, bboxRaw.r)),
              };
            } else {
              bbox = {
                left: Math.round(bboxRaw.l),
                top: Math.round(bboxRaw.t),
                right: Math.round(bboxRaw.r),
                bottom: Math.round(bboxRaw.b),
              };
            }

            bboxes[i][j] = bbox;

            let letterSusp = false;
            if (letterArr[j][6] === '1' || letterArr[j][6] === 'true') {
              wordSusp[i] = true;
              letterSusp = true;
            }

            if (dropCapFix) {
              letterArr[j][7] = letterArr[j][7].toUpperCase();
            }

            // Handle characters escaped in XML
            letterArr[j][7] = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .unescapeXml */ .Uk)(letterArr[j][7]);

            const contentStrLetter = letterArr[j][7];

            const ascChar = _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .ascCharArr */ .xq.includes(contentStrLetter);
            const xChar = _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .xCharArr */ .oQ.includes(contentStrLetter);

            if ((ascChar || xChar) && !letterSusp && !dropCapFix && !(dropCap && i === 0)) {
              // To calculate the slope of the baseline (and therefore image angle) the position of each glyph that starts (approximately) on the
              // baseline is compared to the first such glyph.  This is less precise than a true "best fit" approach, but hopefully with enough data
              // points it will all average out.
              if (baselineFirst.length === 0) {
                baselineFirst.push(bboxes[i][j].left, bboxes[i][j].bottom);
              } else {
                const baselineSlope = (bboxes[i][j].bottom - baselineFirst[1]) / (bboxes[i][j].left - baselineFirst[0]);
                if (Number.isFinite(baselineSlope)) baselineSlopeArr.push(baselineSlope);
              }
            }

            text[i] += contentStrLetter;

            const charObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrChar */ .Ay.OcrChar(contentStrLetter, bbox);

            charObjArrLine[i].push(charObj);
          }
        }

        // While Abbyy XML already provides line bounding boxes, these have been observed to be (at times)
        // completely different than a bounding box calculated from a union of all letters in the line.
        // Therefore, the line bounding boxes are recaclculated here.
        const lineBoxArrCalc = new Array(4);
        // reduce((acc, val) => acc.concat(val), []) is used as a drop-in replacement for flat() with significantly better performance
        lineBoxArrCalc[0] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x.left).filter((x) => x > 0));
        lineBoxArrCalc[1] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x.top).filter((x) => x > 0));
        lineBoxArrCalc[2] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x.right).filter((x) => x > 0));
        lineBoxArrCalc[3] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x.bottom).filter((x) => x > 0));

        const baselineSlope = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .quantile */ .YV)(baselineSlopeArr, 0.5) || 0;

        // baselinePoint should be the offset between the bottom of the line bounding box, and the baseline at the leftmost point
        let baselinePoint = baselineFirst[1] - lineBoxArrCalc[3];
        if (baselineSlope < 0) {
          baselinePoint -= baselineSlope * (baselineFirst[0] - lineBoxArrCalc[0]);
        }
        baselinePoint = baselinePoint || 0;

        // In general, the bounding box calculated here from the individual word boundign boxes is used.
        // In a small number of cases the bounding box cannot be calculated because all individual character-level bounding boxes are at 0 (and therefore skipped)
        // In this case the original line-level bounding box from Abbyy is used
        const lineBoxArrOut = Number.isFinite(lineBoxArrCalc[0]) && Number.isFinite(lineBoxArrCalc[1]) && Number.isFinite(lineBoxArrCalc[2]) && Number.isFinite(lineBoxArrCalc[3])
          ? lineBoxArrCalc : lineBoxArr.slice(2, 6);

        const baselineOut = [(0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .round6 */ .X_)(baselineSlope), Math.round(baselinePoint)];

        const bbox = {
          left: lineBoxArrOut[0], top: lineBoxArrOut[1], right: lineBoxArrOut[2], bottom: lineBoxArrOut[3],
        };

        const lineObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrLine */ .Ay.OcrLine(pageObj, bbox, baselineOut);

        lineObj.orientation = textOrientationFinal;

        // This should be kept disabled as a rule unless debugging.
        // Enabling has caused crashes with large documents.
        if (debugMode) lineObj.raw = xmlText;

        let lettersKept = 0;
        for (let i = 0; i < text.length; i++) {
          if (text[i].trim() === '') continue;
          const bboxesI = bboxes[i];

          // Abbyy-specific fix:
          // Only values > 0 are considered, since Abbyy has been observed to frequently return incorrect "0" coordinates.
          // This frequently (but not always) occurs with superscripts.
          // If this filter leaves no remaining left/right/top/bottom coordinates, the word is skipped entirely.
          // TODO: Figure out why this happens and whether these glyphs should be dropped completely.
          const bboxesILeft = Math.min(...bboxesI.map((x) => x.left).filter((x) => x > 0));
          const bboxesIRight = Math.max(...bboxesI.map((x) => x.right).filter((x) => x > 0));
          const bboxesITop = Math.min(...bboxesI.map((x) => x.top).filter((x) => x > 0));
          const bboxesIBottom = Math.max(...bboxesI.map((x) => x.bottom).filter((x) => x > 0));

          if (!Number.isFinite(bboxesITop) || !Number.isFinite(bboxesIBottom) || !Number.isFinite(bboxesILeft) || !Number.isFinite(bboxesIRight)) {
            continue;
          }

          const bboxWord = {
            left: bboxesILeft, top: bboxesITop, right: bboxesIRight, bottom: bboxesIBottom,
          };

          const id = `word_${n + 1}_${pageObj.lines.length + 1}_${i + 1}`;

          const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, text[i], bboxWord, id);
          wordObj.chars = charObjArrLine[i];
          wordObj.conf = wordSusp[i] ? 0 : 100;

          console.assert(wordObj.chars.length === text[i].length, `Likely parsing error for word: ${id}. Number of letters in text does not match number of \`ocrChar\` objects.`);

          if (styleArr[i] === 'italic') {
            wordObj.style = 'italic';
          }

          wordObj.smallCaps = smallCapsArr[i];

          if (fontName) wordObj.font = fontName;

          if (styleArr[i] === 'sup') {
            wordObj.sup = true;
          } else if (styleArr[i] === 'dropcap') {
            wordObj.dropcap = true;
          }

          lineObj.words.push(wordObj);

          lettersKept++;
        }

        // If there are no letters in the line, drop the entire line element
        if (lettersKept === 0) return;

        pageObj.lines.push(lineObj);
        parLineArr.push(lineObj);

        // eslint-disable-next-line consistent-return
        return baselineSlope;
      }

      const lineStrArr = xmlPar.split(/<\/line>/);

      for (let i = 0; i < lineStrArr.length; i++) {
        const angle = convertLineAbbyy(lineStrArr[i]);
        if (typeof angle === 'number' && !Number.isNaN(angle)) angleRisePage.push(angle);
      }

      if (parLineArr.length === 0) return;

      const parbox = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcBboxUnion */ .gc)(parLineArr.map((x) => x.bbox));

      const parObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrPar */ .Ay.OcrPar(pageObj, parbox);

      parLineArr.forEach((x) => {
        x.par = parObj;
      });

      parObj.lines = parLineArr;
      pageObj.pars.push(parObj);
    }

    const parStrArr = xmlText.split(/<\/par>/);

    for (let i = 0; i < parStrArr.length; i++) {
      convertParAbbyy(parStrArr[i]);
    }
  }

  const textStrArr = ocrStr.split(/<\/text>/);

  for (let i = 0; i < textStrArr.length; i++) {
    convertTextAbbyy(textStrArr[i]);
  }

  const angleRiseMedian = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .mean50 */ .lW)(angleRisePage) || 0;

  const angleOut = Math.asin(angleRiseMedian) * (180 / Math.PI);

  pageObj.angle = angleOut;

  const langSet = (0,_convertPageShared_js__WEBPACK_IMPORTED_MODULE_3__/* .pass3 */ .j)(pageObj);

  return { pageObj, dataTables: tablesPage, langSet };
}

/**
 * @param {number} n
 * @param {string} ocrStr
 */
function convertTableLayoutAbbyy(n, ocrStr) {
  // Note: This assumes that block elements are not nested within table block elements
  // Not sure if this is true or not
  const tableRegex = /<block blockType=["']Table[\s\S]+?(?:<\/block>\s*)/ig;

  const tablesStrArr = ocrStr.match(tableRegex);

  const tablesPage = new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataTablePage */ .Cd(n);

  if (!tablesStrArr) return tablesPage;

  for (let i = 0; i < tablesStrArr.length; i++) {
    /** @type {Array<LayoutDataColumn>} */
    const tableBoxes = [];

    const tableStr = tablesStrArr[i];
    const tableCoords = tableStr.match(/<block blockType=['"]Table['"][^>]*?l=['"](\d+)['"] t=['"](\d+)['"] r=['"](\d+)['"] b=['"](\d+)['"]/i)?.slice(1, 5).map((x) => parseInt(x));

    if (!tableCoords || tableCoords[0] === undefined || tableCoords[1] === undefined || tableCoords[2] === undefined || tableCoords[3] === undefined) {
      console.log('Failed to parse table');
      continue;
    }

    let leftLast = tableCoords?.[0];

    const rows = tableStr.match(/<row[\s\S]+?(?:<\/row>\s*)/g);

    // Columns widths are calculated using the cells in a single row.
    // The first row is used unless it contains cells spanning multiple columns,
    // in which case the second row is used.
    const firstRow = rows?.[1] && /colSpan/.test(rows[0]) ? rows[1] : rows?.[0];

    const firstRowCells = firstRow?.match(/<cell[\s\S]+?(?:<\/cell>\s*)/ig);

    if (leftLast === null || leftLast === undefined || !firstRowCells || !rows) {
      console.warn('Failed to parse table:');
      console.warn(tableStr);
      continue;
    }

    const table = new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataTable */ .hw(tablesPage);

    for (let j = 0; j < firstRowCells.length; j++) {
      const cell = firstRowCells[j];
      const cellWidth = parseInt(cell.match(/width=['"](\d+)['"]/)?.[1]);

      const cellLeft = leftLast;
      const cellRight = leftLast + cellWidth;

      leftLast = cellRight;

      tableBoxes.push(new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataColumn */ .B2({
        left: cellLeft, top: tableCoords[1], right: cellRight, bottom: tableCoords[3],
      }, table));
    }

    // Abbyy sometimes provides column widths that are incorrect
    // If the column widths do not add up to the table width, the column widths are re-caculated from scratch.
    if (Math.abs(leftLast - tableCoords[2]) > 10) {
      /** @type {Array<Array<number>>} */
      let colLeftArr = [];
      /** @type {Array<Array<number>>} */
      let colRightArr = [];

      for (let j = 0; j < rows.length; j++) {
        const cells = rows[j].match(/<cell[\s\S]+?(?:<\/cell>\s*)/ig);

        if (!cells) {
          console.warn('Failed to parse rows:');
          continue;
        }

        for (let k = 0; k < cells.length; k++) {
          // Extract coordinates for every element in the cell with coordinates
          const coordsArrStr = cells[k].match(/l=['"](\d+)['"] t=['"](\d+)['"] r=['"](\d+)['"] b=['"](\d+)['"]/ig);
          if (!coordsArrStr) continue;
          const coordsArr = coordsArrStr.map((x) => x.match(/\d+/g).map((y) => parseInt(y)));
          const cellLeft = Math.min(...coordsArr.map((x) => x[0]));
          const cellRight = Math.max(...coordsArr.map((x) => x[2]));
          if (!colLeftArr[k]) {
            colLeftArr[k] = [];
            colRightArr[k] = [];
          }
          colLeftArr[k].push(cellLeft);
          colRightArr[k].push(cellRight);
        }
      }

      // Columns that contain no data are removed
      colLeftArr = colLeftArr.filter((x) => x);
      colRightArr = colRightArr.filter((x) => x);

      // Calculate the minimum left bound of each column
      const colLeftMin = colLeftArr.map((x) => Math.min(...x));

      // Calculate the max right bound of each column, after removing observations past the minimum left bound of the next column.
      // This filter is intended to remove cells that span multiple rows.
      const colRightMax = [];
      for (let j = 0; j < colRightArr.length; j++) {
        const colRightArrJ = j + 1 === colRightArr.length ? colRightArr[j] : colRightArr[j].filter((x) => x < colLeftMin[j + 1]);
        colRightMax.push(Math.max(...colRightArrJ));
      }

      // Re-create boxes
      tableBoxes.length = 0;
      for (let j = 0; j < colLeftArr.length; j++) {
        let cellLeft;
        if (j === 0) {
          cellLeft = tableCoords[0];
        } else if (!Number.isFinite(colRightMax[j - 1])) {
          cellLeft = Math.round(colLeftMin[j]);
        } else {
          cellLeft = Math.round((colLeftMin[j] + colRightMax[j - 1]) / 2);
        }

        let cellRight;
        if (j + 1 === colLeftArr.length) {
          cellRight = tableCoords[2];
        } else if (!Number.isFinite(colRightMax[j])) {
          cellRight = colLeftMin[j + 1];
        } else {
          cellRight = Math.round((colLeftMin[j + 1] + colRightMax[j]) / 2);
        }

        tableBoxes.push(new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataColumn */ .B2({
          left: cellLeft, top: tableCoords[1], right: cellRight, bottom: tableCoords[3],
        }, table));
      }

      if (debugMode) console.log(`Table width does not match sum of rows (${String(tableCoords[2])} vs ${String(leftLast)}), calculated new layout boxes using column contents.`);
    }

    // const table = new LayoutDataTable(i);
    table.boxes = tableBoxes;

    tablesPage.tables.push(table);
  }

  return tablesPage;
}


/***/ }),

/***/ 2980:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ convertPageBlocks)
/* harmony export */ });
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7193);
/* harmony import */ var _convertPageShared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5847);
/* harmony import */ var _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5663);
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2961);







const baselineCharArr = [..._utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_3__/* .xCharArr */ .oQ, ..._utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_3__/* .ascCharArr */ .xq];

/**
 * @param {Object} params
 * @param {Array<import('@scribe.js/tesseract.js').Block>} params.ocrBlocks
 * @param {number} params.n
 * @param {dims} params.pageDims
 * @param {number} params.rotateAngle - The angle that the input image is rotated prior to recognition.
 *    This is used to transform OCR coordinates back to the original coordinate space after recognizing a rotated intermediate image.
 * @param {boolean} params.keepItalic - If true, italic tags (`<em>`) are honored.  This is false by default,
 *    as vanilla Tesseract does not recognize italic text in a way that is reliable.
 *    This is fixed for Legacy recognition in the included custom build of Tesseract.
 * @param {boolean} [params.upscale=false]
 */
async function convertPageBlocks({
  ocrBlocks, n, pageDims, keepItalic, rotateAngle, upscale = false,
}) {
  rotateAngle = rotateAngle || 0;

  if (upscale) {
    pageDims.height *= 2;
    pageDims.width *= 2;
  }

  const currentLang = 'eng';

  const pageObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrPage */ .Ay.OcrPage(n, pageDims);

  let wordCount = 0;

  for (let i = 0; i < ocrBlocks.length; i++) {
    const block = ocrBlocks[i];
    for (let j = 0; j < block.paragraphs.length; j++) {
      const paragraph = block.paragraphs[j];

      const parbox = {
        left: paragraph.bbox.x0, top: paragraph.bbox.y0, right: paragraph.bbox.x1, bottom: paragraph.bbox.y1,
      };

      const parObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrPar */ .Ay.OcrPar(pageObj, parbox);

      for (let k = 0; k < paragraph.lines.length; k++) {
        const line = paragraph.lines[k];

        const linebox = {
          left: line.bbox.x0, top: line.bbox.y0, right: line.bbox.x1, bottom: line.bbox.y1,
        };

        const x0 = line.baseline.x0 - linebox.left;
        const x1 = line.baseline.x1 - linebox.left;
        const y0 = line.baseline.y0 - linebox.bottom;
        const y1 = line.baseline.y1 - linebox.bottom;

        const baselineSlope = (y1 - y0) / (x1 - x0);
        const baselinePoint = y0 - baselineSlope * x0;

        const baseline = [baselineSlope, baselinePoint];

        // This case presumably happens for vertical text, which we currently do not support.
        if (!Number.isFinite(baselineSlope) || !Number.isFinite(baselinePoint)) {
          baseline[0] = 0;
          baseline[1] = 0;
        }

        const ascHeight = line.rowAttributes.row_height - line.rowAttributes.descenders;
        const xHeight = line.rowAttributes.row_height - line.rowAttributes.descenders - line.rowAttributes.ascenders;

        const lineObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrLine */ .Ay.OcrLine(pageObj, linebox, baseline, ascHeight, xHeight);
        lineObj.par = parObj;

        for (let l = 0; l < line.words.length; l++) {
          const word = line.words[l];

          const wordbox = {
            left: word.bbox.x0, top: word.bbox.y0, right: word.bbox.x1, bottom: word.bbox.y1,
          };

          const id = `word_${n + 1}_${wordCount}`;
          wordCount++;

          // Words containing only space characters are skipped.
          if (word.text.trim() === '') continue;

          let wordLang = word.language || currentLang;
          if (['chi_sim', 'chi_tra'].includes(wordLang)) {
            const { han: hanChars, latin: latinChars } = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_3__/* .getTextScript */ .TY)(word.text);

            if (hanChars === 0) {
              // Do not let languages be switched for a word that contains 0 Han characters.
              if (!['chi_sim', 'chi_tra'].includes(currentLang)) {
                wordLang = currentLang;
              // Do not let language be Chinese for any word that contains no Han characters and >0 non-Chinese characters.
              // TODO: Assign the appropriate Latin language (not necessarily English).
              } else if (latinChars > 0) {
                wordLang = 'eng';
              }
            }
          }

          // For Chinese, individual characters are treated as words.
          if (['chi_sim', 'chi_tra'].includes(wordLang)) {
            for (let m = 0; m < word.symbols.length; m++) {
              const symbol = word.symbols[m];

              const symbolbox = {
                left: symbol.bbox.x0, top: symbol.bbox.y0, right: symbol.bbox.x1, bottom: symbol.bbox.y1,
              };

              const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, symbol.text, symbolbox, `${id}_${m}`);
              wordObj.conf = symbol.confidence;
              wordObj.lang = wordLang;

              lineObj.words.push(wordObj);
            }
            continue;
          }

          const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, word.text.trim(), wordbox, id);
          wordObj.lang = word.language;
          wordObj.conf = word.confidence;

          // Keep alternative choices if they have higher confidence than the primary choice.
          // This happens when the original "best choice" is rejected due to an ad-hoc penalty, most frequently because it is a non-dictionary word.
          if (word.choices.length > 0) {
            word.choices.sort((a, b) => b.confidence - a.confidence);
            if (word.choices[0].text !== word.text) {
              wordObj.textAlt = word.choices[0].text;
            }
          }

          // The `word` object has a `is_italic` property, but it is always false.
          // Therefore, the font name is checked to determine if the word is italic.
          // See: https://github.com/naptha/tesseract.js/issues/907
          if (keepItalic && /italic/i.test(word.font_name)) wordObj.style = 'italic';

          // Our fork of Tesseract Legacy should be able to recognize fonts, so this information is included.
          // The generic HOCR importer does not include font information, as this is assumed to be unreliable.
          wordObj.font = word.font_name;

          wordObj.chars = [];
          for (let m = 0; m < word.symbols.length; m++) {
            const symbol = word.symbols[m];

            // The LSTM model sometimes produces space characters.
            if (!symbol.text?.trim()) continue;

            const symbolbox = {
              left: symbol.bbox.x0, top: symbol.bbox.y0, right: symbol.bbox.x1, bottom: symbol.bbox.y1,
            };

            const charObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrChar */ .Ay.OcrChar(symbol.text, symbolbox);

            wordObj.chars.push(charObj);
          }

          lineObj.words.push(wordObj);
        }

        if (lineObj.words.length > 0) {
          // If the line contains only one word and this is Tesseract Legacy (so bounding boxes are accurate), re-calculate the baseline.
          // Tesseract calculates the baseline early in the recognition process under the assumption that most text is on the baseline,
          // so baselines are frequently inaccurate for single-word lines.
          // `keepItalic` is used to determine if this is using Tesseract Legacy; should be edited for clarity.
          if (lineObj.words.length === 1 && keepItalic && lineObj.words[0].chars) {
            const baselineBottomArr = lineObj.words[0].chars.filter((char) => baselineCharArr.includes(char.text)).map((char) => char.bbox.bottom);
            if (baselineBottomArr.length * 2 > lineObj.words[0].chars.length) {
              const baselineBottom = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_3__/* .mean50 */ .lW)(baselineBottomArr);
              lineObj.baseline[1] = baselineBottom - lineObj.bbox.bottom;
            }
          }
          pageObj.lines.push(lineObj);
          parObj.lines.push(lineObj);
        }
      }
      if (parObj.lines.length > 0) {
        pageObj.pars.push(parObj);
      }
    }
  }

  pageObj.angle = rotateAngle;

  if (upscale) _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.scalePage(pageObj, 0.5);

  (0,_convertPageShared_js__WEBPACK_IMPORTED_MODULE_1__/* .pass2 */ .c)(pageObj, rotateAngle);
  const langSet = (0,_convertPageShared_js__WEBPACK_IMPORTED_MODULE_1__/* .pass3 */ .j)(pageObj);

  return {
    pageObj, dataTables: new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataTablePage */ .Cd(n), warn: { char: '' }, langSet,
  };
}


/***/ }),

/***/ 2638:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ convertPageHocr)
/* harmony export */ });
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7193);
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2961);
/* harmony import */ var _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5663);
/* harmony import */ var _convertPageShared_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5847);
/* harmony import */ var _utils_detectTables_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6776);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_4__]);
_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];








// If enabled, raw strings are saved in OCR objects for debugging purposes.
const debugMode = true;

/**
 * @param {Object} params
 * @param {string} params.ocrStr
 * @param {number} params.n
 * @param {?dims} [params.pageDims]
 * @param {boolean} params.scribeMode
 */
async function convertPageHocr({
  ocrStr, n, pageDims = null, scribeMode = false,
}) {
  let currentLang = 'eng';

  const angleRisePage = [];
  const lineLeft = [];
  const lineTop = [];

  // If page dimensions are not provided as an argument, we assume that the entire image is being recognized
  // (so the width/height of the image bounding box is the same as the width/height of the image).
  if (!pageDims) {
    const pageElement = ocrStr.match(/<div class=["']ocr_page["'][^>]+/i);
    if (pageElement != null) {
      const pageDimsMatch = pageElement[0].match(/bbox \d+ \d+ (\d+) (\d+)/i);
      if (pageDimsMatch != null) {
        pageDims = { height: parseInt(pageDimsMatch[2]), width: parseInt(pageDimsMatch[1]) };
      }
    }
  }

  if (!pageDims) throw new Error('Failed to parse page dimensions.');

  const pageObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrPage */ .Ay.OcrPage(n, pageDims);

  // Test whether character-level data (class="ocrx_cinfo" in Tesseract) is present.
  const charMode = !!/ocrx_cinfo/.test(ocrStr);

  // The JavaScript regex engine does not support matching start/end tags (some other engines do), so the end of words and lines are detected
  // through a hard-coded number of </span> end tags.  The only difference charMode should make on the expressions below is the number of
  // consecutive </span> tags required.
  let lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*){2}/ig;
  if (charMode) {
    lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){2}/ig;
  }

  const wordRegexCharLevel = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){1}/ig;
  const wordRegex = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)/ig;

  const charRegex = /<span class=["']ocrx_cinfo["'] title='([^'"]+)["']>([^<]*)<\/span>/ig;

  // Remove all bold/italics tags.  These complicate the syntax and are unfortunately virtually always wrong anyway (coming from Tesseract).
  // This does not impact re-uploads of .hocr files created with Scribe.
  ocrStr = ocrStr.replaceAll(/<\/?strong>/ig, '');
  ocrStr = ocrStr.replaceAll(/<\/?em>/ig, '');

  // Delete namespace to simplify xpath
  ocrStr = ocrStr.replace(/<html[^>]*>/i, '<html>');

  // Replace various classes with "ocr_line" class for simplicity
  // At least in Tesseract, these elements are not identified accurately or consistently enough to warrent different treatment.
  ocrStr = ocrStr.replace(/(class=')ocr_caption/ig, '$1ocr_line');
  ocrStr = ocrStr.replace(/(class=')ocr_textfloat/ig, '$1ocr_line');
  ocrStr = ocrStr.replace(/(class=')ocr_header/ig, '$1ocr_line');

  // Delete additional elements created by the `lstm_choice_mode` option in Tesseract
  const lstmChoiceMode1 = !!/id='timestep1/.test(ocrStr);
  const lstmChoiceMode2 = !!/id='lstm_choices/.test(ocrStr);

  if (lstmChoiceMode1) {
    ocrStr = ocrStr.replace(/<span class='ocr_symbol'[\s\S]+?(?:<\/span>\s*){3}/ig, '');
  }

  if (lstmChoiceMode2) {
    ocrStr = ocrStr.replace(/<span class='ocrx_cinfo' id='lstm_choices[\s\S]+?(?:<\/span>\s*){2}/ig, '');
  }

  /**
   * @param {string} match
   */
  function convertLine(match) {
    const titleStrLine = match.match(/title=['"]([^'"]+)/)?.[1];
    if (!titleStrLine) return '';

    const linebox1 = [...titleStrLine.matchAll(/bbox(?:es)?(\s+[\d.-]+)(\s+[\d.-]+)?(\s+[\d.-]+)?(\s+[\d.-]+)?/g)][0].slice(1, 5).map((x) => parseInt(x));

    const linebox = {
      left: linebox1[0], top: linebox1[1], right: linebox1[2], bottom: linebox1[3],
    };

    // The baseline can be missing in the case of vertical text (textangle present instead)
    const baselineMatch = [...titleStrLine.matchAll(/baseline(\s+[\d.-]+)(\s+[\d.-]+)/g)][0];

    if (!baselineMatch) return '';

    const baseline = baselineMatch.slice(1, 5).map((x) => parseFloat(x));

    // Only calculate baselines from lines 200px+.
    // This avoids short "lines" (e.g. page numbers) that often report wild values.
    if ((linebox.right - linebox.left) >= 200) {
      angleRisePage.push(baseline[0]);
      lineLeft.push(linebox.left);
      lineTop.push(linebox.top);
    }

    /** @type {?number} */
    let lineAscHeightFinal = null;
    /** @type {?number} */
    let lineXHeightFinal = null;

    if (scribeMode) {
      const lineAscHeightFinalStr = titleStrLine.match(/x_asc_height\s+([\d.-]+)/)?.[1];
      const lineXHeightFinalStr = titleStrLine.match(/x_x_height\s+([\d.-]+)/)?.[1];
      if (lineAscHeightFinalStr) lineAscHeightFinal = parseFloat(lineAscHeightFinalStr);
      if (lineXHeightFinalStr) lineXHeightFinal = parseFloat(lineXHeightFinalStr);
    }

    // This is not an `else` because old versions of Scribe used the same metrics as Tesseract,
    // so it is possible that `scribeMode` is `true` but this block still needs to be run.
    // This can likely be removed at some point in the future, as this change occured very early in Scribe's development.
    if (!lineAscHeightFinal && !lineXHeightFinal) {
      // Line font size metrics as reported by Tesseract.
      // As these are frequently not correct (as Tesseract calculates them before character recognition),
      // so they may be replaced later by versions we calculate.
      const lineAllHeightTessStr = parseFloat(titleStrLine.match(/x_size\s+([\d.-]+)/)?.[1] || '15');
      const lineAscHeightTessStr = parseFloat(titleStrLine.match(/x_ascenders\s+([\d.-]+)/)?.[1] || '0');
      const lineDescHeightTessStr = parseFloat(titleStrLine.match(/x_descenders\s+([\d.-]+)/)?.[1] || '0');

      lineAscHeightFinal = lineAllHeightTessStr - lineDescHeightTessStr;

      // When Scribe exports lines with `null` `xHeight` values to HOCR, `x_ascenders` is omitted.
      if (lineAscHeightTessStr > 0) {
        lineXHeightFinal = lineAllHeightTessStr - lineDescHeightTessStr - lineAscHeightTessStr;
      }
    }

    console.assert(lineAscHeightFinal || lineXHeightFinal, 'Line height metrics missing.');
    const lineObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrLine */ .Ay.OcrLine(pageObj, linebox, baseline, lineAscHeightFinal, lineXHeightFinal);

    if (debugMode) lineObj.raw = match;

    /**
     * @param {string} match
     */
    function convertWordCharLevel(match) {
      let text = '';

      const titleStrWord = match.match(/title=['"]([^'"]+)/)?.[1];
      const confMatchStr = titleStrWord?.match(/(?:;|\s)x_wconf\s+(\d+)/)?.[1];
      let wordConf = 0;
      if (confMatchStr) {
        wordConf = parseInt(confMatchStr);
      }

      const italic = /<\/em>\s*<\/span>/.test(match);

      const wordID = match.match(/id=['"]([^'"]*)['"]/i)?.[1] || `word_${n + 1}_${pageObj.lines.length + 1}_${lineObj.words.length + 1}`;

      const wordLangRaw = match.match(/lang=['"]([^'"]*)['"]/i)?.[1];

      let fontName = match.match(/^[^>]+?x_font\s*([^'";]+)/)?.[1];
      if (fontName) fontName = fontName.trim();

      const it = match.matchAll(charRegex);
      const letterArr = [...it];

      const bboxes = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/).slice(1, 5).map((y) => parseInt(y)));

      let wordLang = wordLangRaw || currentLang;
      if (['chi_sim', 'chi_tra'].includes(wordLang)) {
        const charArr = letterArr.map((x) => x[2]);
        const { han: hanChars, latin: latinChars } = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .getTextScript */ .TY)(charArr);

        if (hanChars === 0) {
          // Do not let languages be switched for a word that contains 0 Han characters.
          if (!['chi_sim', 'chi_tra'].includes(currentLang)) {
            wordLang = currentLang;
          // Do not let language be Chinese for any word that contains no Han characters and >0 non-Chinese characters.
          // TODO: Assign the appropriate Latin language (not necessarily English).
          } else if (latinChars > 0) {
            wordLang = 'eng';
          }
        }
      }

      /** @type {Array<OcrChar>} */
      const charObjArr = [];

      for (let j = 0; j < letterArr.length; j++) {
        let contentStrLetter = letterArr[j][2];

        // Handle characters escaped in XML
        contentStrLetter = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .unescapeXml */ .Uk)(contentStrLetter);

        const bbox = {
          left: bboxes[j][0], top: bboxes[j][1], right: bboxes[j][2], bottom: bboxes[j][3],
        };

        // For Chinese, every "character" in the .hocr should be its own word.
        // Tesseract LSTM already does this, however Tesseract Legacy combines entire lines into the same "word",
        // which makes good alignment impossible.
        if (wordLang === 'chi_sim') {
          const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, contentStrLetter, bbox, `${wordID}_${j}`);
          wordObj.conf = wordConf;
          wordObj.lang = wordLang;

          lineObj.words.push(wordObj);
        } else {
          const charObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrChar */ .Ay.OcrChar(contentStrLetter, bbox);
          charObjArr.push(charObj);

          text += contentStrLetter;
        }
      }

      if (wordLang === 'chi_sim') return '';

      text = text ?? '';
      text = text.trim();

      if (text === '') return ('');

      const bboxesCore = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/)?.slice(1, 5).map((y) => parseInt(y)));

      const wordBoxCore = {
        left: Math.min(...bboxesCore.map((x) => x[0])),
        top: Math.min(...bboxesCore.map((x) => x[1])),
        right: Math.max(...bboxesCore.map((x) => x[2])),
        bottom: Math.max(...bboxesCore.map((x) => x[3])),
      };

      const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, text, wordBoxCore, wordID);
      wordObj.lang = wordLang;

      wordObj.chars = charObjArr;

      if (debugMode) wordObj.raw = match;

      if (italic) wordObj.style = 'italic';
      if (fontName) wordObj.font = fontName;

      wordObj.conf = wordConf;

      lineObj.words.push(wordObj);

      return '';
    }

    /**
     * @param {string} match
     */
    function convertWord(match) {
      const wordID = match.match(/id=['"]([^'"]*)['"]/i)?.[1] || `word_${n + 1}_${pageObj.lines.length + 1}_${lineObj.words.length + 1}`;

      const wordSup = /<sup>/i.test(match);
      const wordDropCap = /<span class=['"]ocr_dropcap['"]>/i.test(match);

      let wordText;
      if (wordSup) {
        wordText = match.replace(/\s*<sup>/i, '').replace(/<\/sup>\s*/i, '').match(/>([^>]*)</)?.[1];
      } else if (wordDropCap) {
        wordText = match.replace(/\s*<span class=['"]ocr_dropcap['"]>/i, '').match(/>([^>]*)</)?.[1];
      } else {
        wordText = match.match(/>([^>]*)</)?.[1];
      }

      if (!wordText) return '';

      wordText = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .unescapeXml */ .Uk)(wordText);

      const titleStrWord = match.match(/title=['"]([^'"]+)/)?.[1];

      const wordLang = match.match(/lang=['"]([^'"]*)['"]/i)?.[1] || currentLang;

      if (!titleStrWord) {
        console.log(`Unable to process word, skipping: ${match}`);
        return '';
      }

      const wordBox1 = [...titleStrWord.matchAll(/bbox(?:es)?(\s+[\d-.]+)(\s+[\d-.]+)?(\s+[\d-.]+)?(\s+[\d-.]+)?/g)][0].slice(1, 5).map((x) => parseFloat(x));

      const wordBox = {
        left: wordBox1[0],
        top: wordBox1[1],
        right: wordBox1[2],
        bottom: wordBox1[3],
      };

      let fontName = match.match(/^[^>]+?x_font\s*([^'";]+)/)?.[1];
      if (fontName) fontName = fontName.trim();

      const styleStr = match.match(/style=['"]([^'"]+)/)?.[1];

      let smallCaps = false;
      /** @type {('normal'|'italic'|'bold')} */
      let fontStyle = 'normal';
      if (styleStr && /italic/i.test(styleStr)) {
        fontStyle = 'italic';
      } else if (styleStr && /bold/i.test(styleStr)) {
        fontStyle = 'bold';
      }

      if (styleStr && /small-caps/i.test(styleStr)) {
        smallCaps = true;
      }

      const confMatch = titleStrWord.match(/(?:;|\s)x_wconf\s+(\d+)/)?.[1] || '0';
      const wordConf = parseInt(confMatch) || 0;

      const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, wordText, wordBox, wordID);
      wordObj.lang = wordLang;

      // Font size is only respected if this is a re-import, as if an ocrWord object has `size` set, it will be used over line metrics.
      // Therefore, this should only be set if manually set by the user.
      if (scribeMode) {
        const wordFontSizeStr = titleStrWord.match(/(?:;|\s)x_fsize\s+(\d+)/)?.[1];
        if (wordFontSizeStr) {
          const wordFontSize = parseInt(wordFontSizeStr);
          if (wordFontSize) wordObj.size = wordFontSize;
        }
      }

      wordObj.style = fontStyle;
      if (fontName) wordObj.font = fontName;

      wordObj.sup = wordSup;

      wordObj.smallCaps = smallCaps;

      wordObj.conf = wordConf;

      lineObj.words.push(wordObj);

      return '';
    }

    if (charMode) {
      match = match.replaceAll(wordRegexCharLevel, convertWordCharLevel);
    } else {
      match = match.replaceAll(wordRegex, convertWord);
    }

    pageObj.lines.push(lineObj);

    return '';
  }

  /**
   * @param {string} match
   */
  const convertPar = (match) => {
    const parLang = match.match(/^.+?lang=['"]([^'"]*)['"]/i)?.[1];
    if (parLang) currentLang = parLang;
    match.replaceAll(lineRegex, convertLine);
    return '';
  };

  ocrStr = ocrStr.replaceAll(/<p class=["']ocr_par[\s\S]+?(?:<\/p>\s*)/ig, convertPar);

  ocrStr = ocrStr.replaceAll(lineRegex, convertLine);

  const warn = { char: charMode ? '' : 'char_warning' };

  (0,_convertPageShared_js__WEBPACK_IMPORTED_MODULE_3__/* .pass2 */ .c)(pageObj, 0);
  const langSet = (0,_convertPageShared_js__WEBPACK_IMPORTED_MODULE_3__/* .pass3 */ .j)(pageObj);

  const autoDetectTables = false;
  const dataTablePage = new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataTablePage */ .Cd(n);
  if (autoDetectTables) {
    const tableBboxes = (0,_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_4__/* .detectTablesInPage */ .p9)(pageObj);
    tableBboxes.forEach((bbox) => {
      const dataTable = (0,_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_4__/* .makeTableFromBbox */ .Gx)(pageObj, bbox);
      dataTable.page = dataTablePage;
      dataTablePage.tables.push(dataTable);
    });
  }

  return {
    pageObj, dataTables: dataTablePage, warn, langSet,
  };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 5847:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ pass2),
/* harmony export */   j: () => (/* binding */ pass3)
/* harmony export */ });
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7193);
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2961);



/**
 * Pass 2 iterates over all words/letters in the OCR object, and corrects style and rotation.
 * This pass should only be run for Tesseract data.
 *
 * @param {OcrPage} pageObj - Page object to apply corrections to. Edited in place.
 */
function pass2(pageObj, rotateAngle) {
  // Re-calculate line bounding box and adjust baseline.
  // Note: this must happen before the roatation step, as that step assumes the bounding boxes are correct.
  // Data from Tesseract can omit certain characters when calculating line-level bounding boxes.
  // Therefore, the bounding box is recalculated using `ocr.updateLineBbox` (which is used by the editor).
  for (const lineObj of pageObj.lines) {
    _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.updateLineBbox(lineObj);
  }

  // Transform bounding boxes if rotation is specified.
  // This option is used when an image is rotated before it is sent to Tesseract,
  // however the HOCR needs to be applied to the original image.
  if (Math.abs(rotateAngle) > 0.05) {
    for (let i = 0; i < pageObj.lines.length; i++) {
      _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.rotateLine(pageObj.lines[i], rotateAngle, null, true);
    }
  }

  // Flag words that are small caps, incorrectly identified as capital letters in a normal style.
  // Unlike Abbyy, which generally identifies small caps as lowercase letters (and identifies small cap text explicitly as a formatting property),
  // Tesseract (at least the Legacy model) reports them as upper-case letters.
  for (let i = 0; i < pageObj.lines.length; i++) {
    const lineObj = pageObj.lines[i];
    let firstWord = false;
    const smallCapsWordArr = [];
    const titleCaseArr = [];
    for (let j = 0; j < lineObj.words.length; j++) {
      const wordObj = lineObj.words[j];
      // Skip words that are already identified as small caps, however they can be used to validate other words.
      if (wordObj.smallCaps) {
        smallCapsWordArr.push(wordObj);
        firstWord = true;
        continue;
      }

      // Detect words that were not identified as small caps but the engine, but likely are.
      // Word contains multiple capital letters, no lowercase letters, and has character-level data.
      if (!/[a-z]/.test(wordObj.text) && /[A-Z].?[A-Z]/.test(wordObj.text) && wordObj.chars) {
        // Filter to only include letters
        const letterChars = wordObj.chars.filter((x) => /[a-z]/i.test(x.text));

        // The letter "Q" is a special case as the capital letter is larger than other capital letters.
        const firstLetterHeight = letterChars[0].bbox.bottom - letterChars[0].bbox.top;
        const otherLetters = letterChars.slice(1).filter((x) => !/[q]/i.test(x.text));
        if (otherLetters.length === 0) continue;

        const otherLetterHeightArr = otherLetters.map((x) => x.bbox.bottom - x.bbox.top);
        const otherLetterHeightMax = Math.max(...otherLetterHeightArr);
        const otherLetterHeightMin = Math.min(...otherLetterHeightArr);

        const firstLetterThresh = ['q', 'Q'].includes(letterChars[0].text) ? 1.3 : 1.1;

        // If the first letter is significantly larger than the others, then this word would need to be in title case.
        if (firstLetterHeight > otherLetterHeightMax * firstLetterThresh) {
          // If the other letters are all around the same size, then the word is small caps.
          if ((otherLetterHeightMax / otherLetterHeightMin) < 1.15) {
            smallCapsWordArr.push(wordObj);
            if (j === 0) firstWord = true;
            titleCaseArr[smallCapsWordArr.length - 1] = true;
          }
        } else {
          // Otherwise, all the letters need to be about the same size for this to be small caps.
          const letterCharsAsc = wordObj.chars.filter((x) => /[a-pr-z]/i.test(x.text));
          if (letterCharsAsc.length < 2) continue;
          const allLetterHeightArr = letterCharsAsc.map((x) => x.bbox.bottom - x.bbox.top);
          const allLetterHeightMax = Math.max(...allLetterHeightArr);
          const allLetterHeightMin = Math.min(...allLetterHeightArr);

          if ((allLetterHeightMax / allLetterHeightMin) < 1.15) {
            smallCapsWordArr.push(wordObj);
            if (j === 0) firstWord = true;
            titleCaseArr[smallCapsWordArr.length - 1] = false;
          }
        }
      }
    }

    // To avoid false positives, single words in the middle of a line cannot be small caps.
    if (firstWord || smallCapsWordArr.length >= 2) {
      const titleCaseTotal = titleCaseArr.reduce((x, y) => Number(x) + Number(y), 0);

      for (let k = 0; k < smallCapsWordArr.length; k++) {
        const wordObj = smallCapsWordArr[k];
        wordObj.smallCaps = true;
        if (!wordObj.chars || !titleCaseTotal) continue;

        // If title case, convert all letters after the first to lowercase.
        if (titleCaseArr[k]) {
          wordObj.chars.slice(1).forEach((x) => {
            x.text = x.text.toLowerCase();
          });
          wordObj.text = wordObj.chars.map((x) => x.text).join('');
        } else {
          // If not title case (but title case is used on this line), assume the entire word is lower case.
          // This should be refined at some point to check the actual bounding boxes,
          // however this heuristic is generally reliable.
          wordObj.chars.forEach((x) => {
            x.text = x.text.toLowerCase();
          });
          wordObj.text = wordObj.chars.map((x) => x.text).join('');
        }
      }
    }
  }

  // Split superscripts into separate words, and enable 'super' as word style for superscripts.
  // Tesseract may not split superscript footnote references into separate words, so that happens here.
  for (const lineObj of pageObj.lines) {
    for (let i = 0; i < lineObj.words.length; i++) {
      const wordObj = lineObj.words[i];
      // Skip for non-Latin languages, and when no character-level data exists.
      if (['chi_sim', 'chi_tra'].includes(wordObj.lang) || !wordObj.chars || wordObj.chars.length === 0) continue;

      // Check if any superscript is possible (word ends in number).
      const trailingNumStr = wordObj.text.match(/\d+$/)?.[0];
      if (!trailingNumStr) continue;

      // Adjust box such that top/bottom approximate those coordinates at the leftmost point
      const lineboxAdj = { ...lineObj.bbox };

      if (lineObj.baseline[0] < 0) {
        lineboxAdj.top -= (lineboxAdj.right - lineboxAdj.left) * lineObj.baseline[0];
      } else {
        lineboxAdj.bottom -= (lineboxAdj.right - lineboxAdj.left) * lineObj.baseline[0];
      }

      // Baseline point at leftmost point of the line
      const baselinePointAdj = lineObj.baseline[0] < 0 ? lineObj.baseline[1] : lineObj.baseline[1] + (lineObj.bbox.bottom - lineboxAdj.bottom);

      const expectedBaseline = (wordObj.bbox.left + (wordObj.bbox.right - wordObj.bbox.left) / 2 - lineboxAdj.left) * lineObj.baseline[0] + baselinePointAdj + lineboxAdj.bottom;
      const lineAscHeight = expectedBaseline - lineboxAdj.top;

      let baseN = 0;
      for (let j = wordObj.chars.length - 1; j >= 0; j--) {
        const charObj = wordObj.chars[j];
        if (charObj.bbox.bottom < expectedBaseline - lineAscHeight / 4) {
          baseN++;
        } else {
          break;
        }
      }

      const superN = Math.min(trailingNumStr.length, baseN);

      // If no superscript is possible, skip.
      if (superN === 0) continue;

      // If the entire word is a superscript, it does not need to be split.
      if (superN === wordObj.text.length) {
        wordObj.sup = true;
        wordObj.style = 'normal';
        continue;
      }

      // Otherwise, split the word into two words, with the second word being the superscript.
      const wordObjSup = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneWord(wordObj);

      const charCoreArr = wordObj.chars.slice(0, wordObj.chars.length - superN);
      // Use cloned characters to avoid issues with character objects being shared in multiple words.
      // We know `wordObjSup.chars` exists as we already checked that `wordObj.chars` exists.
      const wordObjSupChars = /** @type {OcrChar[]} */ (wordObjSup.chars);

      const charSuperArr = wordObjSupChars.slice(wordObj.chars.length - superN, wordObj.chars.length);
      const textCore = charCoreArr.map((x) => x.text).join('');
      const textSuper = charSuperArr.map((x) => x.text).join('');

      // const wordObjSup = ocr.cloneWord(wordObj);

      wordObjSup.text = textSuper;
      wordObjSup.chars = charSuperArr;
      wordObjSup.style = 'normal';
      wordObjSup.sup = true;
      wordObjSup.id = `${wordObj.id}a`;
      _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.calcWordBbox(wordObjSup);

      wordObj.text = textCore;
      wordObj.chars = charCoreArr;
      _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.calcWordBbox(wordObj);

      lineObj.words.splice(i + 1, 0, wordObjSup);
      i++;
    }
  }
}

/**
 * Pass 3 iterates over all words/letters in the OCR object, calculating statistics and applying corrections.
 * All OCR objects (Tesseract/Abbyy/Stext) should be run through this function before returning.
 * Returns a set containing all languages detected in the OCR object.
 *
 * @param {OcrPage} pageObj - Page object to apply corrections to. Edited in place.
 */
function pass3(pageObj) {
  /** @type {Set<string>} */
  const langSet = new Set();

  // Calculate page angle, if not already set to non-zero value.
  // If a page angle is already defined, that indicates that angle was already detected and rotation was applied in pre-processing,
  // so that should not be overwritten here (as the number would not be accurate).
  if (!pageObj.angle) {
    const angleRisePage = [];
    for (const lineObj of pageObj.lines) {
      // Only calculate baselines from lines 200px+.
      // This avoids short "lines" (e.g. page numbers) that often report wild values.
      if ((lineObj.bbox.right - lineObj.bbox.left) >= 200) {
        angleRisePage.push(lineObj.baseline[0]);
      }
    }

    const angleRiseMedian = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .mean50 */ .lW)(angleRisePage) || 0;
    pageObj.angle = Math.asin(angleRiseMedian) * (180 / Math.PI);
  }

  // Loop over all glyphs, calculating statistics and applying corrections.
  for (const lineObj of pageObj.lines) {
    /** @type {Array<number>} */
    const lineAscHeightArr = [];
    /** @type {Array<number>} */
    const lineXHeightArr = [];
    /** @type {Array<number>} */
    const lineAllHeightArr = [];

    for (const wordObj of lineObj.words) {
      const letterArr = wordObj.text.split('');
      const charObjArr = wordObj.chars;

      langSet.add(wordObj.lang);

      // This condition should not occur, however has in the past due to parsing bugs.  Skipping to avoid entire program crashing if this occurs.
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;

      // Quotes at the start of a word are assumed to be opening quotes
      if (['"', "'"].includes(letterArr[0]) && letterArr.length > 1 && /[a-z\d]/i.test(letterArr[1])) {
        if (letterArr[0] === '"') {
          letterArr[0] = '“';
          if (charObjArr) charObjArr[0].text = '“';
        } else if (letterArr[0] === "'") {
          letterArr[0] = '‘';
          if (charObjArr) charObjArr[0].text = '‘';
        }
      }

      // Quotes at the end of a word are assumed to be closing quotes
      if (['"', "'"].includes(letterArr[letterArr.length - 1]) && /[a-z\d][.,!?;]?['"]$/i.test(wordObj.text)) {
        if (letterArr[letterArr.length - 1] === '"') {
          letterArr[letterArr.length - 1] = '”';
          if (charObjArr) charObjArr[letterArr.length - 1].text = '”';
        } else if (letterArr[letterArr.length - 1] === "'") {
          letterArr[letterArr.length - 1] = '’';
          if (charObjArr) charObjArr[letterArr.length - 1].text = '’';
        }
      }

      // Single quotes between two letters are assumed to be apostrophes
      for (let k = 0; k < letterArr.length; k++) {
        if (["'"].includes(letterArr[k]) && k > 0 && k + 1 < letterArr.length && /[a-z\d]/i.test(letterArr[k + 1]) && /[a-z\d]/i.test(letterArr[k - 1])) {
          letterArr[k] = '’';
          if (charObjArr) charObjArr[k].text = '’';
        }
      }

      // Calculate statistics from character metrics, if present
      if (wordObj.chars) {
        for (let k = 0; k < letterArr.length; k++) {
          const charObj = wordObj.chars[k];

          // Do not include superscripts, dropcaps, and low-confidence words in all statistics.
          // Low-confidence words are included for font size calculations, as some lines only contain low-confidence words.
          if (wordObj.sup || wordObj.dropcap) continue;

          const contentStrLetter = letterArr[k];
          const charHeight = charObj.bbox.bottom - charObj.bbox.top;

          const ascChar = wordObj.smallCaps && /[A-Z0-9]/.test(contentStrLetter) || !wordObj.smallCaps && _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .ascCharArr */ .xq.includes(contentStrLetter);
          const xChar = wordObj.smallCaps && /[a-z]/.test(contentStrLetter) || !wordObj.smallCaps && _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .xCharArr */ .oQ.includes(contentStrLetter);

          // Save character heights to array for font size calculations
          lineAllHeightArr.push(charHeight);
          if (ascChar) {
            lineAscHeightArr.push(charHeight);
          } else if (xChar) {
            lineXHeightArr.push(charHeight);
          }
        }
      }

      wordObj.text = letterArr.join('');
    }

    const lineAllHeight = Math.max(...lineAllHeightArr);
    const lineAscHeight = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .quantile */ .YV)(lineAscHeightArr, 0.5);
    const lineXHeight = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .quantile */ .YV)(lineXHeightArr, 0.5);

    // TODO: For Tesseract these are often already filled in by the engine.
    // While the calculated values are more reliable, we may want to defer to the Tesseract values at some point as a fallback.
    if (lineAscHeight) lineObj.ascHeight = lineAscHeight;
    if (lineXHeight) lineObj.xHeight = lineXHeight;

    // If ascHeight and xHeight are both known, however one is clearly wrong, delete whichever has fewer observations.
    // This commonly comes up when a line has >90% numbers, however a few (potentially misidentified) lowercase letters are present.
    // Additionally, this deletes the values that Tesseract makes up when it does not have enough data to calculate them.
    // For example, Tesseract will still report xHeight for a line that only contains capital letters.
    if (lineObj.ascHeight && lineObj.xHeight && lineObj.xHeight >= lineObj.ascHeight * 0.9) {
      if (lineAscHeightArr.length > lineXHeightArr.length) {
        lineObj.xHeight = null;
      } else {
        lineObj.ascHeight = null;
      }
    }

    // If neither ascHeight nor xHeight are known, total height is assumed to represent ascHeight, on the grounds that it is better than nothing.
    if (!lineAscHeight && !lineXHeight && lineAllHeight && Number.isFinite(lineAllHeight)) lineObj.ascHeight = lineAllHeight;

    // Replace all dash characters with a hyphen, en-dash or em-dash, depending on their width.
    // OCR engines commonly use the wrong type of dash. This is especially problematic during font optimization,
    // as it can result (for example) in a hyphen being scaled to be closer to an en-dash if the latter is more common.
    for (const wordObj of lineObj.words) {
      // Sometimes a single `ocrChar` letter object will contain multiple actual letters. Skipping to avoid entire program crashing if this occurs.
      // This generally occurs due to Tesseract returning a "character" that is actually multiple characters, so there is nothing we can do here.
      // This can also occur when there is a bug in the parser--notably when a certain unicode/HTML character code is not being unescaped propertly.
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;

      const letterArr = wordObj.text.split('');
      const charObjArr = wordObj.chars;

      // This step requires character-level metrics.
      if (!charObjArr || !wordObj.line.xHeight) continue;

      // In some documents Abbyy consistently uses "¬" rather than "-" for hyphenated words at the the end of lines, so this symbol is included.
      for (let k = 0; k < letterArr.length; k++) {
        // This adjustment requires line-level metrics to be correct, so skip in cases where the dash is (basically) the only thing on the line.
        const enoughInfo = letterArr.length > 2 || wordObj.line.words.length > 2;
        if (['-', '–', '—', '¬'].includes(letterArr[k]) && enoughInfo) {
          let charWidth = charObjArr[k].bbox.right - charObjArr[k].bbox.left;

          // If the gap between the previous character and next character is shorter than the supposed width of the dash character, use that width instead.
          // This should never occur in valid data, however can happen for Tesseract LSTM, which frequently gets character-level bounding boxes wrong.
          // When there is no next character, the right edge of the word is used instead. Word bounds are more reliable than intra-word character bounds for LSTM,
          // so the right bound of the dash should only be used in the case when it is the last character.
          if (charObjArr[k - 1]) {
            const rightBound = charObjArr[k + 1] ? charObjArr[k + 1].bbox.left : charObjArr[k].bbox.right;
            const charWidth2 = rightBound - charObjArr[k - 1].bbox.right;
            charWidth = Math.min(charWidth, charWidth2);
          }

          const charWidthNorm = charWidth / wordObj.line.xHeight;
          if (charWidthNorm > 1.5) {
            letterArr[k] = '—';
            if (charObjArr) charObjArr[k].text = '—';
          } else if (charWidthNorm > 0.9) {
            letterArr[k] = '–';
            if (charObjArr) charObjArr[k].text = '–';
          } else {
            letterArr[k] = '-';
            if (charObjArr) charObjArr[k].text = '-';
          }
        }
      }
      // Stylistic ligatures are replaced with their component letters.
      // This occurs because ligatures are added dynamically when the text is rendered, and the OCR data is assumed to not contain them.
      // Some fonts do not include stylistic ligatures, and whether they are used or not is a matter of font optimization,
      // as stylistic ligatures do not change the meaning of the text.
      wordObj.text = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.replaceLigatures(letterArr.join(''));
    }
  }

  return langSet;
}


/***/ }),

/***/ 1502:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ convertPageStext)
/* harmony export */ });
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7193);
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2961);
/* harmony import */ var _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5663);
/* harmony import */ var _utils_detectTables_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6776);
/* harmony import */ var _utils_ocrUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7347);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_3__, _utils_ocrUtils_js__WEBPACK_IMPORTED_MODULE_4__]);
([_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_3__, _utils_ocrUtils_js__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);








/**
 * @param {Object} params
 * @param {string} params.ocrStr
 * @param {number} params.n
 */
async function convertPageStext({ ocrStr, n }) {
  const pageDimsMatch = ocrStr.match(/<page .+?width=['"]([\d.-]+)['"] height=['"]([\d.-]+)['"]/);

  if (!pageDimsMatch || !pageDimsMatch[1] || !pageDimsMatch[2]) throw new Error('Page dimensions not found in stext.');

  const pageDims = { height: parseInt(pageDimsMatch[2]), width: parseInt(pageDimsMatch[1]) };

  const pageObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrPage */ .Ay.OcrPage(n, pageDims);

  /** @type {Array<number>} */
  const angleRisePage = [];

  /** @type {Set<string>} */
  const langSet = new Set();

  function convertParStext(xmlPar) {
    /** @type {Array<OcrLine>} */
    const parLineArr = [];

    /**
     * @param {string} xmlLine
     */
    // eslint-disable-next-line no-shadow
    function convertLineStext(xmlLine) {
    // Remove the <block> tag to avoid the regex matching it instead of the <line> tag.
    // We currently have no "block" level object, however this may be useful in the future.
      xmlLine = xmlLine.replace(/<block[^>]*?>/i, '');

      const xmlLinePreChar = xmlLine.match(/^[\s\S]*?(?=<char)/)?.[0];
      if (!xmlLinePreChar) return;

      const dir = xmlLinePreChar.match(/dir=['"](\s*[\d.-]+)(\s*[\d.-]+)/)?.slice(1, 3).map((x) => parseFloat(x));

      let orientation = 0;
      if (dir && Math.abs(dir[0]) < 0.5 && dir[1] >= 0.5) {
        orientation = 1;
      } else if (dir && dir[0] <= -0.5 && Math.abs(dir[1]) < 0.5) {
        orientation = 2;
      } else if (dir && Math.abs(dir[0]) < 0.5 && dir[1] <= -0.5) {
        orientation = 3;
      }

      const xmlLineFormatting = xmlLinePreChar?.match(/<font[^>]+/)?.[0];
      const fontName = xmlLineFormatting?.match(/name=['"]([^'"]*)/)?.[1];
      const fontSizeStr = xmlLineFormatting?.match(/size=['"]([^'"]*)/)?.[1];

      console.assert(fontSizeStr, 'Font size not found in stext.');

      const fontSizeLine = fontSizeStr ? parseFloat(fontSizeStr) : 10;

      const fontFamilyLine = fontName?.replace(/-.+/g, '') || 'Default';

      const lineBoxArr = [...xmlLinePreChar.matchAll(/bbox(?:es)?=['"](\s*[\d.-]+)(\s*[\d.-]+)?(\s*[\d.-]+)?(\s*[\d.-]+)?/g)][0].slice(1, 5).map((x) => Math.max(parseFloat(x), 0));

      // Unlike Tesseract, stext does not have a native "word" unit (it provides only lines and letters).
      // Therefore, lines are split into words on either (1) a space character or (2) a change in formatting.
      const wordStrArr = xmlLine.split(/(?:<char[^>]*?c=['"]\s+['"]\/>)/ig);
      // If the last element is a closing font tag, remove it.
      if (wordStrArr[wordStrArr.length - 1] && wordStrArr[wordStrArr.length - 1].trim() === '</font>') wordStrArr.pop();

      // Delete any empty elements.
      // This can happen when multiple spaces are present and is problematic later in the code.
      for (let i = wordStrArr.length - 1; i >= 0; i--) {
        if (wordStrArr[i].trim() === '') {
          wordStrArr.splice(i, 1);
        }
      }

      if (wordStrArr.length === 0) return;

      /** @type {Array<Array<{left: number, top: number, right: number, bottom: number}>>} */
      const bboxes = [];

      let baselineFirstDone = false;
      const baselineFirst = /** @type {Array<Number>} */ ([]);

      let baselineCurrent = 0;

      /** @type {Array<Array<string>>} */
      const text = [];
      /** @type {Array<number>} */
      const wordLetterOrFontArrIndex = [];
      let styleCurrent = 'normal';
      let familyCurrent = 'Default';
      /** Font size at the current position in the PDF, with no modifications. */
      let sizeCurrentRaw = 0;
      /** Font size at the current position in the PDF, with changes for typographical reasons (small caps, superscripts) ignored. */
      let sizeCurrent = 0;
      let superCurrent = false;
      let smallCapsCurrent;
      let smallCapsCurrentAlt;
      /** @type {Array<string>} */
      const styleArr = [];
      /** @type {Array<boolean>} */
      const smallCapsArr = [];
      /** @type {Array<boolean>} */
      const smallCapsAltArr = [];
      /** @type {Array<boolean>} */
      const smallCapsAltTitleCaseArr = [];
      /** @type {Array<string>} */
      const fontFamilyArr = [];
      /** @type {Array<number>} */
      const fontSizeArr = [];
      /** @type {Array<boolean>} */
      const superArr = [];

      /**
       * @typedef {Object} Point
       * @property {number} x - The x coordinate.
       * @property {number} y - The y coordinate.
       */

      /**
       * @typedef {Object} Quad
       * @property {Point} ul - Upper left corner.
       * @property {Point} ur - Upper right corner.
       * @property {Point} ll - Lower left corner.
       * @property {Point} lr - Lower right corner.
       */

      /**
       * @typedef {Object} StextChar
       * @property {Quad} quad
       * @property {Point} origin
       * @property {string} text
       */

      /**
       * @typedef {Object} StextFont
       * @property {string} name
       * @property {number} size
       */

      const wordCharOrFontArr = /** @type {Array<Array<StextChar|StextFont>>} */([]);
      for (let i = 0; i < wordStrArr.length; i++) {
        // Fonts can be changed at any point in the word string.
        // Sometimes the font is changed before a space character, and othertimes it is changed after the space character.
        // This regex splits the string into elements that contain either (1) a font change or (2) a character.
        // The "quad" attribute includes 8 numbers (x and y coordinates for all 4 corners) however we only use capturing groups for 4
        const stextCharRegex = /(<font[^>]+>\s*)|<char quad=['"](\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)[^>]*?x=['"]([\d.-]+)[^>]*?y=['"]([\d.-]+)['"][^>]*?c=['"]([^'"]+)['"]\s*\/>/ig;

        const stextMatches = [...wordStrArr[i].matchAll(stextCharRegex)];

        wordCharOrFontArr[i] = [];
        for (let j = 0; j < stextMatches.length; j++) {
          const fontStr = stextMatches[j][1];
          const fontNameStrI = fontStr?.match(/name=['"]([^'"]*)/)?.[1];
          const fontSizeStrI = fontStr?.match(/size=['"]([^'"]*)/)?.[1];
          if (fontNameStrI && fontSizeStrI) {
            // Skip font changes that occur at the end of a line.
            // In addition to being unnecessary, these are problematic when parsing superscripts.
            if (i + 1 === wordStrArr.length && j + 1 === stextMatches.length) continue;
            wordCharOrFontArr[i][j] = {
              name: fontNameStrI,
              size: parseFloat(fontSizeStrI),
            };
            continue;
          }

          let quad;
          if (orientation === 1) {
            quad = {
              ul: { x: parseFloat(stextMatches[j][6]), y: parseFloat(stextMatches[j][7]) },
              ur: { x: parseFloat(stextMatches[j][2]), y: parseFloat(stextMatches[j][3]) },
              ll: { x: parseFloat(stextMatches[j][8]), y: parseFloat(stextMatches[j][9]) },
              lr: { x: parseFloat(stextMatches[j][4]), y: parseFloat(stextMatches[j][5]) },
            };
          } else if (orientation === 2) {
            quad = {
              ul: { x: parseFloat(stextMatches[j][8]), y: parseFloat(stextMatches[j][9]) },
              ur: { x: parseFloat(stextMatches[j][6]), y: parseFloat(stextMatches[j][7]) },
              ll: { x: parseFloat(stextMatches[j][4]), y: parseFloat(stextMatches[j][5]) },
              lr: { x: parseFloat(stextMatches[j][2]), y: parseFloat(stextMatches[j][3]) },
            };
          } else if (orientation === 3) {
            quad = {
              ul: { x: parseFloat(stextMatches[j][4]), y: parseFloat(stextMatches[j][5]) },
              ur: { x: parseFloat(stextMatches[j][8]), y: parseFloat(stextMatches[j][9]) },
              ll: { x: parseFloat(stextMatches[j][2]), y: parseFloat(stextMatches[j][3]) },
              lr: { x: parseFloat(stextMatches[j][6]), y: parseFloat(stextMatches[j][7]) },
            };
          } else {
            quad = {
              ul: { x: parseFloat(stextMatches[j][2]), y: parseFloat(stextMatches[j][3]) },
              ur: { x: parseFloat(stextMatches[j][4]), y: parseFloat(stextMatches[j][5]) },
              ll: { x: parseFloat(stextMatches[j][6]), y: parseFloat(stextMatches[j][7]) },
              lr: { x: parseFloat(stextMatches[j][8]), y: parseFloat(stextMatches[j][9]) },
            };
          }

          wordCharOrFontArr[i][j] = {
            quad,
            origin: { x: parseFloat(stextMatches[j][10]), y: parseFloat(stextMatches[j][11]) },
            text: stextMatches[j][12],
          };
        }
      }

      for (let i = 0; i < wordCharOrFontArr.length; i++) {
        let textWordArr = [];
        let bboxesWordArr = [];
        let fontFamily = familyCurrent || fontFamilyLine || 'Default';
        // Font size for the word is a separate variable, as if a font size changes at the end of the word,
        // that should not be reflected until the following word.
        let fontSizeWord = sizeCurrent || fontSizeLine || 10;
        let smallCapsWord = smallCapsCurrent || false;
        let smallCapsWordAlt = smallCapsCurrentAlt || false;
        // Title case adjustment does not carry forward between words. A word in title case may be followed by a word in all lower case.
        let smallCapsWordAltTitleCaseAdj = false;
        let styleWord = 'normal';

        if (wordCharOrFontArr[i].length === 0) continue;

        let wordInit = false;

        for (let j = 0; j < wordCharOrFontArr[i].length; j++) {
          const charOrFont = wordCharOrFontArr[i][j];
          if ('name' in charOrFont) {
            // While small caps can be printed using special "small caps" fonts, they can also be printed using a regular font with a size change.
            // This block of code detects small caps printed in title case by checking for a decrease in font size after the first letter.
            // TODO: This logic currently fails when:
            // (1) Runs of small caps include punctuation, which is printed at the full size (and therefore is counted as a size increase ending small caps).
            // (2) Runs of small caps that start with lower-case letters, which do not conform to the expectation that runs of small caps start with a capital letter.
            const sizePrevRaw = sizeCurrentRaw;
            sizeCurrentRaw = charOrFont.size;
            const secondLetter = wordInit && textWordArr.length === 1 && /[A-Z]/.test(textWordArr[0]);

            let baselineNextLetter;
            const possibleNextLetter1 = wordCharOrFontArr[i][j + 1];
            const possibleNextLetter2 = wordCharOrFontArr[i + 1]?.[0];
            const possibleNextLetter3 = wordCharOrFontArr[i + 1]?.[1];
            const possibleNextLetter4 = wordCharOrFontArr[i + 1]?.[2];

            if (possibleNextLetter1 && 'origin' in possibleNextLetter1) {
              baselineNextLetter = possibleNextLetter1.origin.y;
            } else if (possibleNextLetter2 && 'origin' in possibleNextLetter2) {
              baselineNextLetter = possibleNextLetter2.origin.y;
            } else if (possibleNextLetter3 && 'origin' in possibleNextLetter3) {
              baselineNextLetter = possibleNextLetter3.origin.y;
            } else if (possibleNextLetter4 && 'origin' in possibleNextLetter4) {
              baselineNextLetter = possibleNextLetter4.origin.y;
            }

            const fontSizeMin = Math.min(sizeCurrentRaw, sizePrevRaw);
            const baselineDelta = (baselineNextLetter - baselineCurrent) / fontSizeMin;
            const sizeDelta = (sizeCurrentRaw - sizePrevRaw) / fontSizeMin;
            if (secondLetter && sizeCurrentRaw < sizePrevRaw && sizePrevRaw > 0 && baselineNextLetter && Math.abs(baselineDelta) < 0.1) {
              smallCapsCurrentAlt = true;
              smallCapsWordAlt = true;
              smallCapsWordAltTitleCaseAdj = true;
            // Handle case where superscript is starting or ending.
            // We need to be able to detect superscripts using either a start or end font change,
            // as only using one would miss some cases.
            } else if (Number.isFinite(baselineDelta) && Number.isFinite(sizeDelta)
            && ((baselineDelta < -0.25 && sizeDelta < -0.05) || (baselineDelta > 0.25 && sizeDelta > 0.05))) {
              // Split word when superscript starts or ends.
              if (textWordArr.length > 0) {
                text.push(textWordArr);
                bboxes.push(bboxesWordArr);
                styleArr.push(styleWord);
                fontFamilyArr.push(fontFamily);

                if (sizeDelta > 0) {
                  fontSizeArr.push(sizePrevRaw);
                } else {
                  fontSizeArr.push(fontSizeWord);
                }

                smallCapsArr.push(smallCapsWord);
                smallCapsAltArr.push(smallCapsWordAlt);
                smallCapsAltTitleCaseArr.push(smallCapsWordAltTitleCaseAdj);
                superArr.push(sizeDelta > 0);

                textWordArr = [];
                bboxesWordArr = [];
              }

              if (sizeDelta > 0) {
                // If the first word was determined to be a superscript, reset `baselineFirst` to avoid skewing the slope calculation.
                if (!baselineFirstDone) baselineFirst.length = 0;
                familyCurrent = charOrFont.name || familyCurrent;
                sizeCurrent = sizeCurrentRaw || sizeCurrent;
                fontSizeWord = sizeCurrent;
                fontFamily = familyCurrent;
                superArr[superArr.length - 1] = true;
              }

              // If `baselineFirstDone` was set using a non-superscript word, mark it as done.
              if (superArr.length > 0 && !superArr[superArr.length - 1] && baselineFirst.length > 0) {
                baselineFirstDone = true;
              }

              superCurrent = sizeDelta < 0;
            } else {
              sizeCurrent = sizeCurrentRaw || sizeCurrent;
              familyCurrent = charOrFont.name || familyCurrent;
              // Update current word only if this is before every letter in the word.
              if (textWordArr.length === 0) {
                fontSizeWord = sizeCurrent;
                fontFamily = familyCurrent;
              }
              // An increase in font size ends any small caps sequence.
              // A threshold is necessary because stext data has been observed to have small variations without a clear reason.
              // eslint-disable-next-line no-lonely-if
              if (Number.isFinite(sizeDelta) && Math.abs(sizeDelta) > 0.05) {
                smallCapsCurrentAlt = false;
                if (textWordArr.length === 0) {
                  superCurrent = false;
                  smallCapsWordAlt = false;
                  smallCapsWordAltTitleCaseAdj = false;
                }
              }
            }

            // Label as `smallCapsAlt` rather than `smallCaps`, as we confirm the word is all caps before marking as `smallCaps`.
            smallCapsCurrentAlt = smallCapsCurrentAlt ?? smallCapsAltArr[smallCapsAltArr.length - 1];
            smallCapsCurrent = /(small\W?cap)|(sc$)|(caps$)/i.test(charOrFont.name);
            smallCapsWord = smallCapsCurrent;

            if (/italic/i.test(charOrFont.name) || /-\w*ital/i.test(charOrFont.name) || /-it$/i.test(charOrFont.name) || /oblique/i.test(charOrFont.name)) {
              // The word is already initialized, so we need to change the last element of the style array.
              // Label as `smallCapsAlt` rather than `smallCaps`, as we confirm the word is all caps before marking as `smallCaps`.
              styleCurrent = 'italic';
            } else if (/bold|black/i.test(charOrFont.name)) {
              styleCurrent = 'bold';
            } else {
              styleCurrent = 'normal';
            }

            continue;
          } else {
            baselineCurrent = charOrFont.origin.y;
          }

          if (!wordInit) {
            styleWord = styleCurrent;
            wordInit = true;
          }

          let bbox;
          if (orientation === 1) {
            bbox = {
              left: Math.round(charOrFont.origin.y),
              top: Math.round(pageDims.width - Math.max(charOrFont.quad.ur.x, charOrFont.quad.lr.x)),
              right: Math.round(charOrFont.origin.y + (charOrFont.quad.lr.y - charOrFont.quad.ur.y)),
              bottom: Math.round(pageDims.width - Math.min(charOrFont.quad.ul.x, charOrFont.quad.ll.x)),
            };
          } else if (orientation === 2) {
            bbox = {
              left: Math.round(pageDims.width - charOrFont.origin.x),
              top: Math.round(pageDims.height - Math.max(charOrFont.quad.ll.y, charOrFont.quad.lr.y)),
              right: Math.round(pageDims.width - (charOrFont.origin.x - (charOrFont.quad.ur.x - charOrFont.quad.ul.x))),
              bottom: Math.round(pageDims.height - Math.min(charOrFont.quad.ul.y, charOrFont.quad.ur.y)),
            };
          } else if (orientation === 3) {
            bbox = {
              left: Math.round(pageDims.height - charOrFont.origin.y),
              top: Math.round(Math.min(charOrFont.quad.ul.x, charOrFont.quad.ll.x)),
              right: Math.round(pageDims.height - charOrFont.origin.y + (charOrFont.quad.lr.y - charOrFont.quad.ur.y)),
              bottom: Math.round(Math.max(charOrFont.quad.ur.x, charOrFont.quad.lr.x)),
            };
          } else {
            bbox = {
              left: Math.round(charOrFont.origin.x),
              top: Math.round(Math.min(charOrFont.quad.ul.y, charOrFont.quad.ur.y)),
              right: Math.round(charOrFont.origin.x + (charOrFont.quad.ur.x - charOrFont.quad.ul.x)),
              bottom: Math.round(Math.max(charOrFont.quad.ll.y, charOrFont.quad.lr.y)),
            };
          }

          if (!superCurrent) {
            if (baselineFirst.length === 0) {
              let originY;
              if (orientation === 1) {
                originY = pageDims.width - charOrFont.origin.x;
              } else if (orientation === 2) {
                originY = pageDims.height - charOrFont.origin.y;
              } else if (orientation === 3) {
                originY = charOrFont.origin.x;
              } else {
                originY = charOrFont.origin.y;
              }

              baselineFirst.push(bbox.left, originY);
            }
          }

          // Small caps created by reducing font size can carry forward across multiple words.
          smallCapsCurrentAlt = smallCapsCurrentAlt ?? smallCapsAltArr[smallCapsAltArr.length - 1];

          textWordArr.push(charOrFont.text);

          bboxesWordArr.push(bbox);
        }

        if (textWordArr.length === 0) continue;

        wordLetterOrFontArrIndex.push(i);
        text.push(textWordArr);
        bboxes.push(bboxesWordArr);
        styleArr.push(styleWord);
        fontFamilyArr.push(fontFamily);
        fontSizeArr.push(fontSizeWord);
        smallCapsAltArr.push(smallCapsWordAlt);
        smallCapsArr.push(smallCapsWord);
        smallCapsAltTitleCaseArr.push(smallCapsWordAltTitleCaseAdj);

        // Superscripts are only allowed to be one word long.
        // Any identiciation of 2+ words as a superscript is assumed a false positive and disabled.
        if (superCurrent && superArr[superArr.length - 1]) {
          superArr[superArr.length - 1] = false;
          superCurrent = false;
        }

        superArr.push(superCurrent);
        if (superCurrent) fontSizeArr[fontSizeArr.length - 1] = sizeCurrentRaw;
      }

      // Return if there are no letters in the line.
      // This commonly happens for "lines" that contain only space characters.
      if (bboxes.length === 0) return;

      let baselineSlope = 0;
      if (dir && dir[0] !== undefined && !Number.isNaN(dir[0]) && dir[1] !== undefined && !Number.isNaN(dir[1])) {
        if (orientation === 1) {
          baselineSlope = -dir[0];
        } else if (orientation === 2) {
          baselineSlope = -dir[1];
        } else if (orientation === 3) {
          baselineSlope = dir[0];
        } else {
          baselineSlope = dir[1];
        }
      } else {
        console.log('Unable to parse slope.');
      }

      const lineBbox = {
        left: lineBoxArr[0], top: lineBoxArr[1], right: lineBoxArr[2], bottom: lineBoxArr[3],
      };

      // baselinePoint should be the offset between the bottom of the line bounding box, and the baseline at the leftmost point
      let baselinePoint = baselineFirst[1] - lineBbox.bottom;
      baselinePoint = baselinePoint || 0;

      const baselineOut = [(0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .round6 */ .X_)(baselineSlope), Math.round(baselinePoint)];

      // This is only a rough estimate, however since `size` is set on individual words, this value should not matter.
      const letterHeightOut = fontSizeLine * 0.6;

      const lineObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrLine */ .Ay.OcrLine(pageObj, lineBbox, baselineOut, letterHeightOut, null);

      lineObj.orientation = orientation;

      lineObj.raw = xmlLine;

      let lettersKept = 0;
      for (let i = 0; i < text.length; i++) {
        const wordText = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .unescapeXml */ .Uk)(text[i].join(''));

        if (wordText.trim() === '') continue;

        const wordLang = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcLang */ .S6)(wordText);
        langSet.add(wordLang);

        const wordID = `word_${n + 1}_${pageObj.lines.length + 1}_${i + 1}`;
        const bboxesI = bboxes[i];

        /** @type {Array<OcrChar>} */
        const charObjArr = [];

        for (let j = 0; j < text[i].length; j++) {
          const letter = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .unescapeXml */ .Uk)(text[i][j]);

          const bbox = bboxesI[j];

          // For Chinese, every "character" in the .hocr should be its own word.
          // Tesseract LSTM already does this, however Tesseract Legacy combines entire lines into the same "word",
          // which makes good alignment impossible.
          if (wordLang === 'chi_sim') {
            const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, letter, bbox, `${wordID}_${j}`);
            wordObj.conf = 100;
            wordObj.lang = wordLang;
            wordObj.visualCoords = false;

            lineObj.words.push(wordObj);
            lettersKept++;
          } else {
            const charObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrChar */ .Ay.OcrChar(letter, bbox);
            charObjArr.push(charObj);
          }
        }

        if (wordLang === 'chi_sim') continue;

        const bboxesILeft = Math.min(...bboxesI.map((x) => x.left));
        const bboxesIRight = Math.max(...bboxesI.map((x) => x.right));
        const bboxesITop = Math.min(...bboxesI.map((x) => x.top));
        const bboxesIBottom = Math.max(...bboxesI.map((x) => x.bottom));

        const bbox = {
          left: bboxesILeft, top: bboxesITop, right: bboxesIRight, bottom: bboxesIBottom,
        };

        if (bbox.left < 0 && bbox.right < 0) continue;

        const wordObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrWord */ .Ay.OcrWord(lineObj, wordText, bbox, wordID);
        wordObj.size = fontSizeArr[i];

        wordObj.lang = wordLang;

        wordObj.chars = charObjArr;

        // In stext, the coordinates are based on font bounding boxes, not where pixels start/end.
        wordObj.visualCoords = false;

        // There is no confidence information in stext.
        // Confidence is set to 100 simply for ease of reading (to avoid all red text if the default was 0 confidence).
        wordObj.conf = 100;

        if (smallCapsAltArr[i] && !/[a-z]/.test(wordObj.text) && /[A-Z].?[A-Z]/.test(wordObj.text)) {
          wordObj.smallCaps = true;
          if (smallCapsAltTitleCaseArr[i]) {
            wordObj.chars.slice(1).forEach((x) => {
              x.text = x.text.toLowerCase();
            });
          } else {
            wordObj.chars.forEach((x) => {
              x.text = x.text.toLowerCase();
            });
          }
          wordObj.text = wordObj.chars.map((x) => x.text).join('');
        } else if (smallCapsArr[i]) {
          wordObj.smallCaps = true;
        }

        if (styleArr[i] === 'italic') {
          wordObj.style = 'italic';
        } if (styleArr[i] === 'bold') {
          wordObj.style = 'bold';
        }

        wordObj.raw = wordStrArr[wordLetterOrFontArrIndex[i]];

        wordObj.font = fontFamilyArr[i];

        wordObj.sup = superArr[i];

        lineObj.words.push(wordObj);

        lettersKept++;
      }

      // If there are no letters in the line, drop the entire line element
      if (lettersKept === 0) return;

      // Recalculate the bounding box.
      // The bounding boxes reported by mupdf are often significantly larger than the actual text.
      _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.updateLineBbox(lineObj);

      pageObj.lines.push(lineObj);
      parLineArr.push(lineObj);
      // eslint-disable-next-line consistent-return
      return baselineSlope;
    }

    const lineStrArr = xmlPar.split(/<\/line>/);

    for (let i = 0; i < lineStrArr.length; i++) {
      const angle = convertLineStext(lineStrArr[i]);
      // The `Math.abs(angle) < 0.3` condition avoids vertical text impacting the angle calculation.
      // The page angle is intended to account for page skew, not different orientations (90/180/270 degrees).
      // TODO: Eventually different orientations should be supported.
      if (typeof angle === 'number' && !Number.isNaN(angle) && Math.abs(angle) < 0.3) angleRisePage.push(angle);
    }

    if (parLineArr.length === 0) return;

    const parbox = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcBboxUnion */ .gc)(parLineArr.map((x) => x.bbox));

    const parObj = new _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].OcrPar */ .Ay.OcrPar(pageObj, parbox);

    parLineArr.forEach((x) => {
      x.par = parObj;
    });

    parObj.lines = parLineArr;
    pageObj.pars.push(parObj);
  }

  const parStrArr = ocrStr.split(/<\/block>/);

  for (let i = 0; i < parStrArr.length; i++) {
    convertParStext(parStrArr[i]);
  }

  const angleRiseMedian = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .mean50 */ .lW)(angleRisePage) || 0;

  const angleOut = Math.asin(angleRiseMedian) * (180 / Math.PI);

  pageObj.angle = angleOut;

  const autoDetectTables = false;
  const dataTablePage = new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_2__/* .LayoutDataTablePage */ .Cd(n);
  if (autoDetectTables) {
    const tableBboxes = (0,_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_3__/* .detectTablesInPage */ .p9)(pageObj);

    for (let i = 0; i < pageObj.lines.length; i++) {
      const line = pageObj.lines[i];
      let inTable = false;
      for (let j = 0; j < tableBboxes.length; j++) {
        if ((0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcBoxOverlap */ .G)(line.bbox, tableBboxes[j]) > 0.25) {
          inTable = true;
          break;
        }
      }
      if (inTable) {
        const newLines = (0,_utils_ocrUtils_js__WEBPACK_IMPORTED_MODULE_4__/* .splitLineAgressively */ .fQ)(line);
        pageObj.lines.splice(i, 1, ...newLines);
      }
    }

    tableBboxes.forEach((bbox) => {
      const dataTable = (0,_utils_detectTables_js__WEBPACK_IMPORTED_MODULE_3__/* .makeTableFromBbox */ .Gx)(pageObj, bbox);
      dataTable.page = dataTablePage;
      dataTablePage.tables.push(dataTable);
    });
  }

  return { pageObj, dataTables: dataTablePage, langSet };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 3966:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ imageUtils)
/* harmony export */ });
/* unused harmony export ImageWrapper */
/* harmony import */ var _utils_imageUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5968);


class ImageWrapper {
  /**
   * @param {number} n - Page number
   * @param {string} imageStr - Base-64 encoded image string. Should start with "data:image/png" or "data:image/jpeg".
   * @param {string} colorMode - Color mode ("color", "gray", or "binary").
   * @param {boolean} rotated - Whether image has been rotated.
   * @param {boolean} upscaled - Whether image has been upscaled.
   *
   * All properties of this object must be serializable, as ImageWrapper objects are sent between threads.
   * This means that no promises can be used.
   */
  constructor(n, imageStr, colorMode, rotated = false, upscaled = false) {
    this.n = n;
    this.src = imageStr;
    const format0 = imageStr.match(/^data:image\/(png|jpeg)/)?.[1];
    if (!format0 || !['png', 'jpeg'].includes(format0)) throw new Error(`Invalid image format: ${format0}`);
    this.format = format0;
    this._dims = null;
    this.rotated = rotated;
    this.upscaled = upscaled;
    this.colorMode = colorMode;
    /** @type {?ImageBitmap} */
    this.imageBitmap = null;
  }
}

/**
 *
 * @param {import('../containers/imageContainer.js').ImageWrapper} img
 * @returns {dims}
 */
const getDims = (img) => {
  if (!img._dims) {
    if (img.format === 'jpeg') {
      img._dims = (0,_utils_imageUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .getJpegDimensions */ .sn)(img.src);
    } else {
      img._dims = (0,_utils_imageUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .getPngDimensions */ .VZ)(img.src);
    }
  }
  return img._dims;
};

/**
 * Checks whether existing transformations need to be undone by re-rendering raw image.
 * When an existing image has an unwanted tranformation, it is re-rendered from the original source,
 * rather than attempting to unrotate/downscale/etc. the transformed image.
 *
 * @param {(ImageWrapper|import('../containers/imageContainer.js').ImageProperties)} img
 * @param {?import('../containers/imageContainer.js').ImagePropertiesRequest|ImageWrapper} [props]
 * @returns
 */
const requiresUndo = (img, props) => {
  if (!props) return false;
  if (img.rotated && props.rotated === false) return true;
  if (img.upscaled && props.upscaled === false) return true;
  // This condition should only apply to PDFs.
  if (img.colorMode === 'color' && props.colorMode === 'gray' || img.colorMode === 'gray' && props.colorMode === 'color') return true;
  return false;
};

/**
 * Whether the image properties are compatible with the requested properties.
 * @param {ImageWrapper|import('../containers/imageContainer.js').ImageProperties} img
 * @param {?import('../containers/imageContainer.js').ImagePropertiesRequest|ImageWrapper} [props]
 * @param {boolean} [significantRotation] - Whether the page angle is enough to warrant re-rendering.
 */
const compatible = (img, props, significantRotation) => {
  if (!props) return true;
  if (props.rotated === false && img.rotated === true) {
    // Requests to unrotate an image are always respected, even if the angle is very close to 0.
    // This is because the intent may be to restore the raw user-uploaded image for an export, which should always be possible.
    return false;
  } if (props.rotated === true && img.rotated === false) {
    // An unrotated image is considered compatible with a rotated request if the angle is very close to 0.
    if (significantRotation) {
      return false;
    }
  }

  if (props.upscaled === true && img.upscaled === false || props.upscaled === false && img.upscaled === true) return false;

  // The value 'native' is used for images uploaded from the user, and is essentially a default value.
  // These cannot be considered incompatible with any color mode as the color of user-uploaded images is never edited (binarization aside).
  if (props.colorMode && props.colorMode !== img.colorMode && img.colorMode !== 'native' && img.colorMode !== 'native') return false;
  return true;
};

const imageUtils = {
  getDims,
  requiresUndo,
  compatible,
};


/***/ }),

/***/ 5663:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B2: () => (/* binding */ LayoutDataColumn),
/* harmony export */   Cd: () => (/* binding */ LayoutDataTablePage),
/* harmony export */   hw: () => (/* binding */ LayoutDataTable)
/* harmony export */ });
/* unused harmony exports LayoutBoxBase, LayoutRegion, LayoutPage, calcTableBbox */
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2961);


/**
 * Class representing a layout box.
 */
class LayoutBoxBase {
  /**
   * Create a layout box.
   * @param {bbox} coords - The coordinates of the layout box.
   */
  constructor(coords) {
    /** @type {string} */
    this.id = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .getRandomAlphanum */ .MT)(10);
    /** @type {bbox} */
    this.coords = coords;
    /** @type {string} */
    this.inclusionRule = 'majority';
    /** @type {string} */
    this.inclusionLevel = 'word';
  }
}

class LayoutDataColumn extends LayoutBoxBase {
  /**
   * Create a layout data column.
   * @param {bbox} coords - The coordinates of the layout data column.
   * @param {LayoutDataTable} table - The layout data table to which the column belongs.
   */
  constructor(coords, table) {
    super(coords);
    this.type = 'dataColumn';
    this.table = table;
  }
}

class LayoutRegion extends LayoutBoxBase {
  /**
   * Create a layout data column.
   * @param {LayoutPage} page
   * @param {number} priority - The priority of the layout data column.
   * @param {bbox} coords - The coordinates of the layout data column.
   * @param {('order'|'exclude')} type - The type of the layout region.
   */
  constructor(page, priority, coords, type) {
    super(coords);
    this.page = page;
    this.type = type;
    this.order = priority;
  }
}

/**
 * @param {number} n - Page number.
 */
function LayoutPage(n) {
  /** @type {number} */
  this.n = n;
  /** @type {boolean} */
  this.default = true;
  /** @type {Object<string, LayoutRegion>} */
  this.boxes = {};
}

/**
 *
 * @param {LayoutDataTable} table
 */
const calcTableBbox = (table) => {
  const boxesBboxArr = table.boxes.map((box) => box.coords);
  return calcBboxUnion(boxesBboxArr);
};

/**
 * Class representing a layout data table.
 */
class LayoutDataTable {
  /**
   * Create a layout data table.
   * @param {LayoutDataTablePage} page - The layout data table page to which the table belongs.
   */
  constructor(page) {
    this.page = page;
    this.id = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .getRandomAlphanum */ .MT)(10);
    /** @type {Array<LayoutDataColumn>} */
    this.boxes = [];
  }
}

/**
 * @param {number} n - Page number.
 */
function LayoutDataTablePage(n) {
  /** @type {number} */
  this.n = n;
  /** @type {boolean} */
  this.default = true;
  /** @type {Array<LayoutDataTable>} */
  this.tables = [];
}

const layout = {
  LayoutDataColumn,
  LayoutDataTable,
  LayoutRegion,
};

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (layout)));


/***/ }),

/***/ 7193:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   eI: () => (/* binding */ getPrevLine)
/* harmony export */ });
/* unused harmony exports OcrPage, OcrPar, OcrLine, OcrWord, OcrChar, getNextLine, getLineText, getParText, getWordFillOpacity */
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2961);


/**
 * @param {number} n
 * @param {dims} dims
 * @property {number} n - Page number (index 0)
 * @property {dims} dims - Dimensions of OCR
 * @property {number} angle - Angle of page (degrees)
 * @property {Array<OcrLine>} lines -
 */
function OcrPage(n, dims) {
  /** @type {number} */
  this.n = n;
  /** @type {dims} */
  this.dims = dims;
  /** @type {number} - Angle of page (degrees) */
  this.angle = 0;
  /** @type {Array<OcrPar>} */
  this.pars = [];
  /** @type {Array<OcrLine>} */
  this.lines = [];
}

/**
 *
 * @param {OcrPage} page
 * @param {bbox} bbox
 */
function OcrPar(page, bbox) {
  this.page = page;
  /** @type {bbox} */
  this.bbox = bbox;
  /** @type {Array<OcrLine>} */
  this.lines = [];
  /**
   * Reason for paragraph break.
   * Used for debugging purposes.
   * @type {string}
   */
  this.reason = '';
}

/**
 * @param {OcrPage} page
 * @param {bbox} bbox
 * @param {Array<number>} baseline
 * @param {?number} ascHeight - Height of median ascender character
 * @param {?number} xHeight - Height of median non-ascender/descender character
 * @property {bbox} bbox - bounding box for line
 * @property {Array<number>} baseline - baseline [slope, offset]
 * @property {?number} ascHeight -
 * @property {?number} xHeight -
 * @property {Array<OcrWord>} words - words in line
 * @property {OcrPage} page - page line belongs to
 * @property {?number} _sizeCalc - calculated line font size (using `ascHeight` and `xHeight`)
 * @property {?number} _size - line font size set (set through other means)
 *  `_size` should be preferred over `_sizeCalc` when both exist.
 * @property {?string} raw - Raw string this object was parsed from.
 *    Exists only for debugging purposes, should be `null` in production contexts.
 * @property {?{x: number, y: number}} _angleAdj - Cached x/y adjustments that must be made to coordinates when rotation is enabled.
 */
function OcrLine(page, bbox, baseline, ascHeight = null, xHeight = null) {
  // These inline comments are required for types to work correctly with VSCode Intellisense.
  // Unfortunately, the @property tags above are not sufficient.
  /** @type {bbox} */
  this.bbox = bbox;
  /** @type {Array<number>} - baseline [slope, offset] */
  this.baseline = baseline;
  /** @type {?number} */
  this.ascHeight = ascHeight;
  /** @type {?number} */
  this.xHeight = xHeight;
  /** @type {Array<OcrWord>} */
  this.words = [];
  /** @type {OcrPage} */
  this.page = page;
  /** @type {?number} */
  this._sizeCalc = null;
  /** @type {?number} */
  this._size = null;
  /** @type {?string} */
  this.raw = null;
  /** @type {?{x: number, y: number}} */
  this._angleAdj = null;
  /** @type {OcrPar} */
  this.par = null;
  /** @type {number} */
  this.orientation = 0;
}

/**
 * @param {OcrLine} line
 * @param {string} text
 * @param {bbox} bbox
 * @param {string} id
 */
function OcrWord(line, text, bbox, id) {
  /** @type {boolean} */
  this.sup = false;
  /** @type {boolean} */
  this.dropcap = false;
  /** @type {boolean} */
  this.smallCaps = false;
  /** @type {string} */
  this.text = text;
  /** @type {?string} */
  this.textAlt = null;
  /** @type {('normal'|'italic'|'bold')} */
  this.style = 'normal';
  /** @type {?string} */
  this.font = null;
  /** @type {?number} */
  this.size = null;
  /** @type {string} */
  this.lang = 'eng';
  /** @type {number} */
  this.conf = 0;
  /** @type {bbox} */
  this.bbox = bbox;
  /** @type {boolean} */
  this.compTruth = false;
  /** @type {boolean} */
  this.matchTruth = false;
  /** @type {string} */
  this.id = id;
  /** @type {OcrLine} */
  this.line = line;
  /** @type {?string} */
  this.raw = null;
  /** @type {?Array<OcrChar>} */
  this.chars = null;
  /** @type {?{x: number, y: number}} */
  this._angleAdj = null;
  /**
   * @type {boolean} - If `true`, left/right coordinates represent the left/rightmost pixel.
   * If `false`, left/right coordinates represent the start/end of the font bounding box.
   */
  this.visualCoords = true;
}

/**
 *
 * @param {string} text
 * @param {bbox} bbox
 */
function OcrChar(text, bbox) {
  /** @type {string} */
  this.text = text;
  /** @type {bbox} */
  this.bbox = bbox;
}

/**
 *
 * @param {OcrChar} char - The character to scale.
 * @param {number} scale - The scale factor.
 */
function scaleChar(char, scale) {
  char.bbox.left *= scale;
  char.bbox.top *= scale;
  char.bbox.right *= scale;
  char.bbox.bottom *= scale;
}

/**
 *
 * @param {OcrWord} word - The word to scale.
 * @param {number} scale - The scale factor.
 */
function scaleWord(word, scale) {
  word.bbox.left *= scale;
  word.bbox.top *= scale;
  word.bbox.right *= scale;
  word.bbox.bottom *= scale;

  if (word.chars) {
    for (const char of word.chars) {
      scaleChar(char, scale);
    }
  }
}

/**
 *
 * @param {OcrLine} line - The page to scale.
 * @param {number} scale - The scale factor.
 */
function scaleLine(line, scale) {
  line.bbox.left *= scale;
  line.bbox.top *= scale;
  line.bbox.right *= scale;
  line.bbox.bottom *= scale;

  for (const word of line.words) {
    scaleWord(word, scale);
  }

  if (line.ascHeight) line.ascHeight *= scale;
  if (line.xHeight) line.xHeight *= scale;

  line.baseline[1] *= scale;
}

/**
 *
 * @param {OcrPage} page - The page to scale.
 * @param {number} scale - The scale factor.
 */
function scalePage(page, scale) {
  for (const line of page.lines) {
    scaleLine(line, scale);
  }

  page.dims.width *= scale;
  page.dims.height *= scale;
}

/**
 *
 * @param {OcrLine} lineObj
 */
const getPrevLine = (lineObj) => {
  // While lines have no unique ID, word IDs are assumed unique.
  // Therefore, lines are identified using the ID of the first word.
  if (!lineObj.words[0]) throw new Error('All lines must contain >=1 word');
  const lineIndex = lineObj.page.lines.findIndex((elem) => elem.words?.[0]?.id === lineObj.words[0].id);
  if (lineIndex < 1) return null;
  return lineObj.page.lines[lineIndex - 1];
};

/**
 *
 * @param {OcrLine} lineObj
 */
const getNextLine = (lineObj) => {
  // While lines have no unique ID, word IDs are assumed unique.
  // Therefore, lines are identified using the ID of the first word.
  if (!lineObj.words[0]) throw new Error('All lines must contain >=1 word');
  const lineIndex = lineObj.page.lines.findIndex((elem) => elem.words?.[0]?.id === lineObj.words[0].id);
  if (lineIndex + 1 >= lineObj.page.lines.length) return null;
  return lineObj.page.lines[lineIndex + 1];
};

/**
 * @param {OcrPage} page
 * @param {string} id
 */
const getPageWord = (page, id) => {
  for (let i = 0; i < page.lines.length; i++) {
    for (let j = 0; j < page.lines[i].words.length; j++) {
      if (page.lines[i].words[j].id === id) return page.lines[i].words[j];
    }
  }

  return null;
};

/**
 * Delete word with id on a given page.
 * @param {OcrPage} page
 * @param {Array<string>} ids
 */
const deletePageWords = (page, ids) => {
  for (let i = 0; i < page.lines.length; i++) {
    for (let j = 0; j < page.lines[i].words.length; j++) {
      const idsIndex = ids.indexOf(page.lines[i].words[j].id);
      if (idsIndex >= 0) {
        // Delete the ID from the list
        ids.splice(idsIndex, 1);
        page.lines[i].words.splice(j, 1);
        // Subtract 1 from j to account for the fact that the array just got one element shorter
        j--;
        // If there are no words left in this line, delete the line
        if (page.lines[i].words.length === 0) {
          page.lines.splice(i, 1);
          i--;
          break;
        // If there are still words in this line, re-calculate the line bounding box.
        // To avoid duplicative calculations this only happens once at the end of the line or after all ids have been deleted.
        } else if (j + 1 === page.lines[i].words.length || ids.length === 0) {
          ocr.updateLineBbox(page.lines[i]);
        }
        // Return if all ids have been deleted.
        if (ids.length === 0) return;
      }
    }
  }
};

/**
 * @param {OcrPage} page
 */
const getPageWords = (page) => {
  const words = [];
  for (let i = 0; i < page.lines.length; i++) {
    words.push(...page.lines[i].words);
  }
  return words;
};

/**
 * Return an array of all characters used in the provided OCR data.
 * Used for subsetting fonts to only the necessary characters.
 * @param {Array<OcrPage>} ocrPageArr
 */
const getDistinctChars = (ocrPageArr) => {
  const charsAll = {};
  for (const ocrPage of ocrPageArr) {
    for (const ocrLine of ocrPage.lines) {
      for (const ocrWord of ocrLine.words) {
        ocrWord.text.split('').forEach((x) => {
          charsAll[x] = true;
        });
      }
    }
  }
  return Object.keys(charsAll);
};

/**
 * @param {OcrLine} line
 */
const getLineText = (line) => {
  let text = '';
  for (let i = 0; i < line.words.length; i++) {
    text += `${line.words[i].text}`;
    if (i < line.words.length - 1) text += ' ';
  }
  return text;
};

/**
 * @param {OcrPar} par
 */
const getParText = (par) => {
  let text = '';
  for (let i = 0; i < par.lines.length; i++) {
    if (i > 0) text += ' ';
    text += getLineText(par.lines[i]);
  }
  return text;
};

/**
 * @param {OcrPage} page
 */
const getPageText = (page) => {
  let text = '';
  for (let i = 0; i < page.lines.length; i++) {
    if (i > 0) text += '\n';
    text += getLineText(page.lines[i]);
  }
  return text;
};

/**
 * Calculates adjustments to line x and y coordinates needed to auto-rotate the page.
 * This is the rotation applied to the first word in the line (not the entire line bbox).
 * @param {OcrLine} line
 */
function calcLineStartAngleAdj(line) {
  if (!line.words[0]) {
    console.log('No words in line, report as bug.');
    return { x: 0, y: 0 };
  }

  const angle = line.page.angle * -1;
  const dims = line.page.dims;
  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));

  // Use the bounding box that is closest to the left bound of the line.
  // Note that we intentionally use real characters here, rather than predicting the baseline using the line bounding box and `baseline`,
  // as the latter was found to sometimes lead to incoherent results.
  let bbox;
  const char0Bbox = line.words[0]?.chars?.[0]?.bbox;
  if (char0Bbox) {
    bbox = char0Bbox;
  } else {
    bbox = line.words[0].bbox;
  }

  const width = line.orientation % 2 === 0 ? dims.width : dims.height;
  const height = line.orientation % 2 === 0 ? dims.height : dims.width;

  const bboxRot = rotateBbox(bbox, cosAngle, sinAngle, width, height);

  line._angleAdj = { x: bboxRot.left - bbox.left, y: bboxRot.bottom - bbox.bottom };

  return line._angleAdj;
}

/**
 * Calculates adjustments to word x and y coordinates needed to auto-rotate the page.
 * The numbers returned are *in addition* to the adjustment applied to the entire line (calculated by `calcLineStartAngleAdj`).
 *
 * @param {OcrWord} word
 */
function calcWordAngleAdj(word) {
  // if (word._angleAdj === null) {
  if (true) {
    word._angleAdj = { x: 0, y: 0 };

    const { angle } = word.line.page;

    if (Math.abs(angle ?? 0) > 0.05) {
      const sinAngle = Math.sin(angle * (Math.PI / 180));
      const cosAngle = Math.cos(angle * (Math.PI / 180));

      const x = word.bbox.left - word.line.bbox.left;
      const y = word.bbox.bottom - (word.line.bbox.bottom + word.line.baseline[1]);

      if (word.sup || word.dropcap) {
        const tanAngle = sinAngle / cosAngle;
        const angleAdjYSup = (y - (x * tanAngle)) * cosAngle - y;

        const angleAdjXSup = angle > 0 ? 0 : angleAdjYSup * tanAngle;

        word._angleAdj = { x: 0 - angleAdjXSup, y: angleAdjYSup };
      } else {
        const angleAdjXBaseline = x / cosAngle - x;
        word._angleAdj = { x: angleAdjXBaseline, y: 0 };
      }
    }
  }

  return word._angleAdj;
}

/**
 * Replace ligatures with individual ascii characters.
 * @param {string} text
 */
function replaceLigatures(text) {
  return text.replace(/Ĳ/g, 'IJ')
    .replace(/ĳ/g, 'ij')
    .replace(/ŉ/g, 'ʼn')
    .replace(/Ǳ/g, 'DZ')
    .replace(/ǲ/g, 'Dz')
    .replace(/ǳ/g, 'dz')
    .replace(/Ǆ/g, 'DŽ')
    .replace(/ǅ/g, 'Dž')
    .replace(/ǆ/g, 'dž')
    .replace(/Ǉ/g, 'LJ')
    .replace(/ǈ/g, 'Lj')
    .replace(/ǉ/g, 'lj')
    .replace(/Ǌ/g, 'NJ')
    .replace(/ǋ/g, 'Nj')
    .replace(/ǌ/g, 'nj')
    .replace(/ﬀ/g, 'ff')
    .replace(/ﬁ/g, 'fi')
    .replace(/ﬂ/g, 'fl')
    .replace(/ﬃ/g, 'ffi')
    .replace(/ﬄ/g, 'ffl')
    .replace(/ﬅ/g, 'ſt')
    .replace(/ﬆ/g, 'st');
}

/**
 * Escapes XML in a string
 * @param {String} string String to escape
 * @return {String} Escaped version of a string
 */
function escapeXml(string) {
  return string.replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

/**
 * Re-calculate bbox for line
 * @param {OcrLine} line
 * @param {boolean} adjustBaseline - Adjust baseline so that there is no visual change due to this function.
 *
 * `adjustBaseline` should generally be `true`, as calling `updateLineBbox` is not expected to change the appearance of the baseline.
 * The only case where this argument is `false` is when the baseline is adjusted elsewhere in the code,
 * notably in `rotateLine`.
 */
function updateLineBbox(line, adjustBaseline = true) {
  const lineboxBottomOrig = line.bbox.bottom;

  const wordBoxArr = line.words.map((x) => x.bbox);

  line.bbox = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .calcBboxUnion */ .gc)(wordBoxArr);

  if (adjustBaseline) line.baseline[1] += (lineboxBottomOrig - line.bbox.bottom);
}

/**
 * Re-calculate bbox for word from character-level bboxes.
 * @param {OcrWord} word
 */
function calcWordBbox(word) {
  if (!word.chars || word.chars.length === 0) return;

  const charBoxArr = word.chars.map((x) => x.bbox);

  word.bbox = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .calcBboxUnion */ .gc)(charBoxArr);
}

/**
 * Rotates bounding box.
 * Should not be used for lines--use `rotateLine` instead.
 * @param {bbox} bbox
 * @param {number} cosAngle
 * @param {number} sinAngle
 * @param {number} width
 * @param {number} height
 */
function rotateBbox(bbox, cosAngle, sinAngle, width, height) {
  // This math is technically only correct when the angle is 0, as that is the only time when
  // the left/top/right/bottom bounds exactly match the corners of the rectangle the line was printed in.
  // This is generally fine for words (as words are generally short),
  // but results in significantly incorrect results for lines.

  const bboxOut = { ...bbox };

  const xCenter = width / 2;
  const yCenter = height / 2;

  bboxOut.left = cosAngle * (bbox.left - xCenter) - sinAngle * (bbox.bottom - yCenter) + xCenter;
  bboxOut.right = cosAngle * (bbox.right - xCenter) - sinAngle * (bbox.bottom - yCenter) + xCenter;
  bboxOut.top = sinAngle * (bbox.left - xCenter) + cosAngle * (bbox.top - yCenter) + yCenter;
  bboxOut.bottom = sinAngle * (bbox.left - xCenter) + cosAngle * (bbox.bottom - yCenter) + yCenter;

  return bboxOut;
}

/**
 * Rotates line bounding box (modifies in place).
 * @param {OcrLine} line
 * @param {number} angle
 * @param {?dims} dims
 * @param {boolean} useCharLevel - Use character-level bounding boxes for rotation (if they exist).
 *    This option should only be enabled during the import process.
 *    Once users have edited the data, some words may have incorrect character-level data.
 */
function rotateLine(line, angle, dims = null, useCharLevel = false) {
  // If the angle is 0 (or very close) return early.
  if (Math.abs(angle) <= 0.05) return;

  // TODO: Is there ever a reason to use the page dims instead of the line dims?
  const dims1 = dims || line.page.dims;

  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));

  // Add preprocessing angle to baseline angle
  const { baseline } = line;
  const baselineAngleRadXML = Math.atan(baseline[0]);
  const baselineAngleRadAdj = angle * (Math.PI / 180);
  const baselineAngleRadTotal = Math.tan(baselineAngleRadXML + baselineAngleRadAdj);

  for (let i = 0; i < line.words.length; i++) {
    const word = line.words[i];
    if (useCharLevel && word.chars && word.chars.length > 0) {
      for (let j = 0; j < word.chars.length; j++) {
        const char = word.chars[j];
        char.bbox = rotateBbox(char.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
      }
      ocr.calcWordBbox(word);
    } else {
      word.bbox = rotateBbox(word.bbox, cosAngle, sinAngle, dims1.width, dims1.height);
    }
  }

  // Re-calculate line bbox by rotating original line bbox
  const lineBoxRot = rotateBbox(line.bbox, cosAngle, sinAngle, dims1.width, dims1.height);

  // Re-calculate line bbox by taking union of word bboxes
  updateLineBbox(line, false);

  // Adjust baseline
  const baselineOffsetAdj = lineBoxRot.bottom - line.bbox.bottom;

  const baselineOffsetTotal = baseline[1] + baselineOffsetAdj;

  line.baseline[0] = baselineAngleRadTotal;
  line.baseline[1] = baselineOffsetTotal;
}

/**
 * Clones page object.
 * @param {OcrPage} page
 */
function clonePage(page) {
  const pageNew = new OcrPage(page.n, { ...page.dims });
  for (const line of page.lines) {
    const lineNew = cloneLine(line);
    lineNew.page = pageNew;
    pageNew.lines.push(lineNew);
  }
  return pageNew;
}

/**
 * Clones line and included words.  Does not clone page.
 * Should be used rather than `structuredClone` for performance reasons.
 * @param {OcrLine} line
 */
function cloneLine(line) {
  const lineNew = new OcrLine(line.page, { ...line.bbox }, line.baseline.slice(), line.ascHeight, line.xHeight);
  for (const word of line.words) {
    const wordNew = cloneWord(word);
    wordNew.line = lineNew;
    lineNew.words.push(wordNew);
  }
  return lineNew;
}

/**
 * Clones word.  Does not clone line or page.
 * Should be used rather than `structuredClone` for performance reasons.
 * TODO: Rewrite this so it is dynamic and does not break every time we edit the properties of OcrWord.
 * @param {OcrWord} word
 */
function cloneWord(word) {
  const wordNew = new OcrWord(word.line, word.text, { ...word.bbox }, word.id);
  wordNew.conf = word.conf;
  wordNew.sup = word.sup;
  wordNew.smallCaps = word.smallCaps;
  wordNew.dropcap = word.dropcap;
  wordNew.font = word.font;
  wordNew.size = word.size;
  wordNew.style = word.style;
  wordNew.lang = word.lang;
  wordNew.compTruth = word.compTruth;
  wordNew.matchTruth = word.matchTruth;
  wordNew.visualCoords = word.visualCoords;
  wordNew.raw = word.raw;
  if (word.chars) {
    wordNew.chars = [];
    for (const char of word.chars) {
      wordNew.chars.push(cloneChar(char));
    }
  }
  return wordNew;
}

/**
 * Clones char.  Does not clone word, line, or page.
 * Should be used rather than `structuredClone` for performance reasons.
 * @param {OcrChar} char
 */
function cloneChar(char) {
  const charNew = new OcrChar(char.text, { ...char.bbox });
  return charNew;
}

/**
 * Gets words that match the provided text.
 * @param {string} text
 * @param {OcrPage} ocrPage
 */
function getMatchingWords(text, ocrPage) {
  text = text.trim().toLowerCase();

  if (!text) return [];
  const textArr = text.split(' ');

  const wordArr = ocr.getPageWords(ocrPage);

  const matchArr = [];

  for (let i = 0; i < wordArr.length - (textArr.length - 1); i++) {
    const word = wordArr[i];

    if (!word.text.toLowerCase().includes(textArr[0])) continue;

    const candArr = wordArr.slice(i, i + textArr.length);
    const candText = candArr.map((x) => x.text).join(' ').toLowerCase();

    if (candText.toLowerCase().includes(text)) {
      matchArr.push(...candArr);
    }
  }

  return matchArr;
}

/**
 * Gets word IDs that match the provided text.
 * @param {string} text
 * @param {OcrPage} ocrPage
 */
function getMatchingWordIds(text, ocrPage) {
  text = text.trim().toLowerCase();

  if (!text) return [];
  const textArr = text.split(' ');

  const wordArr = ocr.getPageWords(ocrPage);

  const matchIdArr = [];

  for (let i = 0; i < wordArr.length - (textArr.length - 1); i++) {
    const word = wordArr[i];

    if (!word.text.toLowerCase().includes(textArr[0])) continue;

    const candArr = wordArr.slice(i, i + textArr.length);
    const candText = candArr.map((x) => x.text).join(' ').toLowerCase();

    if (candText.toLowerCase().includes(text)) {
      matchIdArr.push(...candArr.map((x) => x.id));
    }
  }

  return matchIdArr;
}

/**
 *
 * @param {OcrWord} word
 * @param {"invis" | "ebook" | "eval" | "proof"} displayMode
 * @param {number} [confThreshMed=75]
 * @param {number} [confThreshHigh=85]
 * @param {number} [overlayOpacity=80]
 */
function getWordFillOpacity(word, displayMode, confThreshMed = 75, confThreshHigh = 85, overlayOpacity = 80) {
  let fillColorHex;
  if (word.conf > confThreshHigh) {
    fillColorHex = '#00ff7b';
  } else if (word.conf > confThreshMed) {
    fillColorHex = '#ffc800';
  } else {
    fillColorHex = '#ff0000';
  }

  const fillColorHexMatch = word.matchTruth ? '#00ff7b' : '#ff0000';

  let opacity;
  let fill;
  // Set current text color and opacity based on display mode selected
  if (displayMode === 'invis') {
    opacity = 0;
    fill = 'black';
  } else if (displayMode === 'ebook') {
    opacity = 1;
    fill = 'black';
  } else if (displayMode === 'eval') {
    opacity = overlayOpacity / 100;
    fill = fillColorHexMatch;
  } else {
    opacity = overlayOpacity / 100;
    fill = fillColorHex;
  }

  return { opacity, fill };
}

const ocr = {
  OcrPage,
  OcrPar,
  OcrLine,
  OcrWord,
  OcrChar,
  calcLineStartAngleAdj,
  updateLineBbox,
  calcBboxUnion: _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .calcBboxUnion */ .gc,
  calcWordBbox,
  calcWordAngleAdj,
  getPageWord,
  getPageWords,
  getDistinctChars,
  getMatchingWords,
  getMatchingWordIds,
  getPageText,
  getParText,
  getLineText,
  getPrevLine,
  getNextLine,
  getWordFillOpacity,
  clonePage,
  cloneLine,
  cloneWord,
  cloneChar,
  rotateLine,
  deletePageWords,
  replaceLigatures,
  scaleLine,
  scalePage,
  escapeXml,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ocr);


/***/ }),

/***/ 6776:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gx: () => (/* binding */ makeTableFromBbox),
/* harmony export */   p9: () => (/* binding */ detectTablesInPage)
/* harmony export */ });
/* unused harmony export calcColumnBounds */
/* harmony import */ var _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5663);
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7193);
/* harmony import */ var _miscUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2961);
/* harmony import */ var _ocrUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7347);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ocrUtils_js__WEBPACK_IMPORTED_MODULE_3__]);
_ocrUtils_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





/**
 *
 * @param {Array<bbox>} boundingBoxes
 */
function calcColumnBounds(boundingBoxes) {
  const tolerance = 5; // Adjust as needed

  /** @type {Array<{left: number, right: number}>} */
  const columnBounds = [];

  // Sort bounding boxes by their left edge
  boundingBoxes.sort((a, b) => a.left - b.left);

  boundingBoxes.forEach((box) => {
    let addedToColumn = false;

    for (const column of columnBounds) {
      // Check if the bounding box overlaps horizontally with the column
      if (
        box.left <= column.right + tolerance
              && box.right >= column.left - tolerance
      ) {
        // Update column bounds
        column.left = Math.min(column.left, box.left);
        column.right = Math.max(column.right, box.right);
        addedToColumn = true;
        break;
      }
    }

    // If not added to any existing column, create a new column
    if (!addedToColumn) {
      columnBounds.push({
        left: box.left,
        right: box.right,
      });
    }
  });

  // Expand column bounds so there is no empty space between columns.
  for (let i = 0; i < columnBounds.length - 1; i++) {
    const boundRight = (columnBounds[i].right + columnBounds[i + 1].left) / 2;
    columnBounds[i].right = boundRight;
    columnBounds[i + 1].left = boundRight;
  }

  return columnBounds;
}

/**
 * Detects tables in an OcrPage and returns a structured object.
 * Each table contains columns, and each column contains rows (lines).
 * @param {OcrPage} ocrPage - OcrPage object containing OcrLine objects.
 */
function detectTablesInPage(ocrPage) {
  const lines = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.clonePage(ocrPage).lines;

  // Sort lines by the top position of their bounding boxes
  lines.sort((a, b) => a.bbox.top - b.bbox.top);

  /** @type {Array<{avgTop: number, items: Array<OcrLine>}>} */
  const rows = [];
  // TODO: Make this dynamic so it adjusts based on font size.
  const rowThreshold = 10; // Threshold for vertical alignment

  // Group lines into rows based on vertical proximity
  lines.forEach((item) => {
    let addedToRow = false;

    for (const row of rows) {
      // Check if the line is vertically aligned with the row
      if (Math.abs(item.bbox.top - row.avgTop) <= rowThreshold) {
        row.items.push(item);
        // Update the average top position of the row
        row.avgTop = row.items.reduce((sum, itm) => sum + itm.bbox.top, 0) / row.items.length;
        addedToRow = true;
        break;
      }
    }

    if (!addedToRow) {
      // Create a new row if the line doesn't fit in existing rows
      rows.push({ avgTop: item.bbox.top, items: [item] });
    }
  });

  // Sort the lines within each row by their left position
  rows.forEach((row) => {
    row.items.sort((a, b) => a.bbox.left - b.bbox.left);
  });

  /**
   *
   * @param {{avgTop: number, items: Array<OcrLine>}} row
   */
  const containsNumbers = (row) => {
    let wordsNumN = 0;
    row.items.forEach((line) => {
      line.words.forEach((word) => {
        if (/[0-9]/.test(word.text)) wordsNumN++;
      });
    });

    if (wordsNumN < 4) return false;
    return true;
  };

  /**
   *
   * @param {{avgTop: number, items: Array<OcrLine>}} row
   */
  const splitRowLinesAgressively = (row) => {
    const row2 = { avgTop: row.avgTop, items: /** @type {Array<OcrLine>} */ ([]) };
    row.items.forEach((line) => {
      row2.items.push(...(0,_ocrUtils_js__WEBPACK_IMPORTED_MODULE_3__/* .splitLineAgressively */ .fQ)(line));
    });
    return row2;
  };

  /**
   *
   * @param {Array<OcrLine>} linesA
   * @param {Array<OcrLine>} linesB
   */
  const hasWordOverlap = (linesA, linesB) => {
    for (let i = 0; i < linesA.length; i++) {
      const lineI = linesA[i];
      const lineJOverlapArr = [];
      for (let j = 0; j < linesB.length; j++) {
        const lineJ = linesB[j];
        if (lineI.bbox.right < lineJ.bbox.left) break;
        if ((0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .calcHorizontalOverlap */ .NH)(lineI.bbox, lineJ.bbox) > 0) {
          lineJOverlapArr.push(lineJ);
        }
      }
      if (lineJOverlapArr.length > 1) {
        const wordsI = lineI.words;
        const wordsJ = lineJOverlapArr.map((line) => line.words).flat();

        for (const wordI of wordsI) {
          let overlapCount = 0;

          for (const wordJ of wordsJ) {
            if ((0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .calcHorizontalOverlap */ .NH)(wordI.bbox, wordJ.bbox) > 0) {
              overlapCount++;
              if (overlapCount >= 2) {
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };

  /**
   *
   * @param {Array<{avgTop: number, items: Array<OcrLine>}>} tableRows
   * @param {{avgTop: number, items: Array<OcrLine>}} row
   */
  const isCompat = (tableRows, row) => {
    if (!tableRows || tableRows.length === 0) return false;

    const expectedColumns = (0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .mean50 */ .lW)(tableRows.map((x) => x.items.length));

    // const lastRow = tableRows[tableRows.length - 1];

    const existingLines = tableRows.map((x) => x.items).flat();

    if (Math.abs(expectedColumns - row.items.length) <= 1) {
      return true;
    }

    if (globalThis.testControl) return false;

    if (hasWordOverlap(existingLines, row.items) || hasWordOverlap(row.items, existingLines)) {
      return false;
    }

    return true;
  };

  const minRows = 4; // Minimum number of rows to consider a table

  /** @type {Array<Array<{avgTop: number, items: Array<OcrLine>}>>} */
  const tables = [];
  /** @type {Array<{avgTop: number, items: Array<OcrLine>}>} */
  let currentTable = [];
  /** @type {Array<{avgTop: number, items: Array<OcrLine>}>} */
  let currentTableCompat = [];
  let currentTableStartIndex = 0;

  const rowsSplit = rows.map((row) => splitRowLinesAgressively(row));

  // Detect tables by finding consecutive rows with similar numbers of items
  for (let i = 0; i < rowsSplit.length; i++) {
    const rowSplit = rowsSplit[i];
    // const rowSplit = rows[i];
    // let rowSplit = rowsSplit[i];
    // let rowSplit;

    if (containsNumbers(rowsSplit[i])) {
      // rowSplit = splitLinesAgressively(row);
      if (currentTable.length > 0) {
        if (isCompat(currentTableCompat, rowSplit)) {
          // Continue the current table
          currentTable.push(rowSplit);
          currentTableCompat.push(rowSplit);
        } else if (currentTable.length >= minRows) {
          // TODO: Handle case where the the header row is a table row but is not compatible
          // with the rows that come afterwards, which puts us in this block.
          // End the current table and start a new one
          const headerRows = [];
          if (rowsSplit[currentTableStartIndex - 1] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 1]))
            && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 1])) {
            headerRows.push(rowsSplit[currentTableStartIndex - 1]);
            if (rowsSplit[currentTableStartIndex - 2] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 2]))
              && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 2])) {
              headerRows.push(rowsSplit[currentTableStartIndex - 2]);
            }
          }
          tables.push([...headerRows, ...currentTable]);

          currentTable = [rowSplit];
          currentTableCompat = [rowSplit];
          currentTableStartIndex = i;
        } else {
          currentTable = [rowSplit];
          currentTableCompat = [rowSplit];
          currentTableStartIndex = i;
        }
      } else {
        currentTable.push(rowSplit);
        currentTableCompat.push(rowSplit);
        currentTableStartIndex = i;
      }
    } else if (currentTable.length > 0) {
      // If the current row does not pass the checks, but the next two rows do, it is still included.
      const nextRowSplit = rowsSplit[i + 1];
      const nextRowSplit2 = rowsSplit[i + 2];
      if (nextRowSplit && nextRowSplit2 && containsNumbers(nextRowSplit) && containsNumbers(nextRowSplit2)
        && isCompat(currentTableCompat, nextRowSplit) && isCompat(currentTableCompat, nextRowSplit2)) {
        currentTable.push(rowSplit);
        continue;
      }

      if (currentTable.length >= minRows) {
        const headerRows = [];
        if (rowsSplit[currentTableStartIndex - 1] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 1]))
          && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 1])) {
          headerRows.push(rowsSplit[currentTableStartIndex - 1]);
          if (rowsSplit[currentTableStartIndex - 2] && (tables.length === 0 || !tables[tables.length - 1].includes(rowsSplit[currentTableStartIndex - 2]))
            && isCompat(currentTableCompat, rowsSplit[currentTableStartIndex - 2])) {
            headerRows.push(rowsSplit[currentTableStartIndex - 2]);
          }
        }
        tables.push([...headerRows, ...currentTable]);
      }

      currentTable = [];
      currentTableCompat = [];
    }
  }

  // Add the last table if it exists
  if (currentTable.length >= minRows) {
    tables.push(currentTable);
  }

  const tableLineBboxes = tables.map((table) => (0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .calcBboxUnion */ .gc)(table.map((row) => (0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .calcBboxUnion */ .gc)(row.items.map((item) => item.bbox)))));

  return tableLineBboxes;
}

/**
 *
 * @param {OcrPage} page
 * @param {bbox} bbox
 */
const makeTableFromBbox = (page, bbox) => {
  const lines = page.lines.filter((line) => (0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .calcBoxOverlap */ .G)(line.bbox, bbox) > 0.5);

  let columnBboxArr;
  if (lines.length > 0) {
    const lineBoxes = lines.map((line) => line.bbox);
    const columnBoundArr = calcColumnBounds(lineBoxes);
    columnBboxArr = columnBoundArr.map((column) => ({
      left: column.left,
      top: bbox.top,
      right: column.right,
      bottom: bbox.bottom,
    }));

    // Expand column bounds so there is no empty space between columns.
    columnBboxArr[0].left = bbox.left;
    columnBboxArr[columnBboxArr.length - 1].right = bbox.right;
    for (let i = 0; i < columnBboxArr.length - 1; i++) {
      const boundRight = (columnBboxArr[i].right + columnBboxArr[i + 1].left) / 2;
      columnBboxArr[i].right = boundRight;
      columnBboxArr[i + 1].left = boundRight;
    }
  } else {
    columnBboxArr = [{ ...bbox }];
  }

  const dataTable = new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_0__/* .LayoutDataTable */ .hw();

  columnBboxArr.forEach((columnBbox) => {
    const layoutBox = new _objects_layoutObjects_js__WEBPACK_IMPORTED_MODULE_0__/* .LayoutDataColumn */ .B2(columnBbox, dataTable);
    dataTable.boxes.push(layoutBox);
  });

  return dataTable;
};

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 1674:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jp: () => (/* binding */ calcWordMetrics),
/* harmony export */   o6: () => (/* binding */ calcLineFontSize),
/* harmony export */   qS: () => (/* binding */ calcWordFontSize)
/* harmony export */ });
/* unused harmony exports subsetFont, addLigatures, missingGlyphs */
/* harmony import */ var _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3695);
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7193);
/* harmony import */ var _miscUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2961);
/* harmony import */ var _lib_opentype_module_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8742);
/* harmony import */ var _containers_app_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7384);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_0__]);
_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// This file contains utility functions for calculating statistics using Opentype.js font objects.
// The only import/dependency this file should have (aside from importing misc utility functions) should be fontObjects.js.








/**
 *
 * @param {import('opentype.js').Font} font
 * @param {Array<string>} charArr
 * @returns
 */
async function subsetFont(font, charArr = []) {
  const glyphs = [];

  // Add the notdef glyph at the start of the subset.
  glyphs.push(font.glyphs.get(0));

  // Always add the space character.
  // The PDF writer may use space characters for spacing purposes,
  // even if no literal space characters are in the data.
  if (!charArr.includes(' ')) glyphs.push(font.charToGlyph(' '));

  charArr.forEach((x) => {
    const glyph = font.charToGlyph(x);
    if (glyph) glyphs.push(glyph);
  });

  // The relevant table is sometimes but not always in a property named `windows`.
  const namesTable = font.names.windows || font.names;

  // Create a new font with the subsetted glyphs.
  const subset = new opentype.Font({
    familyName: namesTable.postScriptName.en,
    styleName: namesTable.fontSubfamily.en,
    unitsPerEm: font.unitsPerEm,
    ascender: font.ascender,
    descender: font.descender,
    glyphs,
  });

  return subset;
}

/**
 * Calculates font size by comparing provided character height to font metrics.
 *
 * @param {import('opentype.js').Font} fontOpentype
 * @param {number} heightActual - Actual, measured height of text in pixels.
 * @param {string} text - Text to compare `heightActual` against.
 *
 * Note: When calculating font size from x-height, `text` should be set to "o" rather than "x".
 * Despite the name, what Tesseract (and this application) are actually calculating is closer to "o" than "x".
 */
function getFontSize(fontOpentype, heightActual, text) {
  const textArr = text.split('');
  const charMetricsFirst = fontOpentype.charToGlyph(textArr[0]).getMetrics();
  let yMin = charMetricsFirst.yMin;
  let yMax = charMetricsFirst.yMax;

  for (let i = 1; i < textArr.length; i++) {
    const charMetrics = fontOpentype.charToGlyph(textArr[i]).getMetrics();
    if (charMetrics.yMin < yMin) yMin = charMetrics.yMin;
    if (charMetrics.yMax > yMax) yMax = charMetrics.yMax;
  }

  const textHeight = (yMax - yMin) * (1 / fontOpentype.unitsPerEm);

  return Math.round(heightActual / textHeight);
}

/**
 * Calculates font size for an array of words using the most granular bounding box available (character or word-level) rather than using line-level metrics.
 * @param {Array<OcrWord>} wordArr
 * @param {import('opentype.js').Font} fontOpentype
 * @param {Boolean} [nonLatin=false]
 *
 */
function calcWordFontSizePrecise(wordArr, fontOpentype, nonLatin = false) {
  if (wordArr[0].chars && wordArr[0].chars.length > 0) {
    const charArr = wordArr.map((x) => x.chars).flat();
    const charArrFiltered = nonLatin ? charArr.filter((x) => x && (x.bbox.bottom - x.bbox.top) > 5) : charArr.filter((x) => x && /[A-Za-z0-9]/.test(x.text));
    const fontSizeCharArr = charArrFiltered.map((x) => getFontSize(fontOpentype, x.bbox.bottom - x.bbox.top, x.text));
    const fontSizeCharMedian = (0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .quantile */ .YV)(fontSizeCharArr, 0.5);
    return fontSizeCharMedian;
  }

  const wordArrFiltered = nonLatin ? wordArr.filter((x) => x && (x.bbox.bottom - x.bbox.top) > 5) : wordArr.filter((x) => x && /[A-Za-z0-9]/.test(x.text));
  const fontSizeWordArr = wordArrFiltered.map((x) => getFontSize(fontOpentype, x.bbox.bottom - x.bbox.top, x.text));
  const fontSizeWordMedian = (0,_miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .quantile */ .YV)(fontSizeWordArr, 0.5);
  return fontSizeWordMedian;
}

/**
 * Adds ligatures to text of `OcrWord` object. Returns an array of letters.
 * @param {OcrWord} word
 * @returns {Array<string>}
 */
function addLigatures(word) {
  if (word.smallCaps || !_containers_app_js__WEBPACK_IMPORTED_MODULE_4__/* .opt */ .m.ligatures) return word.text.split('');
  const fontI = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_0__/* .FontCont */ .a4.getWordFont(word);
  const fontOpentype = fontI.opentype;
  return addLigaturesText(word.text, fontOpentype);
}

/**
 * Adds ligatures if they exist in the font.
 *
 * @param {Array<string>|string} wordText
 * @param {opentype.Font} fontOpentype
 */
function addLigaturesText(wordText, fontOpentype) {
  const wordTextArr = typeof wordText === 'string' ? wordText.split('') : wordText;
  const wordCharArrOut = [];

  for (let i = 0; i < wordTextArr.length; i++) {
    const charI = wordTextArr[i];
    const charJ = wordTextArr[i + 1];

    if (charI === 'f' && charJ) {
      let charLig;
      if (charJ === 'f') {
        charLig = String.fromCharCode(64256);
      } else if (charJ === 'i') {
        charLig = String.fromCharCode(64257);
      } else if (charJ === 'l') {
        charLig = String.fromCharCode(64258);
      }
      if (charLig) {
        const glyphLig = fontOpentype.charToGlyph(charLig);
        if (glyphLig && glyphLig.index > 0 && glyphLig.name !== '.notdef' && glyphLig.path.commands.length > 0) {
          wordCharArrOut.push(charLig);
          i++;
          continue;
        }
      }
    }

    wordCharArrOut.push(charI);
  }

  return wordCharArrOut;
}

/**
 * @type {Object<string, Set<string>>}
 */
const missingGlyphs = {};

/**
 * Calculates array of advance widths and kerning values for a word.
 * Numbers are in font units. Ligatures should have been added prior to this step.
 *
 * @param {Array<string>|string} wordText
 * @param {opentype.Font} fontOpentype
 */
function calcWordCharMetrics(wordText, fontOpentype) {
  const wordTextArr = typeof wordText === 'string' ? wordText.split('') : wordText;

  /** @type {Array<number>} */
  const advanceArr = [];
  /** @type {Array<number>} */
  const kerningArr = [];
  for (let i = 0; i < wordTextArr.length; i++) {
    const charI = wordTextArr[i];
    const charJ = wordTextArr[i + 1];
    const glyphI = fontOpentype.charToGlyph(charI);
    const fontName = fontOpentype.tables.name.postScriptName.en;
    if (!glyphI || glyphI.name === '.notdef') {
      if (!missingGlyphs[fontName]) missingGlyphs[fontName] = new Set();
      missingGlyphs[fontName].add(charI);
      console.log(`Character ${charI} is not defined in font ${fontName}`);
    }
    advanceArr.push(glyphI.advanceWidth);

    if (charJ) {
      if (_containers_app_js__WEBPACK_IMPORTED_MODULE_4__/* .opt */ .m.kerning) {
        const glyphJ = fontOpentype.charToGlyph(charJ);
        const kerning = fontOpentype.getKerningValue(glyphI, glyphJ);
        kerningArr.push(kerning);
      } else {
        kerningArr.push(0);
      }
    }
  }

  return { advanceArr, kerningArr };
}

/**
 * @typedef WordMetrics
 * @type {object}
 * @property {Array<string>} charArr - Array of characters in the word, including any ligature replacements.
 * @property {number} visualWidth - Width of printed characters in px (does not include left/right bearings).
 * @property {number} leftSideBearing - Width of left bearing in px.
 * @property {number} rightSideBearing - Width of right bearing in px.
 * @property {Array<number>} advanceArr - Array of advance widths for each character in the word in px.
 * @property {Array<number>} kerningArr - Array of kerning values for each character pair in the word in px.
 * @property {number} charSpacing - Character spacing in px.
 * @property {FontContainerFont} font
 * @property {number} fontSize
 */
/**
 * @param {OcrWord} word
 * @param {number} [angle=0] - Angle of page rotation in degrees, used to calculate character spacing.
 *    This is only used during the PDF export, when the rotation is applied by a matrix transformation,
 *    so the text always needs to be printed as if it were horizontal.
 * @async
 * @return {WordMetrics}
 */
function calcWordMetrics(word, angle = 0) {
  const fontI = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_0__/* .FontCont */ .a4.getWordFont(word);
  const fontOpentype = fontI.opentype;

  const fontSize = calcWordFontSize(word);

  const charArr = addLigatures(word);

  const charArr2 = word.smallCaps ? charArr.map((x) => (x.toUpperCase())) : charArr;

  const { advanceArr, kerningArr } = calcWordCharMetrics(charArr2, fontOpentype);

  if (word.smallCaps) {
    for (let i = 0; i < charArr2.length; i++) {
      if (charArr2[i] !== charArr[i]) {
        advanceArr[i] *= fontI.smallCapsMult;
        if (kerningArr[i]) kerningArr[i] *= fontI.smallCapsMult;
      }
    }
  }

  const advanceTotal = advanceArr.reduce((a, b) => a + b, 0);
  const kerningTotal = kerningArr.reduce((a, b) => a + b, 0);

  const wordWidth1 = advanceTotal + kerningTotal;

  const wordLastGlyphMetrics = fontOpentype.charToGlyph(charArr2.at(-1)).getMetrics();
  const wordFirstGlyphMetrics = fontOpentype.charToGlyph(charArr2[0]).getMetrics();

  // The `leftSideBearing`/`rightSideBearing`/ numbers reported by Opentype.js are not accurate for mono-spaced fonts, so `xMin`/`xMax` are used instead.
  let wordLeftBearing = wordFirstGlyphMetrics.xMin || 0;
  let lastGlyphMax = wordLastGlyphMetrics.xMax || 0;
  if (word.smallCaps && charArr2[charArr2.length - 1] !== charArr[charArr2.length - 1]) lastGlyphMax *= fontI.smallCapsMult;
  let wordRightBearing = advanceArr[advanceArr.length - 1] - lastGlyphMax;
  if (word.smallCaps && charArr2[0] !== charArr[0]) wordLeftBearing *= fontI.smallCapsMult;
  if (word.smallCaps && charArr2[charArr2.length - 1] !== charArr[charArr2.length - 1]) wordRightBearing *= fontI.smallCapsMult;

  const wordWidth = word.visualCoords ? wordWidth1 - wordRightBearing - wordLeftBearing : wordWidth1;
  const wordWidthPx = wordWidth * (fontSize / fontOpentype.unitsPerEm);
  const wordLeftBearingPx = wordLeftBearing * (fontSize / fontOpentype.unitsPerEm);
  const wordRightBearingPx = wordRightBearing * (fontSize / fontOpentype.unitsPerEm);

  const advanceArrPx = advanceArr.map((x) => x * (fontSize / fontOpentype.unitsPerEm));
  const kerningArrPx = kerningArr.map((x) => x * (fontSize / fontOpentype.unitsPerEm));

  let charSpacing = 0;
  if (charArr2.length > 1) {
    const cosAngle = Math.cos(angle * (Math.PI / 180));
    const actualWidth = (word.bbox.right - word.bbox.left) / cosAngle;
    charSpacing = Math.round((actualWidth - wordWidthPx) / (charArr2.length - 1) * 1e6) / 1e6;
  }

  return {
    visualWidth: wordWidthPx,
    leftSideBearing: wordLeftBearingPx,
    rightSideBearing: wordRightBearingPx,
    advanceArr: advanceArrPx,
    kerningArr: kerningArrPx,
    charSpacing,
    font: fontI,
    fontSize,
    charArr,
  };
}

/**
 * Calculate font size for word.
 * The value will be one of:
 * (1) a manually-set value for that word,
 * (2) a calculated value for superscript/dropcap words,
 * (3) the line font size,
 * (4) a hard-coded default value.
 * @param {OcrWord} word
 */
const calcWordFontSize = (word) => {
  const font = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_0__/* .FontCont */ .a4.getWordFont(word);
  const fontOpentype = font.opentype;

  // If the word is a superscript or dropcap, then size is calculated dynamically for the word.
  // The size of these characters are currently not editable by the user.
  // This is because `size` is currently treated as the size of the main text, and does not vary between main text and superscripts.
  if (word.sup || word.dropcap) {
    if (word.visualCoords) {
      return getFontSize(fontOpentype, word.bbox.bottom - word.bbox.top, word.text);
    }
    if (word.size) {
      const mult = _miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .FontProps */ .sO.sizeMult[font.family] || 1;
      return word.size / mult;
    }

    return (word.bbox.bottom - word.bbox.top) * (fontOpentype.unitsPerEm / (fontOpentype.ascender - fontOpentype.descender));
  }

  // If the user manually set a size, then use that
  if (word.size) {
    const mult = _miscUtils_js__WEBPACK_IMPORTED_MODULE_2__/* .FontProps */ .sO.sizeMult[font.family] || 1;
    return word.size / mult;
  }
  const lineFontSize = calcLineFontSize(word.line);

  if (lineFontSize) return lineFontSize;

  return 12;
};

// Font size, unlike other characteristics (e.g. bbox and baseline), does not come purely from pixels on the input image.
// This is because different fonts will create different sized characters even when the nominal "font size" is identical.
// Therefore, the appropriate font size must be calculated using (1) the character stats from the input image and
// (2) stats regarding the font being used.
/**
 * Get or calculate font size for line.
 * This value will either be (1) a manually set value or (2) a value calculated using line metrics.
 * @param {OcrLine} line
 * @returns {number}
 */
const calcLineFontSize = (line) => {
  if (line._size) return line._size;

  // TODO: Add back cache when there are also functions that clear cache at appropriate times.
  // if (line._sizeCalc) return line._sizeCalc;

  // const anyChinese = line.words.filter((x) => x.lang === 'chi_sim').length > 0;

  const nonLatin = line.words[0]?.lang === 'chi_sim';

  const font = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_0__/* .FontCont */ .a4.getWordFont(line.words[0]);

  // This condition should be handled even if not expected to occur,
  // as some fonts (Chinese) are not loaded synchronously with the main application,
  // and not finding a font should not result in a crash.
  if (!font) {
    // If no font metrics are known, use the font size from the previous line.
    const linePrev = (0,_objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrevLine */ .eI)(line);
    if (linePrev) {
      line._sizeCalc = calcLineFontSize(linePrev);
    // If there is no previous line, as a last resort, use a hard-coded default value.
    } else {
      line._sizeCalc = 15;
    }
    return line._sizeCalc;
  }

  const fontOpentype = font.opentype;

  // Aggregate line-level metrics are unlikely to be correct for short lines (if character data is available), so calculate the size precisely.
  // This method is always used for non-Latin scripts, as the ascender/descender metrics make little sense in that context.
  if ((line.words.length <= 3 && line.words[0].chars && line.words[0].chars.length > 0) || nonLatin) {
    const fontSizeCalc = calcWordFontSizePrecise(line.words, fontOpentype, nonLatin);
    // `fontSizeCalc` has been negative under fringe conditions, so check for that.
    if (fontSizeCalc && fontSizeCalc > 0) {
      line._sizeCalc = fontSizeCalc;
      return line._sizeCalc;
    }
  }

  // If both ascender height and x-height height are known, calculate the font size using both and average them.
  if (line.ascHeight && line.xHeight) {
    const size1 = getFontSize(fontOpentype, line.ascHeight, 'A');
    const size2 = getFontSize(fontOpentype, line.xHeight, 'o');
    let sizeFinal = Math.floor((size1 + size2) / 2);

    // Averaging `size1` and `size2` is intended to smooth out small differences in calculation error.
    // However, in some cases `size1` and `size2` are so different that one is clearly wrong.
    // If `size1` and `size2` are significantly different, however one is closer to the font size of the previous line,
    // then the size of the previous line is used for averaging instead.
    if (Math.max(size1, size2) / Math.min(size1, size2) > 1.2) {
      const linePrev = (0,_objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrevLine */ .eI)(line);
      if (linePrev) {
        const sizeLast = calcLineFontSize(linePrev);
        if (sizeLast && (Math.max(size1, sizeLast) / Math.min(size1, sizeLast) <= 1.2 || Math.max(sizeLast, size2) / Math.min(sizeLast, size2) <= 1.2)) {
          if (Math.abs(sizeLast - size2) < Math.abs(sizeLast - size1)) {
            sizeFinal = Math.floor((sizeLast + size2) / 2);
          } else {
            sizeFinal = Math.floor((sizeLast + size1) / 2);
          }
        }
      }
    }

    line._sizeCalc = sizeFinal;
  // If only x-height is known, calculate font size using x-height.
  } else if (!line.ascHeight && line.xHeight) {
    line._sizeCalc = getFontSize(fontOpentype, line.xHeight, 'o');
  // If only ascender height is known, calculate font size using ascender height.
  } else if (line.ascHeight && !line.xHeight) {
    line._sizeCalc = getFontSize(fontOpentype, line.ascHeight, 'A');
  } else {
    // If no font metrics are known, use the font size from the previous line.
    const linePrev = (0,_objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrevLine */ .eI)(line);
    if (linePrev) {
      line._sizeCalc = calcLineFontSize(linePrev);
    // If there is no previous line, as a last resort, use a hard-coded default value.
    } else {
      line._sizeCalc = 15;
    }
  }

  return line._sizeCalc;
};

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 5968:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VZ: () => (/* binding */ getPngDimensions),
/* harmony export */   hP: () => (/* binding */ imageStrToBlob),
/* harmony export */   sn: () => (/* binding */ getJpegDimensions)
/* harmony export */ });
/* unused harmony exports loadImageElem, base64ToBytes */
/* eslint-disable no-bitwise */

/**
 * Loads an image from a given URL and sets it to a specified HTML element.
 *
 * @param {string|Blob|ArrayBuffer} src - Image source.  Accepts ArrayBuffer, Blob, or URL.
 * @param {HTMLImageElement} elem - The image element where the loaded image will be set.
 * @returns {Promise<HTMLImageElement>} A promise that resolves with the image element when the image is loaded successfully.
 */
async function loadImageElem(src, elem) {
  return new Promise((resolve, reject) => {
    let urlLoad;
    if (src instanceof Blob) {
      urlLoad = URL.createObjectURL(src);
    } else if (src instanceof ArrayBuffer) {
      const blob = new Blob([src]);
      urlLoad = URL.createObjectURL(blob);
    } else {
      urlLoad = src;
    }
    // const urlLoad = url instanceof Blob ? URL.createObjectURL(url) : url;
    elem.onload = () => resolve(elem);
    elem.onerror = reject;
    elem.src = urlLoad;
  });
}

function imageStrToBlob(imgStr) {
  const imgData = new Uint8Array(atob(imgStr.split(',')[1])
    .split('')
    .map((c) => c.charCodeAt(0)));

  const imgBlob = new Blob([imgData], { type: 'application/octet-stream' });

  return imgBlob;
}

/**
 * Converts a base64 encoded string to an array of bytes.
 *
 * @param {string} base64 - The base64 encoded string of the PNG image.
 * @returns {Uint8Array} The byte array representation of the image data.
 */
function base64ToBytes(base64) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

/**
 * Extracts the width and height from the IHDR chunk of a PNG image encoded in base64.
 *
 * This function decodes the base64 to bytes and parses the IHDR chunk to extract the image dimensions.
 * It assumes the base64 string is a valid PNG image and directly starts parsing the binary data.
 * Note: This is a basic implementation without extensive error handling or validation.
 *
 * @param {string} base64 - The base64 encoded string of the PNG image.
 * @returns {dims} An object containing the width and height of the image.
 */
function getPngDimensions(base64) {
  // The number 96 is chosen to line up leanly with byte boundaries (97 would result in an error)
  // but is otherwise arbitrary, while being large enough to contain the IHDR chunk.
  const bytes = base64ToBytes(base64.slice(0, 150).split(',')[1].slice(0, 96));
  // The width and height are located at specific positions in the IHDR chunk
  const width = (bytes[16] << 24) | (bytes[17] << 16) | (bytes[18] << 8) | bytes[19];
  const height = (bytes[20] << 24) | (bytes[21] << 16) | (bytes[22] << 8) | bytes[23];
  return { width, height };
}

/**
 * Gets the dimensions of a base64 encoded JPEG image.
 * @param {string} base64 - The base64 encoded JPEG image.
 * @returns {dims} The dimensions of the image.
 */
function getJpegDimensions(base64) {
  // It would be more efficient if this only converted the base64 string up to the point where the dimensions are found.
  const bytes = base64ToBytes(base64.split(',')[1]);
  let i = 0;

  // Skip the initial marker if it exists.
  if (bytes[i] === 0xFF && bytes[i + 1] === 0xD8) {
    i += 2;
  }

  while (i < bytes.length) {
    // Look for the 0xFF marker that might indicate the start of an SOF segment
    if (bytes[i] === 0xFF) {
      // List of JPEG SOF markers taken from jhead.
      // https://github.com/Matthias-Wandel/jhead/blob/4d04ac965632e35a65709c7f92a857a749e71811/jhead.h#L247-L259
      if ([0xC0, 0xC1, 0xC2, 0xC3, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 0xCD, 0xCE, 0xCF].includes(bytes[i + 1])) {
        // The height and width are stored after the marker and segment length
        const height = (bytes[i + 5] << 8) | bytes[i + 6];
        const width = (bytes[i + 7] << 8) | bytes[i + 8];
        return { width, height };
      }
      // Skip to the next marker if not an SOF marker
      const segmentLength = (bytes[i + 2] << 8) | bytes[i + 3];
      i += segmentLength + 2;
      continue;
    }
    i++;
  }
  throw new Error('Could not find dimensions in the JPEG image.');
}


/***/ }),

/***/ 2961:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ calcBoxOverlap),
/* harmony export */   MT: () => (/* binding */ getRandomAlphanum),
/* harmony export */   Mw: () => (/* binding */ determineSansSerif),
/* harmony export */   NH: () => (/* binding */ calcHorizontalOverlap),
/* harmony export */   S6: () => (/* binding */ calcLang),
/* harmony export */   TY: () => (/* binding */ getTextScript),
/* harmony export */   Uk: () => (/* binding */ unescapeXml),
/* harmony export */   X_: () => (/* binding */ round6),
/* harmony export */   YV: () => (/* binding */ quantile),
/* harmony export */   gc: () => (/* binding */ calcBboxUnion),
/* harmony export */   lW: () => (/* binding */ mean50),
/* harmony export */   oQ: () => (/* binding */ xCharArr),
/* harmony export */   sO: () => (/* binding */ FontProps),
/* harmony export */   xq: () => (/* binding */ ascCharArr)
/* harmony export */ });
/* unused harmony exports getRandomInt, readOcrFile, readTextFile, round3, countSubstringOccurrences, saveAs, reduceEvalMetrics, replaceObjectProperties, replaceSmartQuotes, range, debugLog */
// File summary:
// Various utility functions used in other files.

// Includes all capital letters except for "J" and "Q"
const ascCharArr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  'b', 'd', 'h', 'k', 'l', 't', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
const xCharArr = ['a', 'c', 'e', 'm', 'n', 'o', 'r', 's', 'u', 'v', 'w', 'x', 'z'];

/**
 *
 * @param {Array<bbox>} bboxArr
 * @returns
 */
const calcBboxUnion = (bboxArr) => ({
  left: Math.min(...bboxArr.map((x) => x.left)),
  top: Math.min(...bboxArr.map((x) => x.top)),
  right: Math.max(...bboxArr.map((x) => x.right)),
  bottom: Math.max(...bboxArr.map((x) => x.bottom)),
});

/**
 * Returns the proportion of boxA's area contained in boxB
 * @param {bbox} boxA
 * @param {bbox} boxB
 */
function calcBoxOverlap(boxA, boxB) {
  const left = Math.max(boxA.left, boxB.left);
  const top = Math.max(boxA.top, boxB.top);
  const right = Math.min(boxA.right, boxB.right);
  const bottom = Math.min(boxA.bottom, boxB.bottom);

  const width = right - left;
  const height = bottom - top;

  if (width < 0 || height < 0) return 0;

  const areaA = (boxA.bottom - boxA.top) * (boxA.right - boxA.left);
  const area = width * height;

  return area / areaA;
}

/**
 * Returns the proportion of boxA's width contained in boxB
 * @param {bbox} boxA
 * @param {bbox} boxB
 */
function calcHorizontalOverlap(boxA, boxB) {
  const left = Math.max(boxA.left, boxB.left);
  const right = Math.min(boxA.right, boxB.right);

  const widthOverlap = right - left;

  if (widthOverlap < 0) return 0;

  const widthA = boxA.right - boxA.left;

  return widthOverlap / widthA;
}

/**
 * Generates a random integer.
 *
 * @param {number} min - The minimum value (inclusive).
 * @param {number} max - The maximum value (exclusive).
 *
 * Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
 */
function getRandomInt(min, max) {
  const minI = Math.ceil(min);
  const maxI = Math.floor(max);
  return Math.floor(Math.random() * (maxI - minI) + minI); // The maximum is exclusive and the minimum is inclusive
}

/**
 * Generates a random alphanumeric string of a specified length.
 *
 * @param {number} num - The length of the alphanumeric string to generate.
 */
function getRandomAlphanum(num) {
  const outArr = new Array(num);
  for (let i = 0; i < num; i++) {
    let intI = getRandomInt(1, 62);
    if (intI <= 10) {
      intI += 47;
    } else if (intI <= 36) {
      intI = intI - 10 + 64;
    } else {
      intI = intI - 36 + 96;
    }
    outArr[i] = String.fromCharCode(intI);
  }
  return outArr.join('');
}

/**
 * Calculates the nth quantile of a given array of numbers.
 * @param {number[]} arr - The array of numbers.
 * @param {number} ntile - The quantile to calculate. Should be a value between 0 and 1.
 * @returns {number}
 * This function returns `null` if the array is empty, however the TypeScript definition does not reflect this.
 * Needing to implement type checks on every result is cumbersome, and generally not useful,
 * as other application logic often prevents empty arrays from being passed to this function.
 */
function quantile(arr, ntile) {
  if (arr.length === 0) {
    // @ts-ignore
    return null;
  }
  const arr1 = [...arr];
  const mid = Math.floor(arr.length * ntile);

  // Using sort() will convert numbers to strings by default
  arr1.sort((a, b) => a - b);

  return arr1[mid];
}

/**
 *
 * @param {Array<number>} arr
 * @returns {number}
 * This function returns `null` if the array is empty, however the TypeScript definition does not reflect this.
 * Needing to implement type checks on every result is cumbersome, and generally not useful,
 * as other application logic often prevents empty arrays from being passed to this function.
 */
const mean50 = (arr) => {
  if (arr.length === 0) {
    // @ts-ignore
    return null;
  }
  const per25 = Math.floor(arr.length / 4) - 1;
  const per75 = Math.ceil(arr.length * 3 / 4) - 1;
  const nums = [...arr].sort((a, b) => a - b);
  const numsMiddle = nums.slice(per25, per75 + 1);

  return numsMiddle.reduce((a, b) => a + b) / numsMiddle.length;
};

/**
 * Unescapes XML in a string. This should be replaced with a more robust solution.
 * @param {String} string
 * @return {String}
 */
function unescapeXml(string) {
  const replaceFunc = (match, p1) => String.fromCharCode(parseInt(p1, 16));

  return string.replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&apos;/g, "'")
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&gt;/g, '>')
    .replace(/&#39;/g, "'")
    .replace(/&#34;/g, '"')
    // The prefix &#x indicates the character is encoded as hexidecimal.
    .replace(/&#x([0-9a-f]+);/g, replaceFunc)
    .replace(/\u00AD/g, '-'); // Replace soft hyphen with regular hyphen. This is unrelated to XML escaping, but should be done for all inputs.
}

// TODO: There may be duplicated approaches between `calcLang` and `getTextScript`.
// Consider whether a unified approach can be taken across the stext and hocr parsers.
/**
 * Calculates the language of a string.
 * The only return values are 'chi_sim' and 'eng', with 'chi_sim' being returned if any character is in the range of CJK Unified Ideographs.
 * @param {string} str -
 */
function calcLang(str) {
  for (const char of str) {
    const code = char.charCodeAt(0);

    if (code >= 0 && code <= 127) continue;

    if ((code >= 0x4E00 && code <= 0x9FFF) // CJK Unified Ideographs
    || (code >= 0x3400 && code <= 0x4DBF) // CJK Unified Ideographs Extension A
    || (code >= 0x20000 && code <= 0x2A6DF) // CJK Unified Ideographs Extension B
    || (code >= 0x2A700 && code <= 0x2B73F) // CJK Unified Ideographs Extension C
    || (code >= 0x2B740 && code <= 0x2B81F) // CJK Unified Ideographs Extension D
    || (code >= 0x2B820 && code <= 0x2CEAF) // CJK Unified Ideographs Extension E
    || (code >= 0xF900 && code <= 0xFAFF) // CJK Compatibility Ideographs
    || (code >= 0x2F800 && code <= 0x2FA1F) // CJK Compatibility Ideographs Supplement
    ) return ('chi_sim');

    if ((code >= 0x0400 && code <= 0x04FF)
    || (code >= 0x0500 && code <= 0x052F)
    || code === 0x1C80
    || code === 0x1C81
    ) return ('rus');
  }

  return 'eng';
}

// Reads OCR files, which may be compressed as .gz or uncompressed

/**
 * Reads an OCR file, which may be compressed as .gz or uncompressed.
 *
 * @param {File|FileNode|string|ArrayBuffer} file - OCR file to read
 * @returns {Promise<string>} - Contents of file
 */
async function readOcrFile(file) {
  if (file instanceof ArrayBuffer) {
    const decoder = new TextDecoder('utf-8');
    return decoder.decode(file);
  }

  // Any string is assumed to be the file contents.
  if (typeof file === 'string') return file;

  // The `typeof process` condition is necessary to avoid error in Node.js versions <20, where `File` is not defined.
  if (typeof process === 'undefined' && file instanceof File) {
    if (/\.gz$/i.test(file.name)) {
      return (readTextFileGz(file));
    }
    return (readTextFile(file));
  }

  if (typeof process !== 'undefined') {
    if (!file?.fileData?.toString) throw new Error('Invalid input. Must be a FileNode, ArrayBuffer, or string.');
    // @ts-ignore
    return file.fileData.toString();
  }
  throw new Error('Invalid input. Must be a File, ArrayBuffer, or string.');
}

/**
 * Reads the contents of a Gzip-compressed text file and returns them as a promise.
 *
 * @param {File} file - The File object representing the Gzip-compressed text file to read.
 * @returns {Promise<string>} A promise that resolves with the decompressed text content of the file
 *                           or rejects with an error if reading or decompression fails.
 */
async function readTextFileGz(file) {
  const pako = await __webpack_require__.e(/* import() */ 644).then(__webpack_require__.bind(__webpack_require__, 1644));
  return new Promise(async (resolve, reject) => {
    const zip1 = await file.arrayBuffer();
    const zip2 = await pako.inflate(zip1, { to: 'string' });
    resolve(zip2);
  });
}

/**
 * Reads the contents of a text file and returns them as a promise.
 *
 * @param {File} file - The File object representing the text file to read.
 * @returns {Promise<string>} A promise that resolves with the text content of the file
 *                           or rejects with an error if reading fails.
 */
function readTextFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsText(file);
  });
}

function round3(x) {
  return (Math.round(x * 1e3) / 1e3);
}

/**
 * Rounds a number to six decimal places.
 * @param {number} x - The number to be rounded.
 * @returns {number} The rounded number.
 */
function round6(x) {
  return (Math.round(x * 1e6) / 1e6);
}

/** Function that count occurrences of a substring in a string;
 * @param {String} string               The string
 * @param {String} subString            The sub string to search for
 * @param {Boolean} [allowOverlapping]  Optional. (Default:false)
 *
 * @author Vitim.us https://gist.github.com/victornpb/7736865
 * @see Unit Test https://jsfiddle.net/Victornpb/5axuh96u/
 * @see https://stackoverflow.com/a/7924240/938822
 */
function countSubstringOccurrences(string, subString, allowOverlapping, caseSensitive = false) {
  string += '';
  subString += '';
  if (subString.length <= 0) return (string.length + 1);

  if (!caseSensitive) {
    string = string.toLowerCase();
    subString = subString.toLowerCase();
  }

  let n = 0;
  let pos = 0;
  const step = allowOverlapping ? 1 : subString.length;

  while (true) {
    pos = string.indexOf(subString, pos);
    if (pos >= 0) {
      ++n;
      pos += step;
    } else break;
  }
  return n;
}

/**
 * Saves a Blob or a string URL as a file to the user's computer.
 * Modified version of code found in FileSaver.js.
 *
 * @global
 * @param {string|ArrayBuffer|Blob} content
 * @param {string} fileName - File name.
 */
const saveAs = async (content, fileName) => {
  if (typeof process !== 'undefined') {
    const { promises: fsPromises } = await __webpack_require__.e(/* import() */ 980).then(__webpack_require__.t.bind(__webpack_require__, 8980, 19));
    await fsPromises.writeFile(fileName, content);
    return;
  }

  let blob;
  if (typeof Blob !== 'undefined' && content instanceof Blob) {
    blob = content;
  } else {
    blob = new Blob([content], { type: 'application/octet-stream' });
  }

  const a = document.createElement('a');
  a.download = fileName;
  a.href = globalThis.URL.createObjectURL(blob);
  a.dispatchEvent(new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
    view: window,
  }));
};

/**
 * Reduces an array of EvalMetrics objects into a single EvalMetrics object
 * by summing all of the corresponding properties.
 * @param {Array<EvalMetrics>} evalMetricsArr - Array of EvalMetrics objects.
 * @returns {EvalMetrics} A single EvalMetrics object with summed properties.
 */
const reduceEvalMetrics = (evalMetricsArr) => evalMetricsArr.reduce((acc, curr) => ({
  total: acc.total + curr.total,
  correct: acc.correct + curr.correct,
  incorrect: acc.incorrect + curr.incorrect,
  missed: acc.missed + curr.missed,
  extra: acc.extra + curr.extra,
  correctLowConf: acc.correctLowConf + curr.correctLowConf,
  incorrectHighConf: acc.incorrectHighConf + curr.incorrectHighConf,
}), {
  total: 0,
  correct: 0,
  incorrect: 0,
  missed: 0,
  extra: 0,
  correctLowConf: 0,
  incorrectHighConf: 0,
});

/**
 * Delete all properties from `obj` and replace with properties from `obj2`.
 * By default `obj2 = {}`, which clears `obj`.
 * @param {Object} obj
 * @param {Object} [obj2={}]
 */
function replaceObjectProperties(obj, obj2 = {}) {
  for (const prop in obj) {
    if (Object.hasOwnProperty.call(obj, prop)) {
      delete obj[prop];
    }
  }
  Object.assign(obj, obj2);
}

// Sans/serif lookup for common font families. These should not include spaces or underscores--multi-word font names should be concatenated.
// Fonts that should not be added (both Sans and Serif variants):
// DejaVu
const serifFonts = ['SerifDefault', 'Baskerville', 'Bookman', 'C059', 'Calibri', 'Cambria', 'Century', 'Courier', 'Garamond', 'Georgia',
  'LucidaBright', 'Minion', 'NimbusMono', 'Optima', 'P052', 'Palatino', 'Times'];
const sansFonts = ['SansDefault', 'Avenir', 'Arial', 'Calibri', 'Candara', 'Carlito', 'Comic', 'Franklin', 'Futura', 'Gotham',
  'Helvetica', 'Impact', 'Interstate', 'Myriad', 'Tahoma', 'Trebuchet', 'Univers', 'Verdana'];

const serifFontsRegex = new RegExp(serifFonts.reduce((x, y) => `${x}|${y}`), 'i');
const sansFontsRegex = new RegExp(sansFonts.reduce((x, y) => `${x}|${y}`), 'i');

const unidentifiedFonts = new Set();

class FontProps {
  static sansFontsDoc = new Set();

  static serifFontsDoc = new Set();

  static sizeMult = {};
}

/**
 * Given a font name from Tesseract/Abbyy XML, determine if it should be represented by sans font or serif font.
 *
 * @param {string|null|undefined} fontName - The name of the font to determine the type of. If the font name
 * is falsy, the function will return "Default".
 * @returns {('SansDefault'|'SerifDefault'|'Default')}
 */
function determineSansSerif(fontName) {
  // Remove underscores and spaces from the font name.
  fontName = fontName?.replaceAll(/[_\s]/gi, '');

  /** @type {('SansDefault'|'SerifDefault'|'Default')} */
  let fontFamily = 'Default';
  // Font support is currently limited to 1 font for Sans and 1 font for Serif.
  if (fontName && !['Default', 'GlyphLessFont', 'HiddenHorzOCR'].includes(fontName)) {
    // First, test to see if "sans" or "serif" is in the name of the font
    if (/(^|\W|_)sans($|\W|_)/i.test(fontName)) {
      fontFamily = 'SansDefault';
    } else if (/(^|\W|_)serif($|\W|_)/i.test(fontName)) {
      fontFamily = 'SerifDefault';

    // If not, check against a list of known sans/serif fonts.
    // This list is almost certainly incomplete, so should be added to when new fonts are encountered.
    } else if (serifFontsRegex.test(fontName)) {
      fontFamily = 'SerifDefault';
    } else if (sansFontsRegex.test(fontName)) {
      fontFamily = 'SansDefault';
    } else if (fontName !== 'Default Metrics Font') {
      if (/serif|rom/i.test(fontName) && !/sans/i.test(fontName)) {
        fontFamily = 'SerifDefault';
      } else if (/san/i.test(fontName)) {
        fontFamily = 'SansDefault';
      // This comes after the hard-coded values, as the hard-coded values are considered more reliable.
      // If recognition decides the font named "Arial" is a serif font, it's probably wrong.
      } else if (FontProps.sansFontsDoc.has(fontName)) {
        fontFamily = 'SansDefault';
      } else if (FontProps.serifFontsDoc.has(fontName)) {
        fontFamily = 'SerifDefault';
      } else if (!unidentifiedFonts.has(fontName)) {
        unidentifiedFonts.add(fontName);
        console.log(`Unidentified font: ${fontName}`);
      }
    }
  }

  return fontFamily;
}

/**
 *
 * @param {Array<string>|string} text - String containing word, or array containing individual letters.
 * @returns
 */
function getTextScript(text) {
  let han = 0;
  let latin = 0;
  const letterArr = typeof text === 'string' ? text.split('') : text;
  for (let j = 0; j < letterArr.length; j++) {
    if (/\p{Script=Han}/u.test(letterArr[j])) han++;
    if (/\p{Script=Latin}/u.test(letterArr[j])) latin++;
  }

  return { han, latin };
}

const replaceSmartQuotes = (text) => {
  if (!/['"]/.test(text)) return text;
  return text.replace(/(^|[-–—])'/, '$1‘')
    .replace(/(^|[-–—])"/, '$1“')
    .replace(/'(?=$|[-–—])/, '’')
    .replace(/"(?=$|[-–—])/, '”')
    .replace(/([a-z])'(?=[a-z]$)/i, '$1’');
};

/**
 *
 * @param {number} min - First number in the range.
 * @param {number} max - Last number in the range (inclusive).
 * @returns
 * `range(1, 5)` returns `[1, 2, 3, 4, 5]`.
 */
function range(min, max) {
  const result = [];
  for (let i = min; i <= max; i++) {
    result.push(i);
  }
  return result;
}

// Function that logs to stderr and then waits for the log to be flushed to the console.
// This should only be used for debugging purposes.
const debugLog = (x) => new Promise((resolve) => {
  process.stderr.write(`${String(x)}\n`, resolve);
});


/***/ }),

/***/ 7347:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fQ: () => (/* binding */ splitLineAgressively)
/* harmony export */ });
/* unused harmony exports calcConf, splitOcrWord, mergeOcrWords, checkOcrWordsAdjacent */
/* harmony import */ var _containers_app_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7384);
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7193);
/* harmony import */ var _fontUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1674);
/* harmony import */ var _miscUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2961);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_fontUtils_js__WEBPACK_IMPORTED_MODULE_2__]);
_fontUtils_js__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





/**
 *
 * @param {Array<OcrPage>} pages
 * @returns
 */
const calcConf = (pages) => {
  let wordsTotal = 0;
  let wordsHighConf = 0;
  for (let i = 0; i < pages.length; i++) {
    const words = ocr.getPageWords(pages[i]);
    for (let j = 0; j < words.length; j++) {
      const word = words[j];
      wordsTotal += 1;
      if (word.conf > opt.confThreshHigh) wordsHighConf += 1;
    }
  }
  return { total: wordsTotal, highConf: wordsHighConf };
};

/**
 *
 * @param {OcrWord} word
 * @param {number} splitIndex
 * @returns
 */
function splitOcrWord(word, splitIndex) {
  const wordA = ocr.cloneWord(word);
  const wordB = ocr.cloneWord(word);

  // Character-level metrics are often present and reliable, however may not be.
  // If a user edits the text, then the character-level metrics from the OCR engine will not match.
  // Therefore, a fallback strategy is used in this case to calculate where to split the word.
  const validCharData = word.chars && word.chars.map((x) => x.text).join('') === word.text;
  if (wordA.chars && wordB.chars) {
    wordA.chars.splice(splitIndex);
    wordB.chars.splice(0, splitIndex);
    if (validCharData) {
      wordA.bbox = calcBboxUnion(wordA.chars.map((x) => x.bbox));
      wordB.bbox = calcBboxUnion(wordB.chars.map((x) => x.bbox));
    }
  }

  // TODO: This is a quick fix; figure out how to get this math correct.
  if (!validCharData) {
    const metrics = calcWordMetrics(wordA);
    wordA.bbox.right -= metrics.advanceArr.slice(splitIndex).reduce((a, b) => a + b, 0);
    wordB.bbox.left = wordA.bbox.right;
  }

  wordA.text = wordA.text.split('').slice(0, splitIndex).join('');
  wordB.text = wordB.text.split('').slice(splitIndex).join('');

  wordA.id = `${word.id}a`;
  wordB.id = `${word.id}b`;

  return { wordA, wordB };
}

/**
 *
 * @param {Array<OcrWord>} words
 * @returns
 */
function mergeOcrWords(words) {
  words.sort((a, b) => a.bbox.left - b.bbox.left);
  const wordA = ocr.cloneWord(words[0]);
  wordA.bbox.right = words[words.length - 1].bbox.right;
  wordA.text = words.map((x) => x.text).join('');
  if (wordA.chars) wordA.chars = words.flatMap((x) => x.chars || []);
  return wordA;
}

/**
 *
 * @param {Array<OcrWord>} words
 * @returns
 */
const checkOcrWordsAdjacent = (words) => {
  const sortedWords = words.slice().sort((a, b) => a.bbox.left - b.bbox.left);
  const lineWords = words[0].line.words;
  lineWords.sort((a, b) => a.bbox.left - b.bbox.left);

  const firstIndex = lineWords.findIndex((x) => x.id === sortedWords[0].id);
  const lastIndex = lineWords.findIndex((x) => x.id === sortedWords[sortedWords.length - 1].id);
  return lastIndex - firstIndex === sortedWords.length - 1;
};

/**
 *
 * @param {OcrLine} line
 */
const splitLineAgressively = (line) => {
  /** @type {Array<OcrLine>} */
  const linesOut = [];
  const lineHeight = line.bbox.bottom - line.bbox.top;
  let wordPrev = line.words[0];
  let lineCurrent = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.cloneLine(line);
  lineCurrent.words = [line.words[0]];
  for (let i = 1; i < line.words.length; i++) {
    const word = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.cloneWord(line.words[i]);
    if (word.bbox.left - wordPrev.bbox.right > lineHeight) {
      linesOut.push(lineCurrent);
      lineCurrent = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.cloneLine(line);
      word.line = lineCurrent;
      lineCurrent.words = [word];
    } else {
      word.line = lineCurrent;
      lineCurrent.words.push(word);
    }
    wordPrev = word;
  }
  linesOut.push(lineCurrent);

  linesOut.forEach((x) => {
    _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.updateLineBbox(x);
  });

  return linesOut;
};

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 2020:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $S: () => (/* binding */ compareOCRPageImp),
/* harmony export */   Fg: () => (/* binding */ evalPageFont),
/* harmony export */   LD: () => (/* binding */ evalPageBase),
/* harmony export */   QR: () => (/* binding */ nudgePageBaseline),
/* harmony export */   Y1: () => (/* binding */ evalWords),
/* harmony export */   Zz: () => (/* binding */ nudgePageFontSize),
/* harmony export */   s_: () => (/* binding */ renderPageStaticImp)
/* harmony export */ });
/* unused harmony exports drawWordActual, drawWordRender, checkWords, nudgePageBase */
/* harmony import */ var _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7193);
/* harmony import */ var _utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1674);
/* harmony import */ var _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3695);
/* harmony import */ var _objects_imageObjects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3966);
/* harmony import */ var _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(497);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__, _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__]);
([_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__, _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// Disable linter rule.  Many async functions in this files draw on the canvas (a side effect) so need to be run one at a time.
/* eslint-disable no-await-in-loop */








/**
 * Crop the image data the area containing `words` and render to the `calcCanvas` canvas.
 * @param {Array<OcrWord>} words
 * @param {ImageBitmap} imageBinaryBit
 * @param {number} angle
 */
async function drawWordActual(words, imageBinaryBit, angle) {
  if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw) throw new Error('Fonts must be defined before running this function.');

  // The font/style from the first word is used for the purposes of font metrics
  const lineFontSize = (0,_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcLineFontSize */ .o6)(words[0].line);

  const fontI = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.getWordFont(words[0]);

  const fontOpentypeI = fontI.opentype;

  const fontAscApprox = fontOpentypeI.charToGlyph('A').getMetrics().yMax * 1.1;
  const fontDescApprox = fontOpentypeI.charToGlyph('j').getMetrics().yMin * 1.1;

  const fontDesc = Math.round(fontDescApprox * (lineFontSize / 1000));
  const fontAsc = Math.round(fontAscApprox * (lineFontSize / 1000));

  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));

  const wordsBox = words.map((x) => x.bbox);

  // Union of all bounding boxes
  const wordBoxUnion = {
    left: Math.min(...wordsBox.map((x) => x.left)),
    top: Math.min(...wordsBox.map((x) => x.top)),
    right: Math.max(...wordsBox.map((x) => x.right)),
    bottom: Math.max(...wordsBox.map((x) => x.bottom)),
  };

  // All words are assumed to be on the same line
  const lineObj = words[0].line;
  const linebox = words[0].line.bbox;
  const { baseline } = words[0].line;

  const imageRotated = angle !== 0;
  const angleAdjLine = imageRotated ? _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.calcLineStartAngleAdj(lineObj) : { x: 0, y: 0 };

  const start = linebox.left + angleAdjLine.x + (wordBoxUnion.left - linebox.left) / cosAngle;

  // We crop to the dimensions of the font (fontAsc and fontDesc) rather than the image bounding box.
  const height = Math.round(fontAsc - fontDesc);
  const width = Math.round(wordBoxUnion.right - wordBoxUnion.left + 1);

  const cropY = linebox.bottom + baseline[1] - fontAsc - 1;
  const cropYAdj = cropY + angleAdjLine.y;

  const canvas = await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.createCanvas(width, height);
  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (canvas.getContext('2d'));

  ctx.drawImage(imageBinaryBit, start - 1, cropYAdj, width, height, 0, 0, width, height);

  return {
    canvas,
    cropY,
    width,
    height,
  };
}

/**
 * Function that draws a word on a canvas.
 * This code was factored out to allow for drawing multiple times while only calculating metrics once.
 * Therefore, only the drawing code should be in this function; the metrics should be calculated elsewhere
 * and passed to this function, rather than calcualting from an `OcrWord` object.
 *
 * @param {Object} params
 * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} params.ctx
 * @param {Array<string>} params.charArr
 * @param {number} params.left
 * @param {number} params.bottom
 * @param {Array<number>} params.advanceArr - Array of pixels to advance for each character.
 *    Unlike the "advance" property of a glyph, this is the actual distance to advance on the canvas,
 *    and should include kerning and character spacing.
 * @param {FontContainerFont} params.font
 * @param {number} params.size
 * @param {boolean} params.smallCaps
 * @param {string} [params.fillStyle='black']
 */
const printWordOnCanvas = async ({
  ctx, charArr, left, bottom, advanceArr, font, size, smallCaps, fillStyle = 'black',
}) => {
  ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size}px ${font.fontFaceName}`;
  ctx.fillStyle = fillStyle;
  ctx.textBaseline = 'alphabetic';

  let leftI = left;
  for (let i = 0; i < charArr.length; i++) {
    let charI = charArr[i];

    if (smallCaps) {
      if (charI === charI.toUpperCase()) {
        ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size}px ${font.fontFaceName}`;
      } else {
        charI = charI.toUpperCase();
        ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size * font.smallCapsMult}px ${font.fontFaceName}`;
      }
    }

    ctx.fillText(charI, leftI, bottom);
    leftI += advanceArr[i];
  }
};

/**
 * Print word on canvas.
 *
 * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx
 * @param {OcrWord} word
 * @param {number} offsetX
 * @param {number} cropY
 * @param {?CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctxView
 * @param {boolean} [imageRotated=false] -
 */
const drawWordRender = async (ctx, word, offsetX = 0, cropY = 0, ctxView = null, imageRotated = false) => {
  if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw) throw new Error('Fonts must be defined before running this function.');
  if (!ctx) throw new Error('Canvases must be defined before running this function.');

  const fontI = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.getWordFont(word);

  let baselineY = word.line.bbox.bottom + word.line.baseline[1];

  const wordMetrics = (0,_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcWordMetrics */ .jp)(word);
  const advanceArr = wordMetrics.advanceArr;
  const kerningArr = wordMetrics.kerningArr;
  const charSpacing = wordMetrics.charSpacing;
  const wordFontSize = wordMetrics.fontSize;

  if (word.sup) {
    const wordboxXMid = word.bbox.left + (word.bbox.right - word.bbox.left) / 2;

    const baselineYWord = word.line.bbox.bottom + word.line.baseline[1] + word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);

    baselineY -= (baselineYWord - word.bbox.bottom);

    if (!word.visualCoords) {
      const fontDesc = fontI.opentype.descender / fontI.opentype.unitsPerEm * wordMetrics.fontSize;
      baselineY += fontDesc;
    }
  } else if (!imageRotated) {
    const wordboxXMid = word.bbox.left + (word.bbox.right - word.bbox.left) / 2;

    baselineY = word.line.bbox.bottom + word.line.baseline[1] + word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);
  }

  const y = baselineY - cropY;

  const advanceArrTotal = [];
  for (let i = 0; i < advanceArr.length; i++) {
    let leftI = 0;
    leftI += advanceArr[i] || 0;
    leftI += kerningArr[i] || 0;
    leftI += charSpacing || 0;
    advanceArrTotal.push(leftI);
  }

  let left = 1 + offsetX;
  if (word.visualCoords) left -= wordMetrics.leftSideBearing;

  await printWordOnCanvas({
    ctx, charArr: wordMetrics.charArr, left, bottom: y, advanceArr: advanceArrTotal, font: fontI, size: wordFontSize, smallCaps: word.smallCaps,
  });

  if (ctxView) {
    await printWordOnCanvas({
      ctx: ctxView, charArr: wordMetrics.charArr, left, bottom: y, advanceArr: advanceArrTotal, font: fontI, size: wordFontSize, smallCaps: word.smallCaps, fillStyle: 'red',
    });
  }
};

/**
 * Evaluate the accuracy of OCR results by comparing visually with input image.
 * Optionally, an alternative array of OCR results (for the same underlying text)
 * can be provided for comparison purposes.
 * @param {Object} params
 * @param {Array<OcrWord>} params.wordsA - Array of words
 * @param {Array<OcrWord>} [params.wordsB] - Array of words for comparison.  Optional.
 * @param {ImageBitmap} params.binaryImage - Image to compare to.  Using an ImageBitmap is more efficient
 *    when multiple compparisons are being made to the same binaryImage.
 * @param {number} params.angle - Angle image has been rotated. This should be 0 if the image has not been rotated.
 * @param {Object} [params.options]
 * @param {boolean} [params.options.view] - Draw results on debugging canvases
 * @param {boolean} [params.options.useAFontSize] - Use font size from `wordsA` when printing `wordsB`
 *   This is useful when the metrics from `wordsA` are considered systematically more reliable,
 *   such as when `wordsA` are from Tesseract Legacy and `wordsB` are from Tesseract LSTM.
 * @param {boolean} [params.options.useABaseline]
 */
async function evalWords({
  wordsA, wordsB = [], binaryImage, angle, options = {},
}) {
  // This code cannot currently handle non-Latin characters.
  // Therefore, if any Chinese words are in either set of words,
  // `wordsB` are determined correct by default.
  let anyChinese = false;
  wordsA.forEach((x) => {
    if (x.lang === 'chi_sim') anyChinese = true;
  });
  wordsB.forEach((x) => {
    if (x.lang === 'chi_sim') anyChinese = true;
  });
  // Also skip if the first word in the line, which are used for various calculations, are Chinese.
  if (wordsA[0].line.words[0].lang === 'chi_sim') anyChinese = true;
  if (wordsB[0] && wordsB[0].line.words[0].lang === 'chi_sim') anyChinese = true;

  if (anyChinese) return { metricA: 1, metricB: 0, debug: null };

  const binaryImageBit = await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.getImageBitmap(binaryImage);

  if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw) throw new Error('Fonts must be defined before running this function.');

  const view = options?.view === undefined ? false : options?.view;
  const useABaseline = options?.useABaseline === undefined ? true : options?.useABaseline;

  const cosAngle = Math.cos(angle * -1 * (Math.PI / 180)) || 1;

  // All words are assumed to be on the same line
  const linebox = wordsA[0].line.bbox;
  const baselineA = wordsA[0].line.baseline;

  // Draw the actual words (from the user-provided image)
  const {
    canvas, cropY, width, height,
  } = await drawWordActual([...wordsA, ...wordsB], binaryImageBit, angle);

  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (canvas.getContext('2d'));

  const imageDataActual = ctx.getImageData(0, 0, width, height).data;

  let canvasView0;
  let ctxView0;
  let canvasView1;
  let ctxView1;
  let canvasView2;
  let ctxView2;
  if (view) {
    let img;
    if (typeof process === 'undefined') {
      img = canvas;
    } else {
      img = _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.CanvasKit.MakeImage({
        width,
        height,
        alphaType: _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.CanvasKit.AlphaType.Unpremul,
        colorType: _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.CanvasKit.ColorType.RGBA_8888,
        colorSpace: _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.CanvasKit.ColorSpace.SRGB,
      }, imageDataActual, 4 * width);
    }

    canvasView0 = await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.createCanvas(width, height);
    ctxView0 = /** @type {OffscreenCanvasRenderingContext2D} */ (canvasView0.getContext('2d'));
    ctxView0.drawImage(img, 0, 0);
    canvasView1 = await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.createCanvas(width, height);
    ctxView1 = /** @type {OffscreenCanvasRenderingContext2D} */ (canvasView1.getContext('2d'));
    ctxView1.drawImage(img, 0, 0);
    if (wordsB.length > 0) {
      canvasView2 = await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.createCanvas(width, height);
      ctxView2 = /** @type {OffscreenCanvasRenderingContext2D} */ (canvasView2.getContext('2d'));
      ctxView2.drawImage(img, 0, 0);
    }
  }

  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, width, height);

  // Draw the words in wordsA
  let x0 = wordsA[0].bbox.left;
  const y0 = linebox.bottom + baselineA[1] + baselineA[0] * (wordsA[0].bbox.left - linebox.left);
  for (let i = 0; i < wordsA.length; i++) {
    const word = wordsA[i];
    const wordIBox = word.bbox;

    const offsetX = (wordIBox.left - x0) / cosAngle;

    await drawWordRender(ctx, word, offsetX, cropY, ctxView1, Boolean(angle));
  }

  const imageDataExpectedA = ctx.getImageData(0, 0, width, height).data;

  if (imageDataActual.length !== imageDataExpectedA.length) {
    console.log('Actual and expected images are different sizes');
    debugger;
  }

  let diffA = 0;
  let totalA = 0;
  let lastMatch = false;
  for (let i = 0; i < imageDataActual.length; i++) {
    if (imageDataActual[i] !== 255 || imageDataExpectedA[i] !== 255) {
      totalA += 1;
      if (imageDataActual[i] === 255 || imageDataExpectedA[i] === 255) {
        if (lastMatch) {
          diffA += 0.5;
        } else {
          diffA += 1;
        }
        lastMatch = false;
      } else {
        lastMatch = true;
      }
    }
  }

  const metricA = diffA / totalA;

  let metricB = 1;
  if (wordsB.length > 0) {
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);

    // Draw the words in wordsB
    for (let i = 0; i < wordsB.length; i++) {
      // Clone object so editing does not impact the original
      const word = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneWord(wordsB[i]);

      // Set style to whatever it is for wordsA.  This is based on the assumption that "A" is Tesseract Legacy and "B" is Tesseract LSTM (which does not have useful style info).
      word.font = wordsA[0].font;
      word.style = wordsA[0].style;

      if (i === 0) {
        x0 = word.bbox.left;
      }
      const offsetX = (word.bbox.left - x0) / cosAngle;

      await drawWordRender(ctx, word, offsetX, cropY, ctxView2, Boolean(angle));
    }

    const imageDataExpectedB = ctx.getImageData(0, 0, width, height).data;

    ctx.clearRect(0, 0, width, height);

    let diffB = 0;
    let totalB = 0;
    let lastMatch = false;
    for (let i = 0; i < imageDataActual.length; i++) {
      if (imageDataActual[i] !== 255 || imageDataExpectedB[i] !== 255) {
        totalB += 1;
        if (imageDataActual[i] === 255 || imageDataExpectedB[i] === 255) {
          if (lastMatch) {
            diffB += 0.5;
          } else {
            diffB += 1;
          }
          lastMatch = false;
        } else {
          lastMatch = true;
        }
      }
    }

    metricB = diffB / totalB;
  }

  /** @type {?CompDebugBrowser|CompDebugNode} */
  let debugImg = null;
  if (view) {
    if (typeof process === 'undefined') {
      let imageRaw;
      let imageA;
      let imageB;

      if (canvasView0) imageRaw = await canvasView0.convertToBlob();
      if (canvasView1) imageA = await canvasView1.convertToBlob();
      if (canvasView2) imageB = await canvasView2.convertToBlob();
      const dims = { width, height };

      debugImg = {
        context: 'browser', imageRaw, imageA, imageB, dims, errorRawA: metricA, errorRawB: metricB, errorAdjA: null, errorAdjB: null,
      };
    } else {
      let imageRaw;
      let imageA;
      let imageB;

      if (canvasView0) imageRaw = canvasView0.toDataURL('image/png');
      if (canvasView1) imageA = canvasView1.toDataURL('image/png');
      if (canvasView2) imageB = canvasView2.toDataURL('image/png');

      const dims = { width, height };

      debugImg = {
        context: 'node', imageRaw, imageA, imageB, dims, errorRawA: metricA, errorRawB: metricB, errorAdjA: null, errorAdjB: null,
      };
    }
  }

  if (typeof process !== 'undefined') {
    canvas.dispose();
    if (canvasView0) canvasView0.dispose();
    if (canvasView1) canvasView1.dispose();
    if (canvasView2) canvasView2.dispose();
  }

  return { metricA, metricB, debug: debugImg };
}

/**
 * Determines whether Tesseract Legacy word should be rejected in favor of LSTM word.
 * This should only be run when combining Tesseract Legacy and Tesseract LSTM,
 * as these heuristics are based specifically on Tesseract Legacy issues,
 * and it should only include patterns that are highly likely to be incorrect when only found in Legacy.
 * Patterns that should merely be penalized (in all engines) should be in `penalizeWord`,
 *
 * @param {string} legacyText
 * @param {string} lstmText
 */
function rejectWordLegacy(legacyText, lstmText) {
  // Automatically reject words that contain a number between two letters.
  // Tesseract Legacy commonly identifies letters as numbers (usually 1).
  // This does not just happen with "l"--in test documents "r" and "i" were also misidentified as "1" multiple times.
  const replaceNum = /[a-z]\d[a-z]/i.test(legacyText) && !/[a-z]\d[a-z]/i.test(lstmText);

  // Automatically reject words where "ii" is between two non-"i" letters
  // Tesseract Legacy commonly recognizes "ii" when the (actual) letter contains an accent,
  // while Tesseract LSTM usually recognizes the correct letter, sans the accent.
  // This "ii" pattern is automatically discarded, regardless of the overlap metrics,
  // because the overlap metrics often fail in this case.
  // E.g. the letter "ö" (o with umlaut) may overlap better with "ii" than "o".
  const replaceII = /[a-hj-z]ii[a-hj-z]/i.test(legacyText) && !/[a-hj-z]ii[a-hj-z]/i.test(lstmText);

  return replaceNum || replaceII;
}

/**
 * Calculate penalty for word using ad-hoc heuristics.
 * Supplements word overlap strategy by penalizing patterns that may have plausible overlap
 * but are implausible from a language perspective (e.g. "1%" being misidentified as "l%")
 * @param {Array<OcrWord>} wordObjs - Array of OcrWord objects. All objects should (potentially) belong to a single word,
 *    rather than this function being used on an entire line.
 */
async function penalizeWord(wordObjs) {
  const wordStr = wordObjs.map((x) => x.text).join('');

  let penalty = 0;
  // Penalize non-numbers followed by "%"
  // This potentially penalizes valid URLs
  if (/[^0-9]%/.test(wordStr)) penalty += 0.05;

  // Penalize "ii" (virtually always a false positive)
  // If this penalty becomes an issue, a whitelist of dictionary words containing "ii" can be added
  if (/ii/.test(wordStr)) penalty += 0.05;

  // Penalize single-letter word "m"
  // When Tesseract Legacy incorrectly combines letters, resulting wide "character" is usually identified as "m".
  // Therefore, "m" as a single word is likely a short word like "to" that was not segmented correctly.
  if (/^m$/.test(wordStr)) penalty += 0.05;

  // Penalize digit between two letters
  // This usually indicates a letter is being misidentified as "0" or "1"
  if (/[a-z]\d[a-z]/i.test(wordStr)) penalty += 0.05;

  // Penalize "]" at the start of word (followed by at least one other character)
  // Motivated by "J" being misidentified as "]"
  // (Overlap can be fairly strong of no actual "]" characters are present due to font optimization)
  if (/^\]./.test(wordStr)) penalty += 0.05;

  // Penalize likely noise characters.
  // These are identified as characters that cause the characters to overlap, however if reduced, the spacing would be plausible.
  // This is currently limited to two letter words where a letter is following by a period, comma, or dash,
  // however should likely be expanded in the future to cover more cases.
  // See notes for more explanation of this issue.
  if (wordObjs.length === 1 && /^[a-z][.,-]$/i.test(wordStr)) {
    const word = wordObjs[0];
    const wordTextArr = wordStr.split('');
    const wordFontSize = (0,_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcLineFontSize */ .o6)(word.line);

    const fontI = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.getWordFont(word);
    const fontOpentypeI = fontI.opentype;

    // These calculations differ from the standard word width calculations,
    // because they do not include left/right bearings.
    const glyphFirstMetrics = fontOpentypeI.charToGlyph(wordTextArr[0]).getMetrics();
    const widthFirst = (glyphFirstMetrics.xMax - glyphFirstMetrics.xMin) / fontOpentypeI.unitsPerEm * wordFontSize;

    const glyphSecondMetrics = fontOpentypeI.charToGlyph(wordTextArr[1]).getMetrics();
    const widthSecond = (glyphSecondMetrics.xMax - glyphSecondMetrics.xMin) / fontOpentypeI.unitsPerEm * wordFontSize;

    const widthTotal = widthFirst + widthSecond;

    const wordWidth = word.bbox.right - word.bbox.left;

    if (widthFirst >= wordWidth * 0.9 && widthTotal > wordWidth * 1.15) penalty += 0.05;
  }

  return penalty;
}

/**
 * Checks words in pageA against words in pageB.
 * @param {object} params
 * @param {OcrPage} params.pageA
 * @param {OcrPage} params.pageB
 * @param {import('../containers/imageContainer.js').ImageWrapper} params.binaryImage
 * @param {PageMetrics} params.pageMetricsObj
 * @param {object} params.options
 * @param {("stats"|"comb")} [params.options.mode='stats'] - If `mode = 'stats'` stats quantifying the number of matches/mismatches are returned.
 *    If `mode = 'comb'` a new version of `pageA`, with text and confidence metrics informed by comparisons with pageB, is created.
 * @param {boolean} [params.options.editConf] - Whether confidence metrics should be updated when `mode = 'stats'`,
 *    rather than simply setting `compTruth`/`matchTruth`. Enabled when using recognition to update confidence metrics, but not when comparing to ground truth.
 * @param {boolean} [params.options.legacyLSTMComb] - Whether Tesseract Legacy and Tesseract LSTM are being combined, when `mode = 'comb'`.
 *    When `legacyLSTMComb` is enabled, additional heuristics are applied that are based on specific behaviors of the Tesseract Legacy engine.
 * @param {boolean} [params.options.useBboxB] - Use bounding boxes from `pageB` in combined output.
 * @param {string} [params.options.debugLabel]
 * @param {boolean} [params.options.evalConflicts] - Whether to evaluate word quality on conflicts. If `false` the text from `pageB` is always assumed correct.
 *    This option is useful for combining the style from Tesseract Legacy with the text from Tesseract LSTM.
 * @param {boolean} [params.options.supplementComp] - Whether to run additional recognition jobs for words in `pageA` not in `pageB`
 * @param {Tesseract.Worker} [params.options.tessWorker] - Tesseract worker to use for recognizing text. Must be provided if `supplementComp` is `true`.
 * @param {boolean} [params.options.ignorePunct]
 * @param {boolean} [params.options.ignoreCap]
 * @param {number} [params.options.confThreshHigh]
 * @param {number} [params.options.confThreshMed]
 */
async function compareOCRPageImp({
  pageA, pageB, binaryImage, pageMetricsObj, options = {},
}) {
  // The `binaryImage` argument is not sent for certain operations, which do not require it.
  // For example, running a basic comparison between a page and the ground truth does not require having the image.
  // The types do not currently reflect this, so this should be reworked at some point.
  /** @type {?ImageBitmap} */
  let binaryImageBit = null;
  let imageUpscaled = false;
  let imageRotated = false;

  if (binaryImage) {
    binaryImageBit = binaryImage.imageBitmap || await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.getImageBitmap(binaryImage.src);
    imageUpscaled = binaryImage.upscaled;
    imageRotated = binaryImage.rotated;
  }

  const mode = options?.mode === undefined ? 'stats' : options?.mode;
  const editConf = options?.editConf === undefined ? false : options?.editConf;
  const legacyLSTMComb = options?.legacyLSTMComb === undefined ? false : options?.legacyLSTMComb;
  const useBboxB = options?.useBboxB === undefined ? false : options?.useBboxB;
  const debugLabel = options?.debugLabel === undefined ? '' : options?.debugLabel;
  const evalConflicts = options?.evalConflicts === undefined ? true : options?.evalConflicts;
  const supplementComp = options?.supplementComp === undefined ? false : options?.supplementComp;
  const tessWorker = options?.tessWorker === undefined ? null : options?.tessWorker;
  const ignorePunct = options?.ignorePunct === undefined ? false : options?.ignorePunct;
  const ignoreCap = options?.ignoreCap === undefined ? false : options?.ignoreCap;
  const confThreshHigh = options?.confThreshHigh === undefined ? 85 : options?.confThreshHigh;
  const confThreshMed = options?.confThreshMed === undefined ? 75 : options?.confThreshMed;

  if (supplementComp && !tessWorker) console.log('`supplementComp` enabled, but no scheduler was provided. This step will be skipped.');

  // If this is not being run in a worker, clone the data so the original is not edited.
  // This is not necessary when running in a worker, as the data is already cloned when sent to the worker.
  if (typeof WorkerGlobalScope === 'undefined') {
    pageA = structuredClone(pageA);
    pageB = structuredClone(pageB);
  }

  const imgAngle = imageRotated ? (pageMetricsObj.angle || 0) : 0;
  if (imageUpscaled) {
    _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.scalePage(pageA, 2);
    _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.scalePage(pageB, 2);
  }

  const debugImg = [];

  const hocrAOverlap = {};
  const hocrBOverlap = {};
  const hocrBOverlapAWords = {};
  const hocrACorrect = {};
  const hocrBCorrect = {};

  // Reset all comparison-related fields in input page
  _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWords(pageA).forEach((x) => {
    x.compTruth = false;
    x.matchTruth = false;
  });

  // Create copy of `pageA` so original is not edited.
  // This is used to get the original confidence metrics later in the code.
  const pageAInt = structuredClone(pageA);

  if (mode === 'comb') {
    _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWords(pageAInt).forEach((x) => {
      x.conf = 0;
    });
  }

  // TODO: This assumes that the lines are in a specific order, which may not always be the case.
  //    Add a sorting step or otherwise make more robust.
  // TODO: Does this need to consider rotation?  It does not do so at present.
  for (let i = 0; i < pageAInt.lines.length; i++) {
    const lineA = pageAInt.lines[i];
    const lineBoxA = lineA.bbox;

    let lineWordsEditedNew = 0;
    let lineBReplace = null;

    for (let j = 0; j < pageB.lines.length; j++) {
      const lineB = pageB.lines[j];
      const lineBoxB = lineB.bbox;

      // If top of line A is below bottom of line B, move to next line B
      if (lineBoxA.top > lineBoxB.bottom) {
        // minLineB = minLineB + 1;
        continue;

        // If top of line B is below bottom of line A, move to next line A
        // (We assume no match is possible for any B)
      } else if (lineBoxB.top > lineBoxA.bottom) {
        continue;

        // Otherwise, there is possible overlap
      } else {
        let minWordB = 0;

        for (let k = 0; k < lineA.words.length; k++) {
          const wordA = lineA.words[k];

          // TODO: Despite the comment, this code does not actually return early.
          //    Consider how to best handle this situation--if we just add a "continue" statement
          //    some of the stats may not add up.
          // If option is set to ignore punctuation and the current "word" conly contains punctuation,
          // exit early with options that will result in the word being printed in green.
          if (ignorePunct && !wordA.text.replace(/[\W_]/g, '')) {
            wordA.compTruth = true;
            wordA.matchTruth = true;
            if (mode === 'comb') wordA.conf = 100;
            hocrACorrect[wordA.id] = 1;
          }

          const wordBoxA = wordA.bbox;

          // Remove 10% from top/bottom of bounding box
          // This prevents small overlapping (around the edges) from triggering a comparison.
          // Nothing should be removed from left/right, as this would prevent legitimate one-to-many
          // relationships from being identified.

          const wordBoxAHeight = wordBoxA.bottom - wordBoxA.top;

          const wordBoxACore = JSON.parse(JSON.stringify(wordBoxA));

          if (wordA.visualCoords) {
            wordBoxACore.top = wordBoxA.top + Math.round(wordBoxAHeight * 0.1);
            wordBoxACore.bottom = wordBoxA.bottom - Math.round(wordBoxAHeight * 0.1);
          } else {
            wordBoxACore.top = wordBoxA.top + Math.round(wordBoxAHeight * 0.25);
            wordBoxACore.bottom = wordBoxA.bottom - Math.round(wordBoxAHeight * 0.25);
          }

          for (let l = minWordB; l < lineB.words.length; l++) {
            const wordB = lineB.words[l];
            const wordBoxB = wordB.bbox;

            // Remove 10% from top/bottom of bounding box
            // This prevents small overlapping (around the edges) from triggering a comparison.
            // Nothing should be removed from left/right, as this would prevent legitimate one-to-many
            // relationships from being identified.
            const wordBoxBHeight = wordBoxB.bottom - wordBoxB.top;

            const wordBoxBCore = JSON.parse(JSON.stringify(wordBoxB));

            if (wordB.visualCoords) {
              wordBoxBCore.top = wordBoxB.top + Math.round(wordBoxBHeight * 0.1);
              wordBoxBCore.bottom = wordBoxB.bottom - Math.round(wordBoxBHeight * 0.1);
            } else {
              wordBoxBCore.top = wordBoxB.top + Math.round(wordBoxBHeight * 0.25);
              wordBoxBCore.bottom = wordBoxB.bottom - Math.round(wordBoxBHeight * 0.25);
            }

            // If left of word A is past right of word B, move to next word B
            if (wordBoxACore.left > wordBoxBCore.right) {
              minWordB += 1;
              continue;

              // If left of word B is past right of word A, move to next word B
            } else if (wordBoxBCore.left > wordBoxACore.right) {
              continue;

              // Otherwise, overlap is likely
            } else {
              // Check for overlap using word height
              if (wordBoxACore.top > wordBoxBCore.bottom || wordBoxBCore.top > wordBoxACore.bottom) {
                continue;
              }

              // Mark `wordA` as having been compared
              wordA.compTruth = true;

              let wordTextA = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.replaceLigatures(wordA.text);
              let wordTextB = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.replaceLigatures(wordB.text);
              if (ignorePunct) {
                // Punctuation next to numbers is not ignored, even if this setting is enabled, as punctuation differences are
                // often/usually substantive in this context (e.g. "-$1,000" vs $1,000" or "$100" vs. "$1.00")
                wordTextA = wordTextA.replace(/(^|\D)[\W_]($|\D)/g, '$1$2');
                wordTextB = wordTextB.replace(/(^|\D)[\W_]($|\D)/g, '$1$2');
              }
              if (ignoreCap) {
                wordTextA = wordTextA.toLowerCase();
                wordTextB = wordTextB.toLowerCase();
              }

              hocrAOverlap[wordA.id] = 1;
              hocrBOverlap[wordB.id] = 1;

              if (!hocrBOverlapAWords[wordB.id]) hocrBOverlapAWords[wordB.id] = {};
              hocrBOverlapAWords[wordB.id][wordA.id] = 1;

              // TODO: Account for cases without 1-to-1 mapping between bounding boxes
              if (wordTextA === wordTextB) {
                wordA.compTruth = true;
                wordA.matchTruth = true;
                if (mode === 'comb') wordA.conf = 100;
                hocrACorrect[wordA.id] = 1;
                hocrBCorrect[wordB.id] = 1;
                if (mode === 'comb' && useBboxB) {
                  wordA.bbox = structuredClone(wordB.bbox);
                  wordA.visualCoords = true;
                  wordA.chars = structuredClone(wordB.chars);
                }
              } else if (mode === 'comb') {
                wordA.conf = 0;
                wordA.matchTruth = false;

                // Check if there is a 1-to-1 comparison between words (this is usually true)
                let oneToOne = Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxB.right - wordBoxA.right) < (wordBoxA.right - wordBoxA.left) * 0.1;

                // Note: The following block solves an issue that I believe has been patched in our version of Tesseract.
                // Due to a bug with the LSTM engine, when a word is split into 3 words (for example), the first and last word can have the right bound.
                // This condition should catch cases where `oneToOne` is `true`, however the appropriate comparison is actually 2-to-1 or 3-to-1.
                const wordBNext = lineB.words[l + 1];
                const wordBNext2 = lineB.words[l + 2];
                const wordBNext3 = lineB.words[l + 3];
                if (oneToOne && legacyLSTMComb) {
                  if (wordBNext3 && wordBNext3.text.length > 2) {
                    const wordBoxBNext3 = wordBNext3.bbox;
                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext3.right) < (wordBoxBNext3.right - wordBoxA.left) * 0.1) oneToOne = false;
                  }

                  if (wordBNext2 && wordBNext2.text.length > 2) {
                    const wordBoxBNext2 = wordBNext2.bbox;
                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext2.right) < (wordBoxBNext2.right - wordBoxA.left) * 0.1) oneToOne = false;
                  }

                  if (wordBNext && wordBNext.text.length > 2) {
                    const wordBoxBNext = wordBNext.bbox;
                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext.right) < (wordBoxBNext.right - wordBoxA.left) * 0.1) oneToOne = false;
                  }
                }

                let twoToOne = false;
                const wordsAArr = [];
                let wordsBArr = [];

                // If there is no 1-to-1 comparison, check if a 2-to-1 comparison is possible using the next word in either dataset
                if (!oneToOne) {
                  if (wordBoxA.right < wordBoxB.right) {
                    const wordANext = lineA.words[k + 1];
                    if (wordANext) {
                      const wordBoxANext = wordANext.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxB.right - wordBoxANext.right) < (wordBoxANext.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsAArr.push(wordANext);
                        wordsBArr.push(wordB);

                        wordANext.conf = 0;
                        wordANext.compTruth = true;
                        wordANext.matchTruth = false;
                      }
                    }
                  } else {
                    if (wordBNext3) {
                      const wordBoxBNext3 = wordBNext3.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext3.right) < (wordBoxBNext3.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsBArr.push(wordB);
                        wordsBArr.push(wordBNext);
                        wordsBArr.push(wordBNext2);
                        wordsBArr.push(wordBNext3);
                      }
                    }

                    if (wordBNext2 && !twoToOne) {
                      const wordBoxBNext2 = wordBNext2.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext2.right) < (wordBoxBNext2.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsBArr.push(wordB);
                        wordsBArr.push(wordBNext);
                        wordsBArr.push(wordBNext2);
                      }
                    }

                    if (wordBNext && !twoToOne) {
                      const wordBoxBNext = wordBNext.bbox;
                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext.right) < (wordBoxBNext.right - wordBoxA.left) * 0.1) {
                        twoToOne = true;
                        wordsAArr.push(wordA);
                        wordsBArr.push(wordB);
                        wordsBArr.push(wordBNext);
                      }
                    }

                    // If comparing one word from Tesseract Legacy with multiple words from Tesseract LSTM, and the letters are mostly the same,
                    // use the bounding boxes from Tesseract Legacy.  These should be more accurate.
                    if (twoToOne && legacyLSTMComb) {
                      const wordsAText = wordsAArr.map((x) => x.text).join('');
                      const wordsBText = wordsBArr.map((x) => x.text).join('');
                      if (wordsAArr.length === 1 && wordsAArr[0]?.chars?.length === wordsAText.length && wordsAText.length === wordsBText.length) {
                        // To make sure the legacy boxes are comparable, either:
                        // (1) the text must be the same between Legacy and LSTM (aside from one word being split/combined), or
                        // (2) the LSTM version must have 2 words, one word matches, and the total number of letters is the same.
                        const match = wordsAText === wordsBText;
                        const match1 = wordsAArr[0].text.substring(0, wordsBArr[0].text.length) === wordsBArr[0].text;
                        const match2 = wordsAArr[0].text.substring(wordsBArr[0].text.length, wordsBArr[0].text.length + wordsBArr[1].text.length) === wordsBArr[1].text;

                        if (match || (wordsBArr.length === 2 && (match1 || match2))) {
                          wordsBArr = wordsBArr.map((x) => _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneWord(x));
                          wordsBArr[0].chars = wordsAArr[0].chars.slice(0, wordsBArr[0].text.length).map((x) => _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneChar(x));
                          wordsBArr[1].chars = wordsAArr[0].chars.slice(wordsBArr[0].text.length, wordsBArr[0].text.length + wordsBArr[1].text.length).map((x) => _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneChar(x));
                          if (wordsBArr[2]) {
                            wordsBArr[2].chars = wordsAArr[0].chars.slice(wordsBArr[0].text.length + wordsBArr[1].text.length,
                              wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length).map((x) => _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneChar(x));
                          }
                          if (wordsBArr[3]) {
                            wordsBArr[3].chars = wordsAArr[0].chars.slice(wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length,
                              wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length + wordsBArr[3].text.length).map((x) => _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneChar(x));
                          }
                          if (!match) {
                            wordsBArr[0].chars.forEach((x, i) => x.text = wordsBArr[0].text[i]);
                            wordsBArr[1].chars.forEach((x, i) => x.text = wordsBArr[1].text[i]);
                            if (wordsBArr[2]) wordsBArr[2].chars.forEach((x, i) => x.text = wordsBArr[2].text[i]);
                          }
                          for (const word of wordsBArr) {
                            // @ts-ignore
                            word.bbox = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.calcBboxUnion(word.chars.map((x) => x.bbox));
                          }
                        }
                      }
                    }
                  }
                }

                // Only consider switching word contents if their bounding boxes are close together
                // This should filter off cases where 2+ words in one dataset match to 1 word in another
                // TODO: Account for cases without 1-to-1 mapping between bounding boxes
                if (!oneToOne && !twoToOne) {
                  continue;
                }

                let hocrAError = 1;
                let hocrBError = 1;
                let hocrAAltError = 1;

                if (!evalConflicts) {
                  hocrBError = 0;
                } else if (oneToOne) {
                  // Some common patterns detected by Tesseract Legacy are so implausible that they are automatically rejected.
                  if (legacyLSTMComb && rejectWordLegacy(wordA.text, wordB.text)) {
                    hocrBError = 0;
                  // If the top choice out of the Tesseract Legacy classifier (but not entire model) is the same as the Tesseract LSTM choice, use the LSTM choice.
                  // This condition is common when the Legacy model improperly applies a dictionary "correction" to a word that was already correct.
                  } else if (legacyLSTMComb && wordA.textAlt && wordA.textAlt === wordB.text) {
                    hocrBError = 0;
                  // Otherwise, the words are compared visually.
                  } else {
                    // TODO: Figure out how to compare between small caps/non small-caps words (this is the only relevant style as it is the only style LSTM detects)
                    // Clone hocrAWord and set text content equal to hocrBWord
                    const wordAClone = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneWord(wordA);
                    wordAClone.text = wordB.text;

                    if (wordB.smallCaps && !wordA.smallCaps) {
                      wordAClone.smallCaps = true;
                      wordAClone.size = (0,_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcWordFontSize */ .qS)(wordB);
                    }

                    const evalRes = await evalWords({
                      wordsA: [wordA], wordsB: [wordAClone], binaryImage: binaryImageBit, angle: imgAngle, options: { view: Boolean(debugLabel) },
                    });

                    hocrAError = evalRes.metricA + (await penalizeWord([wordA]));
                    hocrBError = evalRes.metricB + (await penalizeWord([wordB]));

                    // Reject Tesseract Legacy word if appropriate
                    if (legacyLSTMComb && rejectWordLegacy(wordA.text, wordB.text)) hocrBError = 0;

                    // The alternative word from Tesseract legacy is tested if both other options are rejected.
                    // This can be useful for relatively high-quality scans of non-dictionary words, which both the LSTM model and the Legacy model (after dictionary correction) may fail on,
                    // with the raw results from the Legacy classifier being the most accurate.
                    if (legacyLSTMComb && hocrAError > 0.5 && hocrBError > 0.5 && wordA.textAlt && wordA.textAlt !== wordB.text) {
                      wordAClone.text = wordA.textAlt;

                      // This would run faster if it was built into the original evalWords function, but this case should be rare enough that it doesn't matter.
                      const evalResAlt = await evalWords({
                        wordsA: [wordAClone], binaryImage: binaryImageBit, angle: imgAngle, options: { view: Boolean(debugLabel) },
                      });

                      hocrAAltError = evalResAlt.metricA + (await penalizeWord([wordAClone]));

                      // To use the alt word, the error must be less than 0.5, and the alt word but be at least 0.1 better than both other options.
                      if (hocrAAltError >= 0.5 || (hocrAError - hocrAAltError) < 0.1 || (hocrBError - hocrAAltError) < 0.1) hocrAAltError = 1;
                    }

                    if (evalRes.debug) {
                      const debugObj = evalRes.debug;
                      debugObj.errorAdjA = hocrAError;
                      debugObj.errorAdjB = hocrBError;

                      debugImg.push(debugObj);
                    }
                  }
                } else if (twoToOne) {
                  const wordsAText = wordsAArr.map((x) => x.text).join('');
                  const wordsBText = wordsBArr.map((x) => x.text).join('');

                  if (legacyLSTMComb && rejectWordLegacy(wordsAText, wordsBText)) {
                    hocrBError = 0;
                  } else {
                    const evalRes = await evalWords({
                      wordsA: wordsAArr, wordsB: wordsBArr, binaryImage: binaryImageBit, angle: imgAngle, options: { view: Boolean(debugLabel) },
                    });

                    // The option with more words has a small penalty added, as otherwise words incorrectly split will often score slightly better (due to more precise positioning)
                    hocrAError = evalRes.metricA + (wordsAArr.length - 1) * 0.025 + (await penalizeWord(wordsAArr));
                    hocrBError = evalRes.metricB + (wordsBArr.length - 1) * 0.025 + (await penalizeWord(wordsBArr));

                    // An additional penalty is added to the option with more words when (1) the text is the same in both options and (2) at least one word has no letters.
                    // This has 2 primary motivations:
                    //  1. Tesseract Legacy often splits numbers into separate words.
                    //    For example, the "-" in a negative number may be a different word, or the digits before and after the decimal point may be split into separate words.
                    //    TODO: It may be worth investigating if this issue can be improved in the engine.
                    //  1. Punctuation characters should not be their own word (e.g. quotes should come before/after alphanumeric characters)
                    if (wordsAText === wordsBText) {
                      if (wordsAArr.map((x) => /[a-z]/i.test(x.text)).filter((x) => !x).length > 0 || wordsBArr.map((x) => /[a-z]/i.test(x.text)).filter((x) => !x).length > 0) {
                        hocrAError += (wordsAArr.length - 1) * 0.05;
                        hocrBError += (wordsBArr.length - 1) * 0.05;
                      }
                    }

                    // Reject Tesseract Legacy word if appropriate
                    if (legacyLSTMComb && rejectWordLegacy(wordsAText, wordsBText)) hocrBError = 0;

                    if (evalRes.debug) {
                      const debugObj = evalRes.debug;
                      debugObj.errorAdjA = hocrAError;
                      debugObj.errorAdjB = hocrBError;

                      debugImg.push(debugObj);
                    }
                  }
                }

                // The LSTM model is known to be more accurate on average.
                // Therefore, if both metrics are terrible (indicating the word isn't lined up at all), the LSTM word is used.
                if ((hocrBError < hocrAError && hocrBError < hocrAAltError) || (legacyLSTMComb && hocrAError > 0.5 && hocrAAltError > 0.5)) {
                  const skip = ['eg', 'ie'].includes(wordA.text.replace(/\W/g, ''));

                  if (!skip) {
                    if (oneToOne) {
                      lineWordsEditedNew += 1;
                      lineBReplace = lineB;

                      wordA.text = wordB.text;

                      // Erase character-level data rather than replacing it, as the LSTM data is not expected to be accurate.
                      // There should eventually be an option to disable this when Tesseract Combined is the "B" data and user-provided data is the "A".
                      wordA.chars = null;

                      // Switch to small caps/non-small caps based on style of replacement word.
                      // This is not relevant for italics as the LSTM engine does not detect italics.
                      if (wordB.smallCaps) wordA.smallCaps = true;
                    } else {
                      const wordsBArrRep = wordsBArr.map((x) => _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneWord(x));

                      lineWordsEditedNew += wordsBArrRep.length;
                      lineBReplace = lineB;

                      wordsBArrRep.forEach((x) => {
                        // Use style from word A (assumed to be Tesseract Legacy)
                        if (legacyLSTMComb) {
                          x.font = wordA.font;
                          x.style = wordA.style;
                          x.smallCaps = wordA.smallCaps;
                        }

                        // Set confidence to 0
                        x.conf = 0;

                        // Erase character-level data rather than replacing it, as the LSTM data is not expected to be accurate.
                        // There should eventually be an option to disable this when Tesseract Combined is the "B" data and user-provided data is the "A".
                        x.chars = null;

                        x.compTruth = true;
                        x.matchTruth = false;

                        x.line = lineA;

                        // Change ID to prevent duplicates
                        x.id += 'b';
                      });

                      // Replace "A" words with "B" words
                      lineA.words.splice(k, wordsAArr.length, ...wordsBArrRep);

                      k = k + wordsBArrRep.length - 1;

                      // Move to next hocrAWord
                      break;
                    }
                  }
                } else if (wordA.textAlt && hocrAAltError < 0.5 && hocrAAltError < hocrAError) {
                  lineWordsEditedNew += 1;
                  if (wordA.text.length !== wordA.textAlt.length) wordA.chars = null;
                  wordA.text = wordA.textAlt;
                }
              }
            }
          }
        }
      }
    }

    // If a majority of words in line A are replaced, replace the ascender height and x-height with those from line B.
    if (lineBReplace && lineWordsEditedNew > lineA.words.length * 0.5) {
      lineA.ascHeight = lineBReplace.ascHeight;
      lineA.xHeight = lineBReplace.xHeight;
    }
  }

  // If `supplementComp` is enabled, we run OCR for any words in pageA without an existing comparison in pageB.
  // This ensures that every word has been checked.
  // Unlike the comparisons above, this is strictly for confidence purposes--if conflicts are identified the text is not edited.
  if (supplementComp && tessWorker && evalConflicts) {
    for (let i = 0; i < pageAInt.lines.length; i++) {
      const line = pageAInt.lines[i];
      for (let j = 0; j < line.words.length; j++) {
        const word = line.words[j];
        if (!word.compTruth) {
          const res = await checkWords([word], binaryImageBit, imageRotated, pageMetricsObj, tessWorker, {
            ignorePunct, tessWorker, view: false,
          });
          word.matchTruth = res.match;
          word.conf = word.matchTruth ? 100 : 0;
        }
      }
    }
  }

  // In addition to not making sense, the statistics below will not be properly calculated when `mode == "comb"` and errors will be thrown if attempted.
  // The core issue is that pageAInt is being actively edited `mode == "comb"`.
  // Therefore, `hocrAOverlap` ends up including words not in `pageA`, so `ocr.getPageWord(pageA, overlappingWordsA[i]);` returns `null`.
  if (mode === 'comb') {
    if (imageUpscaled) _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.scalePage(pageAInt, 0.5);

    return {
      page: pageAInt, metrics: null, debugImg,
    };
  }

  // Note: These metrics leave open the door for some fringe edge cases.
  // For example,

  const hocrBAll = {};
  _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWords(pageB).forEach((x) => {
    hocrBAll[x.id] = 1;
  });

  const hocrAAll = {};
  _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWords(pageAInt).forEach((x) => {
    hocrAAll[x.id] = 1;
  });

  // Delete any punctuation-only words from the stats if they are being ignored.
  if (ignorePunct) {
    const punctOnlyIDsA = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWords(pageA).filter((x) => !x.text.replace(/[\W_]/g, '')).map((x) => x.id);
    punctOnlyIDsA.forEach((x) => {
      delete hocrAAll[x];
      delete hocrAOverlap[x];
      delete hocrACorrect[x];
    });
    const punctOnlyIDsB = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWords(pageB).filter((x) => !x.text.replace(/[\W_]/g, '')).map((x) => x.id);
    punctOnlyIDsB.forEach((x) => {
      delete hocrBAll[x];
      delete hocrBOverlap[x];
      delete hocrBCorrect[x];
    });
  }

  // Number of words in ground truth
  const totalCountB = Object.keys(hocrBAll).length;

  // Number of words in candidate OCR
  const totalCountA = Object.keys(hocrAAll).length;

  // Number of words in ground truth with any overlap with candidate OCR
  const overlapCountB = Object.keys(hocrBOverlap).length;

  // Number of words in candidate OCR with any overlap with ground truth
  const overlapCountA = Object.keys(hocrAOverlap).length;

  // Number of words in ground truth correctly identified by 1+ overlapping word in candidate OCR
  const correctCount = Object.keys(hocrBCorrect).length;

  // Number of words in ground truth not identified by 1+ overlapping word in candidate OCR
  const incorrectCount = overlapCountB - correctCount;

  let correctCountLowConf = 0;
  let incorrectCountHighConf = 0;
  const overlappingWordsB = Object.keys(hocrBOverlap);
  for (let i = 0; i < overlappingWordsB.length; i++) {
    const wordBID = overlappingWordsB[i];

    const wordAIDs = Object.keys(hocrBOverlapAWords[wordBID]);

    let lowConfCount = 0;
    let highConfCount = 0;
    for (let j = 0; j < wordAIDs.length; j++) {
      // The word comes from the original input (pageA) since we need unedited confidence metrics.
      const word = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWord(pageA, wordAIDs[j]);
      if (word.conf <= confThreshMed) {
        lowConfCount++;
      } else if (word.conf > confThreshHigh) {
        highConfCount++;
      }
    }

    const match = hocrBCorrect[wordBID];

    if (match && lowConfCount > 0) {
      correctCountLowConf++;
    } else if (!match && highConfCount > 0) {
      incorrectCountHighConf++;
    }
  }

  /** @type {EvalMetrics} */
  const metricsRet = {
    total: totalCountB,
    correct: correctCount,
    incorrect: incorrectCount,
    missed: totalCountB - overlapCountB,
    extra: totalCountA - overlapCountA,
    correctLowConf: correctCountLowConf,
    incorrectHighConf: incorrectCountHighConf,
  };

  // Confidence scores are only edited if an option is set.
  // This is because confidence scores should not be edited when comparing to ground truth.
  if (editConf) {
    _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getPageWords(pageAInt).forEach((x) => {
      x.conf = x.matchTruth ? 100 : 0;
    });
  }

  if (imageUpscaled) _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.scalePage(pageAInt, 0.5);

  return {
    page: pageAInt, metrics: metricsRet, debugImg,
  };
}

/**
 * @param {Array<OcrWord>} wordsA
 * @param {ImageBitmap} binaryImage
 * @param {boolean} imageRotated - Whether provided `binaryImage` has been rotated.
 * @param {PageMetrics} pageMetricsObj
 * @param {object} [options]
 * @param {boolean} [options.view] - TODO: make this functional or remove
 * @param {boolean} [options.ignorePunct]
 * @param {boolean} [options.ignoreCap]
 */
async function checkWords(wordsA, binaryImage, imageRotated, pageMetricsObj, tessWorker, options = {}) {
  const view = options?.view === undefined ? false : options?.view;
  const ignorePunct = options?.ignorePunct === undefined ? false : options?.ignorePunct;
  const ignoreCap = options?.ignoreCap === undefined ? false : options?.ignoreCap;

  // Draw the actual words (from the user-provided image)
  const angle = imageRotated ? (pageMetricsObj.angle || 0) : 0;
  // const ctxViewArr = view ? [{ canvas: viewCanvas0, ctx: viewCtx0 }, { canvas: viewCanvas1, ctx: viewCtx1 }, { canvas: viewCanvas2, ctx: viewCtx2 }] : undefined;
  const { canvas } = await drawWordActual(wordsA, binaryImage, angle);

  const extraConfig = {
    tessedit_pageseg_mode: '6', // "Single block"
  };

  const inputImage = typeof process === 'undefined' ? await canvas.convertToBlob() : await canvas.toDataURL();

  const res = (await tessWorker.recognize(inputImage, extraConfig)).data;

  let wordTextA = wordsA.map((x) => x.text).join(' ');
  let wordTextB = res.text.trim();

  wordTextA = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.replaceLigatures(wordTextA);
  wordTextB = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.replaceLigatures(wordTextB);

  if (ignorePunct) {
    // Punctuation next to numbers is not ignored, even if this setting is enabled, as punctuation differences are
    // often/usually substantive in this context (e.g. "-$1,000" vs $1,000" or "$100" vs. "$1.00")
    wordTextA = wordTextA.replace(/(^|\D)[\W_]($|\D)/g, '$1$2');
    wordTextB = wordTextB.replace(/(^|\D)[\W_]($|\D)/g, '$1$2');
  }
  if (ignoreCap) {
    wordTextA = wordTextA.toLowerCase();
    wordTextB = wordTextB.toLowerCase();
  }

  return { match: wordTextA === wordTextB };
}

/**
 * @param {Object} params
 * @param {OcrPage|OcrLine} params.page
 * @param {import('../containers/imageContainer.js').ImageWrapper} params.binaryImage
 * @param {PageMetrics} params.pageMetricsObj
 * @param {?function} [params.func=null]
 * @param {boolean} [params.view=false] - Draw results on debugging canvases
 * @returns
 */
async function evalPageBase({
  page, binaryImage, pageMetricsObj, func = null, view = false,
}) {
  // If this is not being run in a worker, clone the data so the original is not edited.
  // This is not necessary when running in a worker, as the data is already cloned when sent to the worker.
  if (typeof WorkerGlobalScope === 'undefined') {
    page = structuredClone(page);
  }

  const lines = 'lines' in page ? page.lines : [page];

  const imgAngle = binaryImage.rotated ? (pageMetricsObj.angle || 0) : 0;
  if (binaryImage.upscaled) {
    for (let i = 0; i < lines.length; i++) {
      _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.scaleLine(lines[i], 2);
    }
  }

  const binaryImageBit = binaryImage.imageBitmap || await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.getImageBitmap(binaryImage.src);

  if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw) throw new Error('Fonts must be defined before running this function.');

  let metricTotal = 0;
  let wordsTotal = 0;
  const debugArr = [];

  for (let j = 0; j < lines.length; j++) {
    let ocrLineJ = lines[j];

    // The Chinese font is currently not loaded in the workers, so trying to evaluate it will cause an error.
    if (ocrLineJ.words[0].lang === 'chi_sim') continue;

    if (func) {
      ocrLineJ = await func(lines[j]);
    }

    if (!ocrLineJ) continue;

    const evalRes = await evalWords({
      wordsA: ocrLineJ.words, binaryImage: binaryImageBit, angle: imgAngle, options: { view },
    });

    metricTotal += (evalRes.metricA * ocrLineJ.words.length);

    wordsTotal += ocrLineJ.words.length;

    if (evalRes.debug) debugArr.push(evalRes.debug);
  }

  return { wordsTotal, metricTotal, debug: debugArr };
}

/**
 * @param {Object} params
 * @param {OcrPage} params.page
 * @param {import('../containers/imageContainer.js').ImageWrapper} params.binaryImage
 * @param {PageMetrics} params.pageMetricsObj
 * @param {string} params.font
 * @param {boolean} [params.opt=false] - Whether to use the optimized font set
 * @returns
 */
async function evalPageFont({
  page, binaryImage, pageMetricsObj, font, opt = false,
}) {
  const enableOptSave = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.enableOpt;
  const forceOptSave = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.forceOpt;

  // Allowing the font to be set here allows for better performance during font optimization compared to using the `enableFontOpt` function.
  // This is because the `enableFontOpt` function requires a response from the main thread and *every* worker before completing, which leads to non-trivial waiting time.
  if (opt === true) {
    if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.opt) throw new Error('Optimized fonts requested but not defined.');
    _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.forceOpt = true;
  } else if (opt === false) {
    if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw) throw new Error('Raw fonts requested but not defined.');
    _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.enableOpt = false;
    _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.forceOpt = false;
  }

  /**
   * @param {OcrLine} ocrLineJ
   */
  const transformLineFont = (ocrLineJ) => {
    if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw) throw new Error('Fonts must be defined before running this function.');

    if (!ocrLineJ.words[0]) {
      console.log('Line has 0 words, this should not happen.');
      return _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneLine(ocrLineJ);
    }

    // If the font is not set for a specific word, whether it is assumed sans/serif will be determined by the default font.
    const lineFontType = ocrLineJ.words[0].font ? _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.getWordFont(ocrLineJ.words[0]).type : _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.getFont('Default').type;

    if (_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw[font].normal.type !== lineFontType) return null;

    const ocrLineJClone = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneLine(ocrLineJ);

    ocrLineJClone.words.forEach((x) => {
      x.font = font;
    });

    return ocrLineJClone;
  };

  const res = await evalPageBase({
    page, binaryImage, pageMetricsObj, func: transformLineFont,
  });

  _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.enableOpt = enableOptSave;
  _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.forceOpt = forceOptSave;

  return res;
}

/**
 * @param {Object} params
 * @param {OcrPage} params.page
 * @param {import('../containers/imageContainer.js').ImageWrapper} params.binaryImage
 * @param {PageMetrics} params.pageMetricsObj
 * @param {function} params.func
 * @param {boolean} params.view
 * @returns
 */
async function nudgePageBase({
  page, binaryImage, pageMetricsObj, func, view = false,
}) {
  // If this is not being run in a worker, clone the data so the original is not edited.
  // This is not necessary when running in a worker, as the data is already cloned when sent to the worker.
  if (typeof WorkerGlobalScope === 'undefined') {
    page = structuredClone(page);
  }

  const imgAngle = binaryImage.rotated ? (pageMetricsObj.angle || 0) : 0;
  if (binaryImage.upscaled) {
    _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.scalePage(page, 2);
  }

  const binaryImageBit = binaryImage.imageBitmap || await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.getImageBitmap(binaryImage.src);

  if (!_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.raw) throw new Error('Fonts must be defined before running this function.');
  if (!calcCtx) throw new Error('Canvases must be defined before running this function.');

  let improveCt = 0;
  let totalCt = 0;

  const debugImg = [];

  for (const ocrLineJ of page.lines) {
    const tryNudge = async (x) => {
      const ocrLineJClone = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.cloneLine(ocrLineJ);
      await func(ocrLineJClone, x);

      if (!ocrLineJClone) return false;

      const evalRes = await evalWords({
        wordsA: ocrLineJ.words, wordsB: ocrLineJClone.words, binaryImage: binaryImageBit, angle: imgAngle, options: { view, useAFontSize: false, useABaseline: false },
      });

      if (evalRes.debug) debugImg.push(evalRes.debug);

      if (evalRes.metricB < evalRes.metricA) {
        return true;
      }
      return false;
    };

    const res1 = await tryNudge(1);
    if (res1) {
      await func(ocrLineJ, 1);
      improveCt += 1;
    } else {
      const res2 = await tryNudge(-1);
      if (res2) {
        await func(ocrLineJ, -1);
        improveCt += 1;
      }
    }

    totalCt += 1;
  }

  return {
    page, improveCt, totalCt, debug: view ? debugImg : null,
  };
}

/**
 * @param {Object} params
 * @param {OcrPage} params.page
 * @param {import('../containers/imageContainer.js').ImageWrapper} params.binaryImage
 * @param {PageMetrics} params.pageMetricsObj
 * @param {boolean} params.view
 * @returns
 */
async function nudgePageFontSize({
  page, binaryImage, pageMetricsObj, view = false,
}) {
  const func = async (lineJ, x) => {
    const fontSizeBase = (0,_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcLineFontSize */ .o6)(lineJ);
    if (!fontSizeBase) return;
    lineJ._size = fontSizeBase + x;
  };

  return await nudgePageBase({
    page, binaryImage, pageMetricsObj, func, view,
  });
}

/**
 * @param {Object} params
 * @param {OcrPage} params.page
 * @param {import('../containers/imageContainer.js').ImageWrapper} params.binaryImage
 * @param {PageMetrics} params.pageMetricsObj
 * @param {boolean} params.view
 * @returns
 */
async function nudgePageBaseline({
  page, binaryImage, pageMetricsObj, view = false,
}) {
  const func = async (lineJ, x) => {
    lineJ.baseline[1] += x;
  };

  return await nudgePageBase({
    page, binaryImage, pageMetricsObj, func, view,
  });
}

/**
 * Render a page to a canvas.
 * This function is a WIP and not all options are implemented.
 * @param {Object} args
 * @param {OcrPage} args.page - Page to render.
 * @param {import('../containers/imageContainer.js').ImageWrapper} args.image
 * @param {dims} [args.pageDims] - Dimensions of page.
 * @param {?number} [args.angle=0] - Angle of page.
 * @param {("proof" | "invis" | "ebook" | "eval")} [args.displayMode='proof'] - Display mode.
 * @param {number} [args.confThreshMed=75] - Threshold above which words are medium-confidence (0-100).
 * @param {number} [args.confThreshHigh=85] - Threshold above which words are high-confidence (0-100).
 * @returns {Promise<Blob>}
 *
 * TODO: This function does not belong here, however it is in this file because this is where the canvases live.
 * Think about how to refactor--the canvases within workers probably belong in their own container.
 *
 */
const renderPageStaticImp = async ({
  page, image, angle = 0, displayMode = 'proof', confThreshMed = 75, confThreshHigh = 85,
}) => {
  const dims = image ? _objects_imageObjects_js__WEBPACK_IMPORTED_MODULE_3__/* .imageUtils */ .R.getDims(image) : page.dims;

  const canvas = await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.createCanvas(dims.width, dims.height);
  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (/** @type {unknown} */ (canvas.getContext('2d')));

  const imageBit = await _canvasAdapter_js__WEBPACK_IMPORTED_MODULE_4__.ca.getImageBitmap(image.src);
  if (image) ctx.drawImage(imageBit, 0, 0);

  angle = angle ?? 0;

  ctx.textBaseline = 'alphabetic';

  const sinAngle = Math.sin(angle * (Math.PI / 180));
  const cosAngle = Math.cos(angle * (Math.PI / 180));

  for (const lineObj of page.lines) {
    const angleAdjLine = image.rotated ? _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.calcLineStartAngleAdj(lineObj) : { x: 0, y: 0 };

    const baselineY = lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y;
    const lineLeftAdj = lineObj.bbox.left + angleAdjLine.x;

    const rotateText = !image?.rotated;

    if (rotateText) {
      ctx.setTransform(cosAngle, sinAngle, -sinAngle, cosAngle, lineLeftAdj, baselineY);
    } else {
      ctx.setTransform(1, 0, 0, 1, lineLeftAdj, baselineY);
    }

    for (const wordObj of lineObj.words) {
      if (!wordObj.text) continue;

      const { fill, opacity } = _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getWordFillOpacity */ .Ay.getWordFillOpacity(wordObj, displayMode, confThreshMed, confThreshHigh);

      ctx.fillStyle = fill;

      const angleAdjWord = wordObj.sup ? _objects_ocrObjects_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.calcWordAngleAdj(wordObj) : { x: 0, y: 0 };

      const wordMetrics = (0,_utils_fontUtils_js__WEBPACK_IMPORTED_MODULE_1__/* .calcWordMetrics */ .jp)(wordObj);
      const advanceArr = wordMetrics.advanceArr;
      const kerningArr = wordMetrics.kerningArr;
      const charSpacing = wordMetrics.charSpacing;
      const wordFontSize = wordMetrics.fontSize;
      const leftSideBearing = wordMetrics.leftSideBearing;

      // TODO: Test whether the math here is correct for drop caps.
      let ts = 0;
      if (wordObj.sup || wordObj.dropcap) {
        ts = (lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y) - (wordObj.bbox.bottom + angleAdjLine.y + angleAdjWord.y);
        if (!wordObj.visualCoords) {
          const font = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.getWordFont(wordObj);
          const fontDesc = font.opentype.descender / font.opentype.unitsPerEm * wordMetrics.fontSize;
          ts -= fontDesc;
        }
      } else {
        ts = 0;
      }

      const width = (wordObj.bbox.left - wordObj.line.bbox.left) / cosAngle;

      const visualLeft = width + angleAdjWord.x;

      const advanceArrTotal = [];
      for (let i = 0; i < advanceArr.length; i++) {
        let leftI = 0;
        leftI += advanceArr[i] || 0;
        leftI += kerningArr[i] || 0;
        leftI += charSpacing || 0;
        advanceArrTotal.push(leftI);
      }

      const font = _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_2__/* .FontCont */ .a4.getWordFont(wordObj);
      ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize}px ${font.fontFaceName}`;
      let leftI = wordObj.visualCoords ? visualLeft - leftSideBearing : visualLeft;
      for (let i = 0; i < wordMetrics.charArr.length; i++) {
        let charI = wordMetrics.charArr[i];

        if (wordObj.smallCaps) {
          if (charI === charI.toUpperCase()) {
            ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize}px ${font.fontFaceName}`;
          } else {
            charI = charI.toUpperCase();
            ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize * font.smallCapsMult}px ${font.fontFaceName}`;
          }
        }

        ctx.fillText(charI, leftI, -ts);
        leftI += advanceArrTotal[i];
      }
    }
  }

  const img = typeof process === 'undefined' ? await canvas.convertToBlob() : await canvas.toDataURL();

  return img;
};

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 2315:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* unused harmony exports recognizeAndConvert, recognizeAndConvert2, recognize */
/* harmony import */ var _import_convertPageAbbyy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6757);
/* harmony import */ var _import_convertPageBlocks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2980);
/* harmony import */ var _import_convertPageHocr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2638);
/* harmony import */ var _import_convertPageStext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1502);
/* harmony import */ var _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3695);
/* harmony import */ var _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2020);
/* harmony import */ var _optimizeFontModule_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9779);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_import_convertPageHocr_js__WEBPACK_IMPORTED_MODULE_2__, _import_convertPageStext_js__WEBPACK_IMPORTED_MODULE_3__, _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__, _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__, _optimizeFontModule_js__WEBPACK_IMPORTED_MODULE_6__]);
([_import_convertPageHocr_js__WEBPACK_IMPORTED_MODULE_2__, _import_convertPageStext_js__WEBPACK_IMPORTED_MODULE_3__, _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__, _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__, _optimizeFontModule_js__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);









const parentPort = typeof process === 'undefined' ? globalThis : (await __webpack_require__.e(/* import() */ 394).then(__webpack_require__.t.bind(__webpack_require__, 8394, 19))).parentPort;
if (!parentPort) throw new Error('This file must be run in a worker');

const Tesseract = typeof process === 'undefined' ? (await __webpack_require__.e(/* import() */ 949).then(__webpack_require__.bind(__webpack_require__, 1949))).default : await __webpack_require__.e(/* import() */ 65).then(__webpack_require__.t.bind(__webpack_require__, 4065, 19));

// TODO: Add back support for multiple PSM modes.
// There is already an advanced option in the UI that claims to switch this, but it currently does nothing.
// tessedit_pageseg_mode: Tesseract.PSM["SINGLE_COLUMN"],

const defaultConfigsVanilla = {
  tessedit_pageseg_mode: Tesseract.PSM.AUTO,
};

const defaultConfigs = {
  tessedit_pageseg_mode: Tesseract.PSM.AUTO,

  // This is virtually always a false positive (usually "I").
  tessedit_char_blacklist: '|',
  // This option disables an undesirable behavior where Tesseract categorizes blobs *of any size* as noise,
  // simply because they are too rectangular.  This option should always be enabled outside of debugging purposes.
  textord_noise_area_ratio: '1',
  // Table detection appears to interfere with the layout analysis of some documents with multi-column layouts,
  // causing columns to be combined into a single line.  This should be investigated in more detail,
  // but disabling as it does not seem to improve results even when the input document is a table.
  textord_tabfind_find_tables: '0',
};

const defaultInitConfigsVanilla = {};

const defaultInitConfigs = {
  // load_system_dawg: '0',
  load_freq_dawg: '0',
  // load_unambig_dawg: '0',
  // load_punc_dawg: '0',
  // load_number_dawg: '0',
  // load_bigram_dawg: '0',
};

let oemCurrent = 2;
let langArrCurrent = ['eng'];

let vanillaMode_ = false;

// Explicitly setting these paths with `URL` is necessary for this to work with Webpack.
// While Tesseract.js users are advised to always point `corePath` to a directory rather than a file,
// pointing to a file should be fined here.
// First, we never want to use the LSTM-only version, as every recognition mode (aside from some fringe advanced options) use the Legacy engine.
// Second, >99% of devices now support the SIMD version, so only using the SIMD version is fine.
let corePath;
if (vanillaMode_) {
  corePath = new URL(/* asset import */ __webpack_require__(8264), __webpack_require__.b).href;
} else {
  corePath = new URL(/* asset import */ __webpack_require__(2848), __webpack_require__.b).href;
}

const workerPath = new URL(/* asset import */ __webpack_require__(2400), __webpack_require__.b).href;

// Custom build is currently only used for browser version, while the Node.js version uses the published npm package.
// If recognition capabilities are ever added for the Node.js version, then we should use the same build for consistency. .
const tessOptions = typeof process === 'undefined' ? {
  corePath,
  workerPath,
  // langPath: '/tess/tessdata_dist',
  legacyCore: true,
  legacyLang: true,
  workerBlobURL: false,
} : { legacyCore: true, legacyLang: true };

/** @type {?Tesseract.Worker} */
let worker;

let workerLegacy;
let workerLSTM;

/**
 * Function to change language, OEM, and vanilla mode.
 * All arguments can be set to `null` to keep the current settings.
 * This function should return early if requested settings match the current settings.
 *
 * @param {Object} param
 * @param {?Array<string>} param.langs
 * @param {?number} param.oem
 * @param {?boolean} param.vanillaMode
 * @param {Object<string, string>} param.config - Config params to pass to to Tesseract.js.
 */
const reinitialize = async ({
  langs, oem, vanillaMode, config,
}) => {
  const langArr = typeof langs === 'string' ? langs.split('+') : langs;
  const changeLang = langs && JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
  // oem can be 0, so using "truthy" checks does not work
  const changeOEM = oem !== null && oem !== undefined && oem !== oemCurrent;
  const changeVanilla = vanillaMode && vanillaMode !== vanillaMode_;

  if (!changeLang && !changeOEM && !changeVanilla && worker) {
    if (config && Object.keys(config).length > 0) {
      await worker.setParameters(config);
    }
    return;
  }
  if (changeLang) langArrCurrent = langArr;
  if (changeOEM) oemCurrent = oem;
  if (changeVanilla) vanillaMode_ = vanillaMode;

  const initConfigs = vanillaMode_ ? structuredClone(defaultInitConfigsVanilla) : structuredClone(defaultInitConfigs);

  const defaultConfigsI = vanillaMode_ ? defaultConfigsVanilla : defaultConfigs;
  for (const [key, value] of Object.entries(defaultConfigsI)) {
    initConfigs[key] = value;
  }

  if (config) {
    for (const [key, value] of Object.entries(config)) {
      initConfigs[key] = value;
    }
  }

  // The worker only needs to be created from scratch if the build of Tesseract being used changes,
  // or if it was never created in the first place.
  if (changeVanilla || !worker) {
    if (vanillaMode_) {
      tessOptions.corePath = new URL(/* asset import */ __webpack_require__(8264), __webpack_require__.b).href;
    } else {
      tessOptions.corePath = new URL(/* asset import */ __webpack_require__(2848), __webpack_require__.b).href;
    }

    if (worker) await worker.terminate();
    worker = await Tesseract.createWorker(langArrCurrent, oemCurrent, tessOptions, initConfigs);
  } else {
    await worker.reinitialize(langArrCurrent, oemCurrent, initConfigs);
  }
};

/**
 * Alternative version of `reinitialize` that uses two workers and allows for parallelizing recognition for the same image.
 * This is experimental and not currently called by anything.
 * Function to change language, OEM, and vanilla mode.
 * All arguments can be set to `null` to keep the current settings.
 * This function should return early if requested settings match the current settings.
 *
 * @param {Object} param
 * @param {?Array<string>} param.langs
 * @param {?number} param.oem
 * @param {?boolean} param.vanillaMode
 */
const reinitialize2 = async ({ langs, vanillaMode }) => {
  const langArr = typeof langs === 'string' ? langs.split('+') : langs;
  const changeLang = langs && JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
  const changeVanilla = vanillaMode && vanillaMode !== vanillaMode_;

  if (!changeLang && !changeVanilla && workerLegacy && workerLSTM) return;
  if (changeLang) langArrCurrent = langArr;
  if (changeVanilla) vanillaMode_ = vanillaMode;

  const initConfigs = vanillaMode_ ? defaultInitConfigsVanilla : defaultInitConfigs;

  // The worker only needs to be created from scratch if the build of Tesseract being used changes,
  // or if it was never created in the first place.
  if (changeVanilla || !workerLegacy || !workerLSTM) {
    if (vanillaMode_) {
      tessOptions.corePath = new URL(/* asset import */ __webpack_require__(8264), __webpack_require__.b).href;
    } else {
      tessOptions.corePath = new URL(/* asset import */ __webpack_require__(2848), __webpack_require__.b).href;
    }

    if (workerLegacy) {
      console.log('terminating legacy');
      await workerLegacy.terminate();
      workerLegacy = null;
    }
    if (workerLSTM) {
      console.log('terminating lstm');
      await workerLSTM.terminate();
      workerLSTM = null;
    }

    workerLegacy = await Tesseract.createWorker(langArrCurrent, 0, tessOptions, initConfigs);
    workerLSTM = await Tesseract.createWorker(langArrCurrent, 1, tessOptions, initConfigs);
  } else if (changeLang) {
    await workerLegacy.reinitialize(langArrCurrent, 0, initConfigs);
    await workerLSTM.reinitialize(langArrCurrent, 1, initConfigs);
  }

  const config = vanillaMode_ ? defaultConfigsVanilla : defaultConfigs;

  await workerLegacy.setParameters(config);
  await workerLSTM.setParameters(config);
};

/**
 * Asynchronously recognizes or processes an image based on specified options and parameters.
 *
 * @param {Object} params -
 * @param {ArrayBuffer} params.image -
 * @param {Object} params.options -
 * @param {Parameters<Tesseract.Worker['recognize']>[2]} params.output
 * @param {number} params.n -
 * @param {dims} params.pageDims - Original (unrotated) dimensions of input image.
 * @param {?number} [params.knownAngle] - The known angle, or `null` if the angle is not known at the time of recognition.
 * @param {?string} [params.engineName] -
 * Exported for type inference purposes, should not be imported anywhere.
 */
const recognizeAndConvert = async ({
  image, options, output, n, knownAngle = null, pageDims,
}) => {
  if (!worker) throw new Error('Worker not initialized');

  const res1 = await worker.recognize(image, options, output);

  const angle = knownAngle === null || knownAngle === undefined ? (res1.data.rotateRadians || 0) * (180 / Math.PI) * -1 : knownAngle;

  const keepItalic = oemCurrent === 0;

  const ocrBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res1.data.blocks);

  const res2 = await (0,_import_convertPageBlocks_js__WEBPACK_IMPORTED_MODULE_1__/* .convertPageBlocks */ .B)({
    ocrBlocks, n, pageDims, rotateAngle: angle, keepItalic,
  });

  return { recognize: res1.data, convert: res2 };
};

/**
 * Asynchronously recognizes or processes an image based on specified options and parameters.
 *
 * @param {Object} params -
 * @param {ArrayBuffer} params.image -
 * @param {Object} params.options -
 * @param {Parameters<Tesseract.Worker['recognize']>[2]} params.output
 * @param {number} params.n -
 * @param {dims} params.pageDims - Original (unrotated) dimensions of input image.
 * @param {?number} [params.knownAngle] - The known angle, or `null` if the angle is not known at the time of recognition.
 * @param {?string} [params.engineName] -
 * Exported for type inference purposes, should not be imported anywhere.
 */
const recognizeAndConvert2 = async ({
  image, options, output, n, pageDims, knownAngle = null,
}, id) => {
  if (!worker && !(workerLegacy && workerLSTM)) throw new Error('Worker not initialized');

  // Disable output formats that are not used.
  // Leaving these enabled can significantly inflate runtimes for no benefit.
  if (!output) output = {};
  output.hocr = false;
  output.tsv = false;
  output.text = false;

  output.debug = false;

  // The function `worker.recognize2` returns 2 promises.
  // If both Legacy and LSTM data are requested, only the second promise will contain the LSTM data.
  // This allows the Legacy data to be used immediately, which halves the amount of delay between user
  // input and something appearing on screen.
  let resArr;
  if (workerLegacy && workerLSTM) {
    if (options.legacy && !options.lstm) {
      const res1Promise = workerLegacy.recognize(image, options, output);
      resArr = [res1Promise];
    } else if (!options.legacy && options.lstm) {
      const res1Promise = workerLSTM.recognize(image, options, output);
      resArr = [res1Promise];
    } else {
      const res1Promise = workerLegacy.recognize(image, options, output);
      const res2Promise = workerLSTM.recognize(image, options, output);
      resArr = [res1Promise, res2Promise];
    }
  } else {
    resArr = await worker.recognize2(image, options, output);
  }

  const res0 = await resArr[0];

  const angle = knownAngle === null || knownAngle === undefined ? (res0.data.rotateRadians || 0) * (180 / Math.PI) * -1 : knownAngle;

  let resLegacy;
  let resLSTM;
  if (options.lstm && options.legacy) {
    const legacyBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res0.data.blocks);
    resLegacy = await (0,_import_convertPageBlocks_js__WEBPACK_IMPORTED_MODULE_1__/* .convertPageBlocks */ .B)({
      ocrBlocks: legacyBlocks, n, pageDims, rotateAngle: angle, keepItalic: true, upscale: res0.data.upscale,
    });
    (async () => {
      const res1 = await resArr[1];

      const lstmBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res1.data.blocks);
      resLSTM = await (0,_import_convertPageBlocks_js__WEBPACK_IMPORTED_MODULE_1__/* .convertPageBlocks */ .B)({
        ocrBlocks: lstmBlocks, n, pageDims, rotateAngle: angle, keepItalic: false, upscale: res0.data.upscale,
      });

      const xB = { recognize: res1.data, convert: { legacy: null, lstm: resLSTM } };

      parentPort.postMessage({ data: xB, id: `${id}b`, status: 'resolve' });
    })();
  } else if (!options.lstm && options.legacy) {
    const legacyBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res0.data.blocks);
    resLegacy = await (0,_import_convertPageBlocks_js__WEBPACK_IMPORTED_MODULE_1__/* .convertPageBlocks */ .B)({
      ocrBlocks: legacyBlocks, n, pageDims, rotateAngle: angle, keepItalic: true, upscale: res0.data.upscale,
    });
  } else if (options.lstm && !options.legacy) {
    const lstmBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res0.data.blocks);
    resLSTM = await (0,_import_convertPageBlocks_js__WEBPACK_IMPORTED_MODULE_1__/* .convertPageBlocks */ .B)({
      ocrBlocks: lstmBlocks, n, pageDims, rotateAngle: angle, keepItalic: false, upscale: res0.data.upscale,
    });
  }

  const x = { recognize: res0.data, convert: { legacy: resLegacy, lstm: resLSTM } };

  parentPort.postMessage({ data: x, id, status: 'resolve' });

  // Both promises must resolve for the scheduler to move on, even if only one OCR engine is being run.
  if (!options.legacy || !options.lstm) parentPort.postMessage({ data: null, id: `${id}b` });
};

/**
 * @template {Partial<Tesseract.OutputFormats>} TO
 * @param {Object} args
 * @param {Parameters<Tesseract.Worker['recognize']>[0]} args.image
 * @param {Parameters<Tesseract.Worker['recognize']>[1]} args.options
 * @param {TO} args.output
 * @returns {Promise<Tesseract.Page<TO>>}
 * Exported for type inference purposes, should not be imported anywhere.
 */
const recognize = async ({ image, options, output }) => {
  if (!worker) throw new Error('Worker not initialized');
  const res1 = await worker.recognize(image, options, output);
  return res1.data;
};

/**
 * Sets font data in `fontAll`.
 * Used to set font data in workers.
 * @param {Object} args
 * @param {Parameters<loadFontsFromSource>[0]} args.src
 * @param {Parameters<loadFontsFromSource>[1]} args.opt
 */
async function loadFontsWorker({ src, opt }) {
  const fonts = await (0,_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .loadFontsFromSource */ .Cs)(src, opt);
  if (opt) {
    if (_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.opt) {
      Object.assign(_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.opt, fonts);
    } else {
      _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.opt = fonts;
    }
  } else if (_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.raw) {
    Object.assign(_containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.raw, fonts);
  } else {
    _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.raw = fonts;
  }
  return true;
}

async function updateFontContWorker({
  rawMetrics, optMetrics, defaultFontName, sansDefaultName, serifDefaultName, enableOpt, forceOpt,
}) {
  if (sansDefaultName) _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.sansDefaultName = sansDefaultName;
  if (serifDefaultName) _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.serifDefaultName = serifDefaultName;
  if (defaultFontName) _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.defaultFontName = defaultFontName;
  if (rawMetrics) _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.rawMetrics = rawMetrics;
  if (optMetrics) _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.optMetrics = optMetrics;
  if (enableOpt === true || enableOpt === false) _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.enableOpt = enableOpt;
  if (forceOpt === true || forceOpt === false) _containers_fontContainer_js__WEBPACK_IMPORTED_MODULE_4__/* .FontCont */ .a4.forceOpt = forceOpt;
}

async function compareOCRPageImpWrap(args) {
  args.options.tessWorker = worker;
  return await (0,_compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__/* .compareOCRPageImp */ .$S)(args);
}

const handleMessage = async (data) => {
  const func = data[0];
  const args = data[1];
  const id = data[2];

  if (func === 'recognizeAndConvert2') {
    recognizeAndConvert2(args, id);
    return;
  }

  ({
    // Convert page functions
    convertPageAbbyy: _import_convertPageAbbyy_js__WEBPACK_IMPORTED_MODULE_0__/* .convertPageAbbyy */ .U,
    convertPageHocr: _import_convertPageHocr_js__WEBPACK_IMPORTED_MODULE_2__/* .convertPageHocr */ .p,
    convertPageStext: _import_convertPageStext_js__WEBPACK_IMPORTED_MODULE_3__/* .convertPageStext */ .T,
    convertPageBlocks: _import_convertPageBlocks_js__WEBPACK_IMPORTED_MODULE_1__/* .convertPageBlocks */ .B,

    // Optimize font functions
    optimizeFont: _optimizeFontModule_js__WEBPACK_IMPORTED_MODULE_6__/* .optimizeFont */ .X,

    // OCR comparison/evaluation functions
    evalPageFont: _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__/* .evalPageFont */ .Fg,
    evalPageBase: _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__/* .evalPageBase */ .LD,
    evalWords: _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__/* .evalWords */ .Y1,
    compareOCRPageImp: compareOCRPageImpWrap,
    nudgePageFontSize: _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__/* .nudgePageFontSize */ .Zz,
    nudgePageBaseline: _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__/* .nudgePageBaseline */ .QR,
    renderPageStaticImp: _compareOCRModule_js__WEBPACK_IMPORTED_MODULE_5__/* .renderPageStaticImp */ .s_,

    // Recognition
    reinitialize,
    reinitialize2,
    recognize,
    recognizeAndConvert,

    // Change state of worker
    loadFontsWorker,
    updateFontContWorker,
  })[func](args)
    .then((x) => parentPort.postMessage({ data: x, id, status: 'resolve' }))
    .catch((err) => parentPort.postMessage({ data: err, id, status: 'reject' }));
};

if (typeof process === 'undefined') {
  onmessage = (event) => handleMessage(event.data);
} else {
  parentPort.on('message', handleMessage);
}

parentPort.postMessage({ data: 'ready', id: 0, status: 'resolve' });

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 9779:
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ optimizeFont)
/* harmony export */ });
/* harmony import */ var _utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2961);
/* harmony import */ var _lib_opentype_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8742);




// Defining "window" is needed due to bad browser/node detection in Opentype.js
// Can hopefully remove in future version
if (typeof process === 'object') {
  // @ts-ignore
  globalThis.self = globalThis;
  // @ts-ignore
  const { createRequire } = await __webpack_require__.e(/* import() */ 830).then(__webpack_require__.t.bind(__webpack_require__, 6830, 19));
  globalThis.require = createRequire("file:///Users/aswinck/Documents/01022025/scribe.js/js/worker/optimizeFontModule.js");
  const { fileURLToPath } = await Promise.all(/* import() */[__webpack_require__.e(835), __webpack_require__.e(634)]).then(__webpack_require__.t.bind(__webpack_require__, 8835, 19));
  const { dirname } = await __webpack_require__.e(/* import() */ 975).then(__webpack_require__.t.bind(__webpack_require__, 7975, 19));
  globalThis.__dirname = dirname(fileURLToPath("file:///Users/aswinck/Documents/01022025/scribe.js/js/worker/optimizeFontModule.js"));
} else if (globalThis.window === undefined) {
  globalThis.window = {};
}

/**
 * Rounds a number to six decimal places.
 * @param {number} x - The number to be rounded.
 * @returns {number} The rounded number.
 */
function round6(x) {
  return (Math.round(x * 1e6) / 1e6);
}

/**
 * Function that transforms a single numeric input.
 * @callback transformFunc
 * @param {number} x - Numeric input
 */

/**
 * Apply function to all points on glyph.
 * @param {opentype.Glyph} glyph
 * @param {transformFunc} func
 * @param {boolean} transX - Transform x coordinates
 * @param {boolean} transY - Transform y coordinates
 */
function transformGlyph(glyph, func, transX = false, transY = false) {
  // All values are rounded to the nearest integer.
  // All TrueType coordinates must be integers, and while PostScript fonts do not technically need to be integers,
  // non-integers tend to cause issues in real-world use.
  const funcRound = (x) => Math.round(func(x));

  for (let j = 0; j < glyph.path.commands.length; j++) {
    const pointJ = glyph.path.commands[j];

    if (pointJ.type === 'M' || pointJ.type === 'L' || pointJ.type === 'C' || pointJ.type === 'Q') {
      if (transX) pointJ.x = funcRound(pointJ.x);
      if (transY) pointJ.y = funcRound(pointJ.y);
      if (pointJ.type === 'C' || pointJ.type === 'Q') {
        if (transX) pointJ.x1 = funcRound(pointJ.x1);
        if (transY) pointJ.y1 = funcRound(pointJ.y1);
        if (pointJ.type === 'C') {
          if (transX) pointJ.x2 = funcRound(pointJ.x2);
          if (transY) pointJ.y2 = funcRound(pointJ.y2);
        }
      }
    }
  }

  if (transX) {
    // leftSideBearing is not automatically updated by glyphIMetrics
    const glyphMetrics = glyph.getMetrics();
    glyph.leftSideBearing = glyphMetrics.xMin;

    // Apply function to advanceWidth
    glyph.advanceWidth = funcRound(glyph.advanceWidth);
  }
}

/**
 * Calculate pair kerning adjustments for font given provided metrics.
 *
 * @param {opentype.Font} font
 * @param {FontMetricsFont} fontMetricsObj
 * @param {number} xHeight
 * @param {string} style
 */
const calculateKerningPairs = (font, fontMetricsObj, xHeight, style) => {
  const fontKerningObj = {};

  // Kerning is limited to +/-10% of the em size for most pairs.  Anything beyond this is likely not correct.
  const maxKern = Math.round(font.unitsPerEm * 0.1);
  const minKern = maxKern * -1;

  for (const [key, value] of Object.entries(fontMetricsObj.kerning)) {
    // Do not adjust pair kerning for italic "ff".
    // Given the amount of overlap between these glyphs, this metric is rarely accurate.
    if (key === '102,102' && style === 'italic') continue;

    const nameFirst = key.match(/\w+/)[0];
    const nameSecond = key.match(/\w+$/)[0];

    const charFirst = String.fromCharCode(parseInt(nameFirst));
    const charSecond = String.fromCharCode(parseInt(nameSecond));

    const indexFirst = font.charToGlyphIndex(charFirst);
    const indexSecond = font.charToGlyphIndex(charSecond);

    const glyphFirst = font.glyphs.glyphs[indexFirst];
    const glyphSecond = font.glyphs.glyphs[indexSecond];

    const metricsFirst = glyphFirst.getMetrics();
    const metricsSecond = glyphSecond.getMetrics();

    const fontKern1 = Math.round(value * xHeight);
    let spaceTarget = fontKern1;

    // Calculate target (measured) space between two characters.
    // This is calculated as the average between two measurements.
    // This did not exist in an older version of the code, so this should be optional and skipped if the data is not present.
    if (fontMetricsObj.kerning2) {
      const value2 = fontMetricsObj.kerning2[key];
      if (value2) {
        const fontKern2 = Math.round(value2 * xHeight);
        spaceTarget = Math.round((fontKern1 + fontKern2) / 2);
      }
    }

    // Calculate current space between these 2 glyphs (without kerning adjustments)
    const spaceCurrent = (glyphFirst.advanceWidth - metricsFirst.xMax) + metricsSecond.xMin;

    // Calculate kerning adjustment needed
    let fontKern = spaceTarget - spaceCurrent;

    // For smart quotes, the maximum amount of kerning space allowed is doubled.
    // Unlike letters, some text will legitimately have a large space before/after curly quotes.
    // TODO: Handle quotes in a more systematic way (setting advance for quotes, or kerning for all letters,
    // rather than relying on each individual pairing.)
    if (['8220', '8216'].includes(nameFirst) || ['8221', '8217'].includes(nameSecond)) {
      fontKern = Math.min(Math.max(fontKern, minKern), maxKern * 2);

      // For pairs that commonly use ligatures ("ff", "fi", "fl") allow lower minimum
    } else if (['102,102', '102,105', '102,108'].includes(key)) {
      fontKern = Math.min(Math.max(fontKern, Math.round(minKern * 1.5)), maxKern);
    } else {
      fontKern = Math.min(Math.max(fontKern, minKern), maxKern);
    }

    fontKerningObj[`${indexFirst},${indexSecond}`] = fontKern;
  }

  return fontKerningObj;
};

/**
 * Creates optimized version of font based on metrics provided.
 * @param {Object} params
 * @param {string|ArrayBuffer} params.fontData
 * @param {FontMetricsFont} params.fontMetricsObj
 * @param {string} params.style -
 * @param {boolean} [params.adjustAllLeftBearings] - Edit left bearings for all characters based on provided metrics.
 * @param {boolean} [params.standardizeSize] - Scale such that size of 'o' is 0.47x em size.
 * @param {?number} [params.targetEmSize] - If non-null, font is scaled to this em size.
 * @param {boolean} [params.transGlyphs] - Whether individual glyphs should be transformed based on provided metrics.
 *    If `false`, only font-level transformations (adjusting em size and standardizing 'o' height) are performed.
 */
async function optimizeFont({
  fontData, fontMetricsObj, style, adjustAllLeftBearings = false, standardizeSize = false, targetEmSize = null, transGlyphs = true,
}) {
  /** @type {opentype.Font} */
  const workingFont = typeof (fontData) === 'string' ? await _lib_opentype_module_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].load */ .Ay.load(fontData) : _lib_opentype_module_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].parse */ .Ay.parse(fontData, { lowMemory: false });

  // let workingFont;
  // if (typeof (fontData) == "string") {
  //   workingFont = await opentype.load(fontData);
  // } else {
  //   workingFont = opentype.parse(fontData, { lowMemory: false });
  // }

  // Remove GSUB table (in most Latin fonts this table is responsible for ligatures, if it is used at all).
  // The presence of ligatures (such as ﬁ and ﬂ) is not properly accounted for when setting character metrics.
  workingFont.tables.gsub = null;

  // Scale font to standardize x-height
  // TODO: Make this optional or move to a separate script so the default fonts can be pre-scaled.
  const xHeightStandard = 0.47 * workingFont.unitsPerEm;
  let oGlyph = workingFont.charToGlyph('o').getMetrics();
  let xHeight = oGlyph.yMax - oGlyph.yMin;
  const xHeightScale = xHeightStandard / xHeight;
  const scaleGlyph = (x) => x * xHeightScale;
  if (Math.abs(1 - xHeightScale) > 0.01) {
    if (standardizeSize) {
      for (const [key, value] of Object.entries(workingFont.glyphs.glyphs)) {
        transformGlyph(value, scaleGlyph, true, true);
      }
    } else {
      console.log("Font is not standard size ('o' 0.47x em size).  Either standardize the font ahead of time or enable `standardizeSize = true` to standardize on the fly.");
    }
  }

  if (targetEmSize && targetEmSize !== workingFont.unitsPerEm) {
    for (const [key, value] of Object.entries(workingFont.glyphs.glyphs)) {
      transformGlyph(value, (x) => x * (targetEmSize / workingFont.unitsPerEm), true, true);
    }
    workingFont.unitsPerEm = targetEmSize;
  }

  // If no glyph-level transformations are requested, return early.
  if (!transGlyphs) {
    workingFont.kerningPairs = calculateKerningPairs(workingFont, fontMetricsObj, xHeight, style);

    return { fontData: workingFont.toArrayBuffer(), kerningPairs: workingFont.kerningPairs };
  }

  oGlyph = workingFont.charToGlyph('o').getMetrics();
  xHeight = oGlyph.yMax - oGlyph.yMin;

  const heightCapsBelievable = fontMetricsObj.obsCaps >= 10 && fontMetricsObj.heightCaps >= 1.1 && fontMetricsObj.heightCaps < 2;

  const fontAscHeight = workingFont.charToGlyph('A').getMetrics().yMax;

  // Define various character classes
  const lower = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];

  const singleStemClassA = ['i', 'l', 't', 'I'];
  const singleStemClassB = ['f', 'i', 'j', 'l', 't', 'I', 'J', 'T'];

  // const workingFontRightBearingMedian = quantile(lower.map(x => workingFont.charToGlyph(x).getMetrics().rightSideBearing), 0.5);
  // console.log("workingFontRightBearingMedian: " + workingFontRightBearingMedian);

  // Adjust character width and advance
  for (const [key, value] of Object.entries(fontMetricsObj.width)) {
    // 33 is the first latin glyph (excluding space which is 32)
    if (parseInt(key) < 33) { continue; }

    const charLit = String.fromCharCode(parseInt(key));

    // Some glyphs do not benefit from recalculating statistics, as they are commonly misidentified
    if (['.'].includes(charLit)) { continue; }

    const glyphI = workingFont.charToGlyph(charLit);

    if (glyphI.name === '.notdef' || glyphI.name === 'NULL') continue;

    let glyphIMetrics = glyphI.getMetrics();
    const glyphIWidth = glyphIMetrics.xMax - glyphIMetrics.xMin;

    let scaleXFactor = (value * xHeight) / glyphIWidth;

    // TODO: For simplicitly we assume the stem is located at the midpoint of the bounding box (0.35 for "f")
    // This is not always true (for example, "t" in Libre Baskerville).
    // Look into whether there is a low(ish) effort way of finding the visual center for real.

    const glyphICenterPoint = charLit === 'f' ? 0.35 : 0.5;

    const glyphICenter = Math.max(glyphIMetrics.xMin, 0) + Math.round(glyphIWidth * glyphICenterPoint);
    const glyphIWidthQuarter = Math.round(glyphIWidth / 4);

    // Horizontal scaling is limited for certain letters with a single vertical stem.
    // This is because the bounding box for these letters is almost entirely established by the stylistic flourish.
    if (singleStemClassA.includes(charLit)) {
      scaleXFactor = Math.max(Math.min(scaleXFactor, 1.1), 0.9);
      // Some fonts have significantly wider double quotes compared to the default style, so more variation is allowed
    } else if (['“', '”'].includes(charLit)) {
      scaleXFactor = Math.max(Math.min(scaleXFactor, 1.5), 0.7);
    } else {
      scaleXFactor = Math.max(Math.min(scaleXFactor, 1.3), 0.7);
    }

    const scaleH1 = (x) => Math.round((x - glyphICenter) * scaleXFactor) + glyphICenter;
    const scaleH2 = (x) => Math.round(x * scaleXFactor);

    if (singleStemClassB.includes(charLit) && style !== 'italic') {
      transformGlyph(glyphI, scaleH1, true, false);
    } else {
      transformGlyph(glyphI, scaleH2, true, false);
    }

    glyphIMetrics = glyphI.getMetrics();
    // leftSideBearing is not automatically updated by glyphIMetrics
    glyphI.leftSideBearing = glyphIMetrics.xMin;

    // Edit left bearings.
    // This must be done after any horizontal scaling for the calculations to be correct.
    // Left bearings are currently only changed for specific punctuation characters (overall scaling aside)
    let shiftX = 0;
    if ([';', ':', '‘', '’', '“', '”', '"'].includes(charLit) || adjustAllLeftBearings) {
      const leftBearingCorrect = 0;
      // xMin is automatically updated by getMetrics, leftSideBearing is not
      const leftBearingAct = glyphIMetrics.xMin;
      if (Number.isFinite(leftBearingCorrect) && leftBearingAct !== undefined) {
        shiftX = leftBearingCorrect - leftBearingAct;

        // Reset shiftX to 0 if resulting advance would be very small or negative
        if (shiftX + glyphI.advanceWidth < workingFont.unitsPerEm * 0.05) {
          shiftX = 0;
        }
      }
    }

    if (shiftX !== 0) {
      const shiftH = (x) => x + shiftX;
      transformGlyph(glyphI, shiftH, true, false);
      glyphIMetrics = glyphI.getMetrics();
    }

    // leftSideBearing is not automatically updated by glyphIMetrics
    glyphI.leftSideBearing = glyphIMetrics.xMin;
  }

  // Adjust height for capital letters (if heightCaps is believable)
  if (heightCapsBelievable) {
    const capsMult = xHeight * fontMetricsObj.heightCaps / fontAscHeight;
    for (const key of [...Array(26).keys()].map((x) => x + 65)) {
      const charLit = String.fromCharCode(key);

      const glyphI = workingFont.charToGlyph(charLit);

      const scaleCaps = (x) => x * capsMult;

      transformGlyph(glyphI, scaleCaps, false, true);
    }
  }

  // This purposefully does not include numbers, as those are normalized differently.
  const upperAsc = ['A', 'B', 'D', 'E', 'F', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
  const upperAscCodes = upperAsc.map((x) => String(x.charCodeAt(0)));
  const charHeightKeys = Object.keys(fontMetricsObj.height);
  const heightAscArr = Object.values(fontMetricsObj.height).filter((element, index) => upperAscCodes.includes(charHeightKeys[index]));

  // At least 10 observations are required to adjust from the default.
  if (heightAscArr.length >= 10) {
    const heightAscMedian0 = (0,_utils_miscUtils_js__WEBPACK_IMPORTED_MODULE_0__/* .quantile */ .YV)(heightAscArr, 0.5);
    if (heightAscMedian0) {
      const charHeightA = round6(heightAscMedian0);

      // TODO: Extend similar logic to apply to other descenders such as "p" and "q"
      // Adjust height of capital J (which often has a height greater than other capital letters)
      // All height from "J" above that of "A" is assumed to occur under the baseline
      const actJMult = Math.max(round6(fontMetricsObj.height[74]) / charHeightA, 0);
      const fontJMetrics = workingFont.charToGlyph('J').getMetrics();
      const fontAMetrics = workingFont.charToGlyph('A').getMetrics();
      const fontJMult = Math.max((fontJMetrics.yMax - fontJMetrics.yMin) / (fontAMetrics.yMax - fontAMetrics.yMin), 1);
      const actFontJMult = actJMult / fontJMult;

      if (Math.abs(1 - actFontJMult) > 0.02) {
        const glyphI = workingFont.charToGlyph('J');
        const glyphIMetrics = glyphI.getMetrics();
        const yAdj = Math.round(glyphIMetrics.yMax - (glyphIMetrics.yMax * actFontJMult));

        const transDescFunc = (x) => Math.round(x * actFontJMult + yAdj);

        transformGlyph(glyphI, transDescFunc, false, true);
      }
    }
  }

  // Adjust height of descenders
  // All height from "p" or "q" above that of "a" is assumed to occur under the baseline
  const descAdjArr = ['g', 'p', 'q'];
  const fontAMetrics = workingFont.charToGlyph('a').getMetrics();
  const minA = fontAMetrics.yMin;
  for (let i = 0; i < descAdjArr.length; i++) {
    const charI = descAdjArr[i];
    const charICode = charI.charCodeAt(0);
    const actMult = Math.max(fontMetricsObj.height[charICode] / fontMetricsObj.height[97], 0);
    const metrics = workingFont.charToGlyph(charI).getMetrics();
    const fontMult = (metrics.yMax - metrics.yMin) / (fontAMetrics.yMax - fontAMetrics.yMin);
    const actFontMult = actMult / fontMult;
    const glyphHeight = metrics.yMax - metrics.yMin;
    const glyphLowerStemHeight = minA - metrics.yMin;
    const scaleYFactor = ((actFontMult - 1) * (glyphHeight / glyphLowerStemHeight)) + 1;

    const scaleYFunc = (x) => Math.round((x - minA) * scaleYFactor);

    if (Math.abs(actFontMult) > 1.02) {
      const glyphI = workingFont.charToGlyph(charI);

      // Adjust scaling factor to account for the fact that only the lower part of the stem is adjusted

      // Note: This cannot be replaced with a call to `transformGlyph`, as this code only transforms certain glyphs.

      for (let j = 0; j < glyphI.path.commands.length; j++) {
        const pointJ = glyphI.path.commands[j];

        if (pointJ.type === 'M' || pointJ.type === 'L' || pointJ.type === 'C' || pointJ.type === 'Q') {
          if (pointJ.y < minA) pointJ.y = Math.round((pointJ.y - minA) * scaleYFactor);
          if (pointJ.type === 'C' || pointJ.type === 'Q') {
            if (pointJ.y1 < minA) pointJ.y1 = Math.round((pointJ.y1 - minA) * scaleYFactor);
            if (pointJ.type === 'C') {
              if (pointJ.y2 < minA) pointJ.y2 = Math.round((pointJ.y2 - minA) * scaleYFactor);
            }
          }
        }
      }
    }
  }

  workingFont.kerningPairs = calculateKerningPairs(workingFont, fontMetricsObj, xHeight, style);

  // Append suffix to avoid naming conflict with raw font.
  // This is necessary for the Node.js version due to quirks with node-canvas.
  workingFont.tables.name.postScriptName.en = `${workingFont.tables.name.postScriptName.en.replaceAll(/\s+/g, '')}-Opt`;

  return { fontData: workingFont.toArrayBuffer(), kerningPairs: workingFont.kerningPairs };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 8742:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ An)
/* harmony export */ });
/* unused harmony exports BoundingBox, Font, Glyph, Path, _parse, load, loadSync, parse */
/*! https://mths.be/codepointat v0.2.0 by @mathias */
var e,t;String.prototype.codePointAt||(e=function(){try{var e={},t=Object.defineProperty,r=t(e,e,e)&&t}catch(e){}return r}(),t=function(e){if(null==this)throw TypeError();var t=String(this),r=t.length,n=e?Number(e):0;if(n!=n&&(n=0),!(n<0||n>=r)){var a,o=t.charCodeAt(n);return o>=55296&&o<=56319&&r>n+1&&(a=t.charCodeAt(n+1))>=56320&&a<=57343?1024*(o-55296)+a-56320+65536:o}},e?e(String.prototype,"codePointAt",{value:t,configurable:!0,writable:!0}):String.prototype.codePointAt=t);var r=0,n=-3;function a(){this.table=new Uint16Array(16),this.trans=new Uint16Array(288)}function o(e,t){this.source=e,this.sourceIndex=0,this.tag=0,this.bitcount=0,this.dest=t,this.destLen=0,this.ltree=new a,this.dtree=new a}var s=new a,i=new a,u=new Uint8Array(30),l=new Uint16Array(30),p=new Uint8Array(30),c=new Uint16Array(30),h=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=new a,d=new Uint8Array(320);function v(e,t,r,n){var a,o;for(a=0;a<r;++a)e[a]=0;for(a=0;a<30-r;++a)e[a+r]=a/r|0;for(o=n,a=0;a<30;++a)t[a]=o,o+=1<<e[a]}var g=new Uint16Array(16);function m(e,t,r,n){var a,o;for(a=0;a<16;++a)e.table[a]=0;for(a=0;a<n;++a)e.table[t[r+a]]++;for(e.table[0]=0,o=0,a=0;a<16;++a)g[a]=o,o+=e.table[a];for(a=0;a<n;++a)t[r+a]&&(e.trans[g[t[r+a]]++]=a)}function y(e){e.bitcount--||(e.tag=e.source[e.sourceIndex++],e.bitcount=7);var t=1&e.tag;return e.tag>>>=1,t}function b(e,t,r){if(!t)return r;for(;e.bitcount<24;)e.tag|=e.source[e.sourceIndex++]<<e.bitcount,e.bitcount+=8;var n=e.tag&65535>>>16-t;return e.tag>>>=t,e.bitcount-=t,n+r}function S(e,t){for(;e.bitcount<24;)e.tag|=e.source[e.sourceIndex++]<<e.bitcount,e.bitcount+=8;var r=0,n=0,a=0,o=e.tag;do{n=2*n+(1&o),o>>>=1,++a,r+=t.table[a],n-=t.table[a]}while(n>=0);return e.tag=o,e.bitcount-=a,t.trans[r+n]}function x(e,t,r){var n,a,o,s,i,u;for(n=b(e,5,257),a=b(e,5,1),o=b(e,4,4),s=0;s<19;++s)d[s]=0;for(s=0;s<o;++s){var l=b(e,3,0);d[h[s]]=l}for(m(f,d,0,19),i=0;i<n+a;){var p=S(e,f);switch(p){case 16:var c=d[i-1];for(u=b(e,2,3);u;--u)d[i++]=c;break;case 17:for(u=b(e,3,3);u;--u)d[i++]=0;break;case 18:for(u=b(e,7,11);u;--u)d[i++]=0;break;default:d[i++]=p}}m(t,d,0,n),m(r,d,n,a)}function T(e,t,n){for(;;){var a,o,s,i,h=S(e,t);if(256===h)return r;if(h<256)e.dest[e.destLen++]=h;else for(a=b(e,u[h-=257],l[h]),o=S(e,n),i=s=e.destLen-b(e,p[o],c[o]);i<s+a;++i)e.dest[e.destLen++]=e.dest[i]}}function U(e){for(var t,a;e.bitcount>8;)e.sourceIndex--,e.bitcount-=8;if((t=256*(t=e.source[e.sourceIndex+1])+e.source[e.sourceIndex])!==(65535&~(256*e.source[e.sourceIndex+3]+e.source[e.sourceIndex+2])))return n;for(e.sourceIndex+=4,a=t;a;--a)e.dest[e.destLen++]=e.source[e.sourceIndex++];return e.bitcount=0,r}!function(e,t){var r;for(r=0;r<7;++r)e.table[r]=0;for(e.table[7]=24,e.table[8]=152,e.table[9]=112,r=0;r<24;++r)e.trans[r]=256+r;for(r=0;r<144;++r)e.trans[24+r]=r;for(r=0;r<8;++r)e.trans[168+r]=280+r;for(r=0;r<112;++r)e.trans[176+r]=144+r;for(r=0;r<5;++r)t.table[r]=0;for(t.table[5]=32,r=0;r<32;++r)t.trans[r]=r}(s,i),v(u,l,4,3),v(p,c,2,1),u[28]=0,l[28]=258;var k=function(e,t){var a,u,l=new o(e,t);do{switch(a=y(l),b(l,2,0)){case 0:u=U(l);break;case 1:u=T(l,s,i);break;case 2:x(l,l.ltree,l.dtree),u=T(l,l.ltree,l.dtree);break;default:u=n}if(u!==r)throw new Error("Data error")}while(!a);return l.destLen<l.dest.length?"function"==typeof l.dest.slice?l.dest.slice(0,l.destLen):l.dest.subarray(0,l.destLen):l.dest};function O(e,t,r,n,a){return Math.pow(1-a,3)*e+3*Math.pow(1-a,2)*a*t+3*(1-a)*Math.pow(a,2)*r+Math.pow(a,3)*n}function R(){this.x1=Number.NaN,this.y1=Number.NaN,this.x2=Number.NaN,this.y2=Number.NaN}function E(){this.commands=[],this.fill="black",this.stroke=null,this.strokeWidth=1}function L(e){throw new Error(e)}function C(e,t){e||L(t)}R.prototype.isEmpty=function(){return isNaN(this.x1)||isNaN(this.y1)||isNaN(this.x2)||isNaN(this.y2)},R.prototype.addPoint=function(e,t){"number"==typeof e&&((isNaN(this.x1)||isNaN(this.x2))&&(this.x1=e,this.x2=e),e<this.x1&&(this.x1=e),e>this.x2&&(this.x2=e)),"number"==typeof t&&((isNaN(this.y1)||isNaN(this.y2))&&(this.y1=t,this.y2=t),t<this.y1&&(this.y1=t),t>this.y2&&(this.y2=t))},R.prototype.addX=function(e){this.addPoint(e,null)},R.prototype.addY=function(e){this.addPoint(null,e)},R.prototype.addBezier=function(e,t,r,n,a,o,s,i){var u=[e,t],l=[r,n],p=[a,o],c=[s,i];this.addPoint(e,t),this.addPoint(s,i);for(var h=0;h<=1;h++){var f=6*u[h]-12*l[h]+6*p[h],d=-3*u[h]+9*l[h]-9*p[h]+3*c[h],v=3*l[h]-3*u[h];if(0!==d){var g=Math.pow(f,2)-4*v*d;if(!(g<0)){var m=(-f+Math.sqrt(g))/(2*d);0<m&&m<1&&(0===h&&this.addX(O(u[h],l[h],p[h],c[h],m)),1===h&&this.addY(O(u[h],l[h],p[h],c[h],m)));var y=(-f-Math.sqrt(g))/(2*d);0<y&&y<1&&(0===h&&this.addX(O(u[h],l[h],p[h],c[h],y)),1===h&&this.addY(O(u[h],l[h],p[h],c[h],y)))}}else{if(0===f)continue;var b=-v/f;0<b&&b<1&&(0===h&&this.addX(O(u[h],l[h],p[h],c[h],b)),1===h&&this.addY(O(u[h],l[h],p[h],c[h],b)))}}},R.prototype.addQuad=function(e,t,r,n,a,o){var s=e+2/3*(r-e),i=t+2/3*(n-t),u=s+1/3*(a-e),l=i+1/3*(o-t);this.addBezier(e,t,s,i,u,l,a,o)},E.prototype.moveTo=function(e,t){this.commands.push({type:"M",x:e,y:t})},E.prototype.lineTo=function(e,t){this.commands.push({type:"L",x:e,y:t})},E.prototype.curveTo=E.prototype.bezierCurveTo=function(e,t,r,n,a,o){this.commands.push({type:"C",x1:e,y1:t,x2:r,y2:n,x:a,y:o})},E.prototype.quadTo=E.prototype.quadraticCurveTo=function(e,t,r,n){this.commands.push({type:"Q",x1:e,y1:t,x:r,y:n})},E.prototype.close=E.prototype.closePath=function(){this.commands.push({type:"Z"})},E.prototype.extend=function(e){if(e.commands)e=e.commands;else if(e instanceof R){var t=e;return this.moveTo(t.x1,t.y1),this.lineTo(t.x2,t.y1),this.lineTo(t.x2,t.y2),this.lineTo(t.x1,t.y2),void this.close()}Array.prototype.push.apply(this.commands,e)},E.prototype.getBoundingBox=function(){for(var e=new R,t=0,r=0,n=0,a=0,o=0;o<this.commands.length;o++){var s=this.commands[o];switch(s.type){case"M":e.addPoint(s.x,s.y),t=n=s.x,r=a=s.y;break;case"L":e.addPoint(s.x,s.y),n=s.x,a=s.y;break;case"Q":e.addQuad(n,a,s.x1,s.y1,s.x,s.y),n=s.x,a=s.y;break;case"C":e.addBezier(n,a,s.x1,s.y1,s.x2,s.y2,s.x,s.y),n=s.x,a=s.y;break;case"Z":n=t,a=r;break;default:throw new Error("Unexpected path command "+s.type)}}return e.isEmpty()&&e.addPoint(0,0),e},E.prototype.draw=function(e){e.beginPath();for(var t=0;t<this.commands.length;t+=1){var r=this.commands[t];"M"===r.type?e.moveTo(r.x,r.y):"L"===r.type?e.lineTo(r.x,r.y):"C"===r.type?e.bezierCurveTo(r.x1,r.y1,r.x2,r.y2,r.x,r.y):"Q"===r.type?e.quadraticCurveTo(r.x1,r.y1,r.x,r.y):"Z"===r.type&&e.closePath()}this.fill&&(e.fillStyle=this.fill,e.fill()),this.stroke&&(e.strokeStyle=this.stroke,e.lineWidth=this.strokeWidth,e.stroke())},E.prototype.toPathData=function(e){function t(t){return Math.round(t)===t?""+Math.round(t):t.toFixed(e)}function r(){for(var e=arguments,r="",n=0;n<arguments.length;n+=1){var a=e[n];a>=0&&n>0&&(r+=" "),r+=t(a)}return r}e=void 0!==e?e:2;for(var n="",a=0;a<this.commands.length;a+=1){var o=this.commands[a];"M"===o.type?n+="M"+r(o.x,o.y):"L"===o.type?n+="L"+r(o.x,o.y):"C"===o.type?n+="C"+r(o.x1,o.y1,o.x2,o.y2,o.x,o.y):"Q"===o.type?n+="Q"+r(o.x1,o.y1,o.x,o.y):"Z"===o.type&&(n+="Z")}return n},E.prototype.toSVG=function(e){var t='<path d="';return t+=this.toPathData(e),t+='"',this.fill&&"black"!==this.fill&&(null===this.fill?t+=' fill="none"':t+=' fill="'+this.fill+'"'),this.stroke&&(t+=' stroke="'+this.stroke+'" stroke-width="'+this.strokeWidth+'"'),t+="/>"},E.prototype.toDOMElement=function(e){var t=this.toPathData(e),r=document.createElementNS("http://www.w3.org/2000/svg","path");return r.setAttribute("d",t),r};var w={fail:L,argument:C,assert:C},D=2147483648,I={},G={},M={};function B(e){return function(){return e}}G.BYTE=function(e){return w.argument(e>=0&&e<=255,"Byte value should be between 0 and 255."),[e]},M.BYTE=B(1),G.CHAR=function(e){return[e.charCodeAt(0)]},M.CHAR=B(1),G.CHARARRAY=function(e){void 0===e&&(e="",console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name."));for(var t=[],r=0;r<e.length;r+=1)t[r]=e.charCodeAt(r);return t},M.CHARARRAY=function(e){return void 0===e?0:e.length},G.USHORT=function(e){return[e>>8&255,255&e]},M.USHORT=B(2),G.SHORT=function(e){return e>=32768&&(e=-(65536-e)),[e>>8&255,255&e]},M.SHORT=B(2),G.UINT24=function(e){return[e>>16&255,e>>8&255,255&e]},M.UINT24=B(3),G.ULONG=function(e){return[e>>24&255,e>>16&255,e>>8&255,255&e]},M.ULONG=B(4),G.LONG=function(e){return e>=D&&(e=-(2*D-e)),[e>>24&255,e>>16&255,e>>8&255,255&e]},M.LONG=B(4),G.FIXED=G.ULONG,M.FIXED=M.ULONG,G.FWORD=G.SHORT,M.FWORD=M.SHORT,G.UFWORD=G.USHORT,M.UFWORD=M.USHORT,G.LONGDATETIME=function(e){return[0,0,0,0,e>>24&255,e>>16&255,e>>8&255,255&e]},M.LONGDATETIME=B(8),G.TAG=function(e){return w.argument(4===e.length,"Tag should be exactly 4 ASCII characters."),[e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]},M.TAG=B(4),G.Card8=G.BYTE,M.Card8=M.BYTE,G.Card16=G.USHORT,M.Card16=M.USHORT,G.OffSize=G.BYTE,M.OffSize=M.BYTE,G.SID=G.USHORT,M.SID=M.USHORT,G.NUMBER=function(e){return e>=-107&&e<=107?[e+139]:e>=108&&e<=1131?[247+((e-=108)>>8),255&e]:e>=-1131&&e<=-108?[251+((e=-e-108)>>8),255&e]:e>=-32768&&e<=32767?G.NUMBER16(e):G.NUMBER32(e)},M.NUMBER=function(e){return G.NUMBER(e).length},G.NUMBER16=function(e){return[28,e>>8&255,255&e]},M.NUMBER16=B(3),G.NUMBER32=function(e){return[29,e>>24&255,e>>16&255,e>>8&255,255&e]},M.NUMBER32=B(5),G.REAL=function(e){var t=e.toString(),r=/\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t);if(r){var n=parseFloat("1e"+((r[2]?+r[2]:0)+r[1].length));t=(Math.round(e*n)/n).toString()}for(var a="",o=0,s=t.length;o<s;o+=1){var i=t[o];a+="e"===i?"-"===t[++o]?"c":"b":"."===i?"a":"-"===i?"e":i}for(var u=[30],l=0,p=(a+=1&a.length?"f":"ff").length;l<p;l+=2)u.push(parseInt(a.substr(l,2),16));return u},M.REAL=function(e){return G.REAL(e).length},G.NAME=G.CHARARRAY,M.NAME=M.CHARARRAY,G.STRING=G.CHARARRAY,M.STRING=M.CHARARRAY,I.UTF8=function(e,t,r){for(var n=[],a=r,o=0;o<a;o++,t+=1)n[o]=e.getUint8(t);return String.fromCharCode.apply(null,n)},I.UTF16=function(e,t,r){for(var n=[],a=r/2,o=0;o<a;o++,t+=2)n[o]=e.getUint16(t);return String.fromCharCode.apply(null,n)},G.UTF16=function(e){for(var t=[],r=0;r<e.length;r+=1){var n=e.charCodeAt(r);t[t.length]=n>>8&255,t[t.length]=255&n}return t},M.UTF16=function(e){return 2*e.length};var F={"x-mac-croatian":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ","x-mac-cyrillic":"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю","x-mac-gaelic":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ","x-mac-greek":"Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­","x-mac-icelandic":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ","x-mac-inuit":"ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł","x-mac-ce":"ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",macintosh:"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ","x-mac-romanian":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ","x-mac-turkish":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"};I.MACSTRING=function(e,t,r,n){var a=F[n];if(void 0!==a){for(var o="",s=0;s<r;s++){var i=e.getUint8(t+s);o+=i<=127?String.fromCharCode(i):a[127&i]}return o}};var P,A="function"==typeof WeakMap&&new WeakMap;function N(e){return e>=-128&&e<=127}function H(e,t,r){for(var n=0,a=e.length;t<a&&n<64&&0===e[t];)++t,++n;return r.push(128|n-1),t}function z(e,t,r){for(var n=0,a=e.length,o=t;o<a&&n<64;){var s=e[o];if(!N(s))break;if(0===s&&o+1<a&&0===e[o+1])break;++o,++n}r.push(n-1);for(var i=t;i<o;++i)r.push(e[i]+256&255);return o}function W(e,t,r){for(var n=0,a=e.length,o=t;o<a&&n<64;){var s=e[o];if(0===s)break;if(N(s)&&o+1<a&&N(e[o+1]))break;++o,++n}r.push(64|n-1);for(var i=t;i<o;++i){var u=e[i];r.push(u+65536>>8&255,u+256&255)}return o}G.MACSTRING=function(e,t){var r=function(e){if(!P)for(var t in P={},F)P[t]=new String(t);var r=P[e];if(void 0!==r){if(A){var n=A.get(r);if(void 0!==n)return n}var a=F[e];if(void 0!==a){for(var o={},s=0;s<a.length;s++)o[a.charCodeAt(s)]=s+128;return A&&A.set(r,o),o}}}(t);if(void 0!==r){for(var n=[],a=0;a<e.length;a++){var o=e.charCodeAt(a);if(o>=128&&void 0===(o=r[o]))return;n[a]=o}return n}},M.MACSTRING=function(e,t){var r=G.MACSTRING(e,t);return void 0!==r?r.length:0},G.VARDELTAS=function(e){for(var t=0,r=[];t<e.length;){var n=e[t];t=0===n?H(e,t,r):n>=-128&&n<=127?z(e,t,r):W(e,t,r)}return r},G.INDEX=function(e){for(var t=1,r=[t],n=[],a=0;a<e.length;a+=1){var o=G.OBJECT(e[a]);Array.prototype.push.apply(n,o),t+=o.length,r.push(t)}if(0===n.length)return[0,0];for(var s=[],i=1+Math.floor(Math.log(t)/Math.log(2))/8|0,u=[void 0,G.BYTE,G.USHORT,G.UINT24,G.ULONG][i],l=0;l<r.length;l+=1){var p=u(r[l]);Array.prototype.push.apply(s,p)}return Array.prototype.concat(G.Card16(e.length),G.OffSize(i),s,n)},M.INDEX=function(e){return G.INDEX(e).length},G.DICT=function(e){for(var t=[],r=Object.keys(e),n=r.length,a=0;a<n;a+=1){for(var o=parseInt(r[a],0),s=e[o],i=G.OPERAND(s.value,s.type),u=G.OPERATOR(o),l=0;l<i.length;l++)t.push(i[l]);for(var p=0;p<u.length;p++)t.push(u[p])}return t},M.DICT=function(e){return G.DICT(e).length},G.OPERATOR=function(e){return e<1200?[e]:[12,e-1200]},G.OPERAND=function(e,t){var r=[];if(Array.isArray(t))for(var n=0;n<t.length;n+=1){w.argument(e.length===t.length,"Not enough arguments given for type"+t);for(var a=G.OPERAND(e[n],t[n]),o=0;o<a.length;o++)r.push(a[o])}else if("SID"===t)for(var s=G.NUMBER(e),i=0;i<s.length;i++)r.push(s[i]);else if("offset"===t)for(var u=G.NUMBER32(e),l=0;l<u.length;l++)r.push(u[l]);else if("number"===t)for(var p=G.NUMBER(e),c=0;c<p.length;c++)r.push(p[c]);else{if("real"!==t)throw new Error("Unknown operand type "+t);for(var h=G.REAL(e),f=0;f<h.length;f++)r.push(h[f])}return r},G.OP=G.BYTE,M.OP=M.BYTE;var q="function"==typeof WeakMap&&new WeakMap;function _(e,t,r){if(t.length&&("coverageFormat"!==t[0].name||1===t[0].value))for(var n=0;n<t.length;n+=1){var a=t[n];this[a.name]=a.value}if(this.tableName=e,this.fields=t,r)for(var o=Object.keys(r),s=0;s<o.length;s+=1){var i=o[s],u=r[i];void 0!==this[i]&&(this[i]=u)}}function X(e,t,r){void 0===r&&(r=t.length);var n=new Array(t.length+1);n[0]={name:e+"Count",type:"USHORT",value:r};for(var a=0;a<t.length;a++)n[a+1]={name:e+a,type:"USHORT",value:t[a]};return n}function V(e,t,r){var n=t.length,a=new Array(n+1);a[0]={name:e+"Count",type:"USHORT",value:n};for(var o=0;o<n;o++)a[o+1]={name:e+o,type:"TABLE",value:r(t[o],o)};return a}function j(e,t,r){var n=t.length,a=[];a[0]={name:e+"Count",type:"USHORT",value:n};for(var o=0;o<n;o++)a=a.concat(r(t[o],o));return a}function Y(e){1===e.format?_.call(this,"coverageTable",[{name:"coverageFormat",type:"USHORT",value:1}].concat(X("glyph",e.glyphs))):2===e.format?_.call(this,"coverageTable",[{name:"coverageFormat",type:"USHORT",value:2}].concat(j("rangeRecord",e.ranges,(function(e){return[{name:"startGlyphID",type:"USHORT",value:e.start},{name:"endGlyphID",type:"USHORT",value:e.end},{name:"startCoverageIndex",type:"USHORT",value:e.index}]})))):w.assert(!1,"Coverage format must be 1 or 2.")}function Z(e){_.call(this,"scriptListTable",j("scriptRecord",e,(function(e,t){var r=e.script,n=r.defaultLangSys;return w.assert(!!n,"Unable to write GSUB: script "+e.tag+" has no default language system."),[{name:"scriptTag"+t,type:"TAG",value:e.tag},{name:"script"+t,type:"TABLE",value:new _("scriptTable",[{name:"defaultLangSys",type:"TABLE",value:new _("defaultLangSys",[{name:"lookupOrder",type:"USHORT",value:0},{name:"reqFeatureIndex",type:"USHORT",value:n.reqFeatureIndex}].concat(X("featureIndex",n.featureIndexes)))}].concat(j("langSys",r.langSysRecords,(function(e,t){var r=e.langSys;return[{name:"langSysTag"+t,type:"TAG",value:e.tag},{name:"langSys"+t,type:"TABLE",value:new _("langSys",[{name:"lookupOrder",type:"USHORT",value:0},{name:"reqFeatureIndex",type:"USHORT",value:r.reqFeatureIndex}].concat(X("featureIndex",r.featureIndexes)))}]}))))}]})))}function Q(e){_.call(this,"featureListTable",j("featureRecord",e,(function(e,t){var r=e.feature;return[{name:"featureTag"+t,type:"TAG",value:e.tag},{name:"feature"+t,type:"TABLE",value:new _("featureTable",[{name:"featureParams",type:"USHORT",value:r.featureParams}].concat(X("lookupListIndex",r.lookupListIndexes)))}]})))}function K(e,t){_.call(this,"lookupListTable",V("lookup",e,(function(e){var r=t[e.lookupType];return w.assert(!!r,"Unable to write GSUB lookup type "+e.lookupType+" tables."),new _("lookupTable",[{name:"lookupType",type:"USHORT",value:e.lookupType},{name:"lookupFlag",type:"USHORT",value:e.lookupFlag}].concat(V("subtable",e.subtables,r)))})))}G.CHARSTRING=function(e){if(q){var t=q.get(e);if(void 0!==t)return t}for(var r=[],n=e.length,a=0;a<n;a+=1)for(var o=e[a],s=G[o.type](o.value),i=0;i<s.length;i++)r.push(s[i]);return q&&q.set(e,r),r},M.CHARSTRING=function(e){return G.CHARSTRING(e).length},G.OBJECT=function(e){var t=G[e.type];return w.argument(void 0!==t,"No encoding function for type "+e.type),t(e.value)},M.OBJECT=function(e){var t=M[e.type];return w.argument(void 0!==t,"No sizeOf function for type "+e.type),t(e.value)},G.TABLE=function(e){for(var t=[],r=e.fields.length,n=[],a=[],o=0;o<r;o+=1){var s=e.fields[o],i=G[s.type];w.argument(void 0!==i,"No encoding function for field type "+s.type+" ("+s.name+")");var u=e[s.name];void 0===u&&(u=s.value);var l=i(u);if("TABLE"===s.type)a.push(t.length),t.push(0,0),n.push(l);else for(var p=0;p<l.length;p++)t.push(l[p])}for(var c=0;c<n.length;c+=1){var h=a[c],f=t.length;w.argument(f<65536,"Table "+e.tableName+" too big."),t[h]=f>>8,t[h+1]=255&f;for(var d=0;d<n[c].length;d++)t.push(n[c][d])}return t},M.TABLE=function(e){for(var t=0,r=e.fields.length,n=0;n<r;n+=1){var a=e.fields[n],o=M[a.type];w.argument(void 0!==o,"No sizeOf function for field type "+a.type+" ("+a.name+")");var s=e[a.name];void 0===s&&(s=a.value),t+=o(s),"TABLE"===a.type&&(t+=2)}return t},G.RECORD=G.TABLE,M.RECORD=M.TABLE,G.LITERAL=function(e){return e},M.LITERAL=function(e){return e.length},_.prototype.encode=function(){return G.TABLE(this)},_.prototype.sizeOf=function(){return M.TABLE(this)},Y.prototype=Object.create(_.prototype),Y.prototype.constructor=Y,Z.prototype=Object.create(_.prototype),Z.prototype.constructor=Z,Q.prototype=Object.create(_.prototype),Q.prototype.constructor=Q,K.prototype=Object.create(_.prototype),K.prototype.constructor=K;var J={Table:_,Record:_,Coverage:Y,ScriptList:Z,FeatureList:Q,LookupList:K,ushortList:X,tableList:V,recordList:j};function $(e,t){return e.getUint8(t)}function ee(e,t){return e.getUint16(t,!1)}function te(e,t){return e.getUint32(t,!1)}function re(e,t){return e.getInt16(t,!1)+e.getUint16(t+2,!1)/65535}var ne={byte:1,uShort:2,short:2,uLong:4,fixed:4,longDateTime:8,tag:4};function ae(e,t){this.data=e,this.offset=t,this.relativeOffset=0}ae.prototype.parseByte=function(){var e=this.data.getUint8(this.offset+this.relativeOffset);return this.relativeOffset+=1,e},ae.prototype.parseChar=function(){var e=this.data.getInt8(this.offset+this.relativeOffset);return this.relativeOffset+=1,e},ae.prototype.parseCard8=ae.prototype.parseByte,ae.prototype.parseUShort=function(){var e=this.data.getUint16(this.offset+this.relativeOffset);return this.relativeOffset+=2,e},ae.prototype.parseCard16=ae.prototype.parseUShort,ae.prototype.parseSID=ae.prototype.parseUShort,ae.prototype.parseOffset16=ae.prototype.parseUShort,ae.prototype.parseShort=function(){var e=this.data.getInt16(this.offset+this.relativeOffset);return this.relativeOffset+=2,e},ae.prototype.parseF2Dot14=function(){var e=this.data.getInt16(this.offset+this.relativeOffset)/16384;return this.relativeOffset+=2,e},ae.prototype.parseULong=function(){var e=te(this.data,this.offset+this.relativeOffset);return this.relativeOffset+=4,e},ae.prototype.parseOffset32=ae.prototype.parseULong,ae.prototype.parseFixed=function(){var e=re(this.data,this.offset+this.relativeOffset);return this.relativeOffset+=4,e},ae.prototype.parseString=function(e){var t=this.data,r=this.offset+this.relativeOffset,n="";this.relativeOffset+=e;for(var a=0;a<e;a++)n+=String.fromCharCode(t.getUint8(r+a));return n},ae.prototype.parseTag=function(){return this.parseString(4)},ae.prototype.parseLongDateTime=function(){var e=te(this.data,this.offset+this.relativeOffset+4);return e-=2082844800,this.relativeOffset+=8,e},ae.prototype.parseVersion=function(e){var t=ee(this.data,this.offset+this.relativeOffset),r=ee(this.data,this.offset+this.relativeOffset+2);return this.relativeOffset+=4,void 0===e&&(e=4096),t+r/e/10},ae.prototype.skip=function(e,t){void 0===t&&(t=1),this.relativeOffset+=ne[e]*t},ae.prototype.parseULongList=function(e){void 0===e&&(e=this.parseULong());for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getUint32(n),n+=4;return this.relativeOffset+=4*e,t},ae.prototype.parseOffset16List=ae.prototype.parseUShortList=function(e){void 0===e&&(e=this.parseUShort());for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getUint16(n),n+=2;return this.relativeOffset+=2*e,t},ae.prototype.parseShortList=function(e){for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getInt16(n),n+=2;return this.relativeOffset+=2*e,t},ae.prototype.parseByteList=function(e){for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getUint8(n++);return this.relativeOffset+=e,t},ae.prototype.parseList=function(e,t){t||(t=e,e=this.parseUShort());for(var r=new Array(e),n=0;n<e;n++)r[n]=t.call(this);return r},ae.prototype.parseList32=function(e,t){t||(t=e,e=this.parseULong());for(var r=new Array(e),n=0;n<e;n++)r[n]=t.call(this);return r},ae.prototype.parseRecordList=function(e,t){t||(t=e,e=this.parseUShort());for(var r=new Array(e),n=Object.keys(t),a=0;a<e;a++){for(var o={},s=0;s<n.length;s++){var i=n[s],u=t[i];o[i]=u.call(this)}r[a]=o}return r},ae.prototype.parseRecordList32=function(e,t){t||(t=e,e=this.parseULong());for(var r=new Array(e),n=Object.keys(t),a=0;a<e;a++){for(var o={},s=0;s<n.length;s++){var i=n[s],u=t[i];o[i]=u.call(this)}r[a]=o}return r},ae.prototype.parseStruct=function(e){if("function"==typeof e)return e.call(this);for(var t=Object.keys(e),r={},n=0;n<t.length;n++){var a=t[n],o=e[a];r[a]=o.call(this)}return r},ae.prototype.parseValueRecord=function(e){if(void 0===e&&(e=this.parseUShort()),0!==e){var t={};return 1&e&&(t.xPlacement=this.parseShort()),2&e&&(t.yPlacement=this.parseShort()),4&e&&(t.xAdvance=this.parseShort()),8&e&&(t.yAdvance=this.parseShort()),16&e&&(t.xPlaDevice=void 0,this.parseShort()),32&e&&(t.yPlaDevice=void 0,this.parseShort()),64&e&&(t.xAdvDevice=void 0,this.parseShort()),128&e&&(t.yAdvDevice=void 0,this.parseShort()),t}},ae.prototype.parseValueRecordList=function(){for(var e=this.parseUShort(),t=this.parseUShort(),r=new Array(t),n=0;n<t;n++)r[n]=this.parseValueRecord(e);return r},ae.prototype.parsePointer=function(e){var t=this.parseOffset16();if(t>0)return new ae(this.data,this.offset+t).parseStruct(e)},ae.prototype.parsePointer32=function(e){var t=this.parseOffset32();if(t>0)return new ae(this.data,this.offset+t).parseStruct(e)},ae.prototype.parseListOfLists=function(e){for(var t=this.parseOffset16List(),r=t.length,n=this.relativeOffset,a=new Array(r),o=0;o<r;o++){var s=t[o];if(0!==s)if(this.relativeOffset=s,e){for(var i=this.parseOffset16List(),u=new Array(i.length),l=0;l<i.length;l++)this.relativeOffset=s+i[l],u[l]=e.call(this);a[o]=u}else a[o]=this.parseUShortList();else a[o]=void 0}return this.relativeOffset=n,a},ae.prototype.parseCoverage=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort(),r=this.parseUShort();if(1===t)return{format:1,glyphs:this.parseUShortList(r)};if(2===t){for(var n=new Array(r),a=0;a<r;a++)n[a]={start:this.parseUShort(),end:this.parseUShort(),index:this.parseUShort()};return{format:2,ranges:n}}throw new Error("0x"+e.toString(16)+": Coverage format must be 1 or 2.")},ae.prototype.parseClassDef=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();if(1===t)return{format:1,startGlyph:this.parseUShort(),classes:this.parseUShortList()};if(2===t)return{format:2,ranges:this.parseRecordList({start:ae.uShort,end:ae.uShort,classId:ae.uShort})};throw new Error("0x"+e.toString(16)+": ClassDef format must be 1 or 2.")},ae.list=function(e,t){return function(){return this.parseList(e,t)}},ae.list32=function(e,t){return function(){return this.parseList32(e,t)}},ae.recordList=function(e,t){return function(){return this.parseRecordList(e,t)}},ae.recordList32=function(e,t){return function(){return this.parseRecordList32(e,t)}},ae.pointer=function(e){return function(){return this.parsePointer(e)}},ae.pointer32=function(e){return function(){return this.parsePointer32(e)}},ae.tag=ae.prototype.parseTag,ae.byte=ae.prototype.parseByte,ae.uShort=ae.offset16=ae.prototype.parseUShort,ae.uShortList=ae.prototype.parseUShortList,ae.uLong=ae.offset32=ae.prototype.parseULong,ae.uLongList=ae.prototype.parseULongList,ae.struct=ae.prototype.parseStruct,ae.coverage=ae.prototype.parseCoverage,ae.classDef=ae.prototype.parseClassDef;var oe={reserved:ae.uShort,reqFeatureIndex:ae.uShort,featureIndexes:ae.uShortList};ae.prototype.parseScriptList=function(){return this.parsePointer(ae.recordList({tag:ae.tag,script:ae.pointer({defaultLangSys:ae.pointer(oe),langSysRecords:ae.recordList({tag:ae.tag,langSys:ae.pointer(oe)})})}))||[]},ae.prototype.parseFeatureList=function(){return this.parsePointer(ae.recordList({tag:ae.tag,feature:ae.pointer({featureParams:ae.offset16,lookupListIndexes:ae.uShortList})}))||[]},ae.prototype.parseLookupList=function(e){return this.parsePointer(ae.list(ae.pointer((function(){var t=this.parseUShort();w.argument(1<=t&&t<=9,"GPOS/GSUB lookup type "+t+" unknown.");var r=this.parseUShort(),n=16&r;return{lookupType:t,lookupFlag:r,subtables:this.parseList(ae.pointer(e[t])),markFilteringSet:n?this.parseUShort():void 0}}))))||[]},ae.prototype.parseFeatureVariationsList=function(){return this.parsePointer32((function(){var e=this.parseUShort(),t=this.parseUShort();return w.argument(1===e&&t<1,"GPOS/GSUB feature variations table unknown."),this.parseRecordList32({conditionSetOffset:ae.offset32,featureTableSubstitutionOffset:ae.offset32})}))||[]};var se={getByte:$,getCard8:$,getUShort:ee,getCard16:ee,getShort:function(e,t){return e.getInt16(t,!1)},getULong:te,getFixed:re,getTag:function(e,t){for(var r="",n=t;n<t+4;n+=1)r+=String.fromCharCode(e.getInt8(n));return r},getOffset:function(e,t,r){for(var n=0,a=0;a<r;a+=1)n<<=8,n+=e.getUint8(t+a);return n},getBytes:function(e,t,r){for(var n=[],a=t;a<r;a+=1)n.push(e.getUint8(a));return n},bytesToString:function(e){for(var t="",r=0;r<e.length;r+=1)t+=String.fromCharCode(e[r]);return t},Parser:ae},ie=["copyright","fontFamily","fontSubfamily","uniqueID","fullName","version","postScriptName","trademark","manufacturer","designer","description","manufacturerURL","designerURL","license","licenseURL","reserved","preferredFamily","preferredSubfamily","compatibleFullName","sampleText","postScriptFindFontName","wwsFamily","wwsSubfamily"],ue={0:"en",1:"fr",2:"de",3:"it",4:"nl",5:"sv",6:"es",7:"da",8:"pt",9:"no",10:"he",11:"ja",12:"ar",13:"fi",14:"el",15:"is",16:"mt",17:"tr",18:"hr",19:"zh-Hant",20:"ur",21:"hi",22:"th",23:"ko",24:"lt",25:"pl",26:"hu",27:"es",28:"lv",29:"se",30:"fo",31:"fa",32:"ru",33:"zh",34:"nl-BE",35:"ga",36:"sq",37:"ro",38:"cz",39:"sk",40:"si",41:"yi",42:"sr",43:"mk",44:"bg",45:"uk",46:"be",47:"uz",48:"kk",49:"az-Cyrl",50:"az-Arab",51:"hy",52:"ka",53:"mo",54:"ky",55:"tg",56:"tk",57:"mn-CN",58:"mn",59:"ps",60:"ks",61:"ku",62:"sd",63:"bo",64:"ne",65:"sa",66:"mr",67:"bn",68:"as",69:"gu",70:"pa",71:"or",72:"ml",73:"kn",74:"ta",75:"te",76:"si",77:"my",78:"km",79:"lo",80:"vi",81:"id",82:"tl",83:"ms",84:"ms-Arab",85:"am",86:"ti",87:"om",88:"so",89:"sw",90:"rw",91:"rn",92:"ny",93:"mg",94:"eo",128:"cy",129:"eu",130:"ca",131:"la",132:"qu",133:"gn",134:"ay",135:"tt",136:"ug",137:"dz",138:"jv",139:"su",140:"gl",141:"af",142:"br",143:"iu",144:"gd",145:"gv",146:"ga",147:"to",148:"el-polyton",149:"kl",150:"az",151:"nn"},le={0:0,1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:5,11:1,12:4,13:0,14:6,15:0,16:0,17:0,18:0,19:2,20:4,21:9,22:21,23:3,24:29,25:29,26:29,27:29,28:29,29:0,30:0,31:4,32:7,33:25,34:0,35:0,36:0,37:0,38:29,39:29,40:0,41:5,42:7,43:7,44:7,45:7,46:7,47:7,48:7,49:7,50:4,51:24,52:23,53:7,54:7,55:7,56:7,57:27,58:7,59:4,60:4,61:4,62:4,63:26,64:9,65:9,66:9,67:13,68:13,69:11,70:10,71:12,72:17,73:16,74:14,75:15,76:18,77:19,78:20,79:22,80:30,81:0,82:0,83:0,84:4,85:28,86:28,87:28,88:0,89:0,90:0,91:0,92:0,93:0,94:0,128:0,129:0,130:0,131:0,132:0,133:0,134:0,135:7,136:4,137:26,138:0,139:0,140:0,141:0,142:0,143:28,144:0,145:0,146:0,147:0,148:6,149:0,150:0,151:0},pe={1078:"af",1052:"sq",1156:"gsw",1118:"am",5121:"ar-DZ",15361:"ar-BH",3073:"ar",2049:"ar-IQ",11265:"ar-JO",13313:"ar-KW",12289:"ar-LB",4097:"ar-LY",6145:"ary",8193:"ar-OM",16385:"ar-QA",1025:"ar-SA",10241:"ar-SY",7169:"aeb",14337:"ar-AE",9217:"ar-YE",1067:"hy",1101:"as",2092:"az-Cyrl",1068:"az",1133:"ba",1069:"eu",1059:"be",2117:"bn",1093:"bn-IN",8218:"bs-Cyrl",5146:"bs",1150:"br",1026:"bg",1027:"ca",3076:"zh-HK",5124:"zh-MO",2052:"zh",4100:"zh-SG",1028:"zh-TW",1155:"co",1050:"hr",4122:"hr-BA",1029:"cs",1030:"da",1164:"prs",1125:"dv",2067:"nl-BE",1043:"nl",3081:"en-AU",10249:"en-BZ",4105:"en-CA",9225:"en-029",16393:"en-IN",6153:"en-IE",8201:"en-JM",17417:"en-MY",5129:"en-NZ",13321:"en-PH",18441:"en-SG",7177:"en-ZA",11273:"en-TT",2057:"en-GB",1033:"en",12297:"en-ZW",1061:"et",1080:"fo",1124:"fil",1035:"fi",2060:"fr-BE",3084:"fr-CA",1036:"fr",5132:"fr-LU",6156:"fr-MC",4108:"fr-CH",1122:"fy",1110:"gl",1079:"ka",3079:"de-AT",1031:"de",5127:"de-LI",4103:"de-LU",2055:"de-CH",1032:"el",1135:"kl",1095:"gu",1128:"ha",1037:"he",1081:"hi",1038:"hu",1039:"is",1136:"ig",1057:"id",1117:"iu",2141:"iu-Latn",2108:"ga",1076:"xh",1077:"zu",1040:"it",2064:"it-CH",1041:"ja",1099:"kn",1087:"kk",1107:"km",1158:"quc",1159:"rw",1089:"sw",1111:"kok",1042:"ko",1088:"ky",1108:"lo",1062:"lv",1063:"lt",2094:"dsb",1134:"lb",1071:"mk",2110:"ms-BN",1086:"ms",1100:"ml",1082:"mt",1153:"mi",1146:"arn",1102:"mr",1148:"moh",1104:"mn",2128:"mn-CN",1121:"ne",1044:"nb",2068:"nn",1154:"oc",1096:"or",1123:"ps",1045:"pl",1046:"pt",2070:"pt-PT",1094:"pa",1131:"qu-BO",2155:"qu-EC",3179:"qu",1048:"ro",1047:"rm",1049:"ru",9275:"smn",4155:"smj-NO",5179:"smj",3131:"se-FI",1083:"se",2107:"se-SE",8251:"sms",6203:"sma-NO",7227:"sms",1103:"sa",7194:"sr-Cyrl-BA",3098:"sr",6170:"sr-Latn-BA",2074:"sr-Latn",1132:"nso",1074:"tn",1115:"si",1051:"sk",1060:"sl",11274:"es-AR",16394:"es-BO",13322:"es-CL",9226:"es-CO",5130:"es-CR",7178:"es-DO",12298:"es-EC",17418:"es-SV",4106:"es-GT",18442:"es-HN",2058:"es-MX",19466:"es-NI",6154:"es-PA",15370:"es-PY",10250:"es-PE",20490:"es-PR",3082:"es",1034:"es",21514:"es-US",14346:"es-UY",8202:"es-VE",2077:"sv-FI",1053:"sv",1114:"syr",1064:"tg",2143:"tzm",1097:"ta",1092:"tt",1098:"te",1054:"th",1105:"bo",1055:"tr",1090:"tk",1152:"ug",1058:"uk",1070:"hsb",1056:"ur",2115:"uz-Cyrl",1091:"uz",1066:"vi",1106:"cy",1160:"wo",1157:"sah",1144:"ii",1130:"yo"};function ce(e,t,r){switch(e){case 0:if(65535===t)return"und";if(r)return r[t];break;case 1:return ue[t];case 3:return pe[t]}}var he="utf-16",fe={0:"macintosh",1:"x-mac-japanese",2:"x-mac-chinesetrad",3:"x-mac-korean",6:"x-mac-greek",7:"x-mac-cyrillic",9:"x-mac-devanagai",10:"x-mac-gurmukhi",11:"x-mac-gujarati",12:"x-mac-oriya",13:"x-mac-bengali",14:"x-mac-tamil",15:"x-mac-telugu",16:"x-mac-kannada",17:"x-mac-malayalam",18:"x-mac-sinhalese",19:"x-mac-burmese",20:"x-mac-khmer",21:"x-mac-thai",22:"x-mac-lao",23:"x-mac-georgian",24:"x-mac-armenian",25:"x-mac-chinesesimp",26:"x-mac-tibetan",27:"x-mac-mongolian",28:"x-mac-ethiopic",29:"x-mac-ce",30:"x-mac-vietnamese",31:"x-mac-extarabic"},de={15:"x-mac-icelandic",17:"x-mac-turkish",18:"x-mac-croatian",24:"x-mac-ce",25:"x-mac-ce",26:"x-mac-ce",27:"x-mac-ce",28:"x-mac-ce",30:"x-mac-icelandic",37:"x-mac-romanian",38:"x-mac-ce",39:"x-mac-ce",40:"x-mac-ce",143:"x-mac-inuit",146:"x-mac-gaelic"};function ve(e,t,r){switch(e){case 0:return he;case 1:return de[r]||fe[t];case 3:if(1===t||10===t)return he}}function ge(e){var t={};for(var r in e)t[e[r]]=parseInt(r);return t}function me(e,t,r,n,a,o){return new J.Record("NameRecord",[{name:"platformID",type:"USHORT",value:e},{name:"encodingID",type:"USHORT",value:t},{name:"languageID",type:"USHORT",value:r},{name:"nameID",type:"USHORT",value:n},{name:"length",type:"USHORT",value:a},{name:"offset",type:"USHORT",value:o}])}function ye(e,t){var r=function(e,t){var r=e.length,n=t.length-r+1;e:for(var a=0;a<n;a++)for(;a<n;a++){for(var o=0;o<r;o++)if(t[a+o]!==e[o])continue e;return a}return-1}(e,t);if(r<0){r=t.length;for(var n=0,a=e.length;n<a;++n)t.push(e[n])}return r}var be={parse:function(e,t,r){for(var n={},a=new se.Parser(e,t),o=a.parseUShort(),s=a.parseUShort(),i=a.offset+a.parseUShort(),u=0;u<s;u++){var l=a.parseUShort(),p=a.parseUShort(),c=a.parseUShort(),h=a.parseUShort(),f=ie[h]||h,d=a.parseUShort(),v=a.parseUShort(),g=ce(l,c,r),m=ve(l,p,c);if(void 0!==m&&void 0!==g){var y=void 0;if(y=m===he?I.UTF16(e,i+v,d):I.MACSTRING(e,i+v,d,m)){var b=n[f];void 0===b&&(b=n[f]={}),b[g]=y}}}return 1===o&&a.parseUShort(),n},make:function(e,t){var r,n=[],a={},o=ge(ie);for(var s in e){var i=o[s];if(void 0===i&&(i=s),r=parseInt(i),isNaN(r))throw new Error('Name table entry "'+s+'" does not exist, see nameTableNames for complete list.');a[r]=e[s],n.push(r)}for(var u=ge(ue),l=ge(pe),p=[],c=[],h=0;h<n.length;h++){var f=a[r=n[h]];for(var d in f){var v=f[d],g=1,m=u[d],y=le[m],b=ve(g,y,m),S=G.MACSTRING(v,b);void 0===S&&(g=0,(m=t.indexOf(d))<0&&(m=t.length,t.push(d)),y=4,S=G.UTF16(v));var x=ye(S,c);p.push(me(g,y,m,r,S.length,x));var T=l[d];if(void 0!==T){var U=G.UTF16(v),k=ye(U,c);p.push(me(3,1,T,r,U.length,k))}}}p.sort((function(e,t){return e.platformID-t.platformID||e.encodingID-t.encodingID||e.languageID-t.languageID||e.nameID-t.nameID}));for(var O=new J.Table("name",[{name:"format",type:"USHORT",value:0},{name:"count",type:"USHORT",value:p.length},{name:"stringOffset",type:"USHORT",value:6+12*p.length}]),R=0;R<p.length;R++)O.fields.push({name:"record_"+R,type:"RECORD",value:p[R]});return O.fields.push({name:"strings",type:"LITERAL",value:c}),O}};function Se(e,t,r){e.segments.push({end:t,start:t,delta:-(t-r),offset:0,glyphIndex:r})}var xe={parse:function(e,t){var r={};r.version=se.getUShort(e,t),w.argument(0===r.version,"cmap table version should be 0."),r.numTables=se.getUShort(e,t+2);for(var n=null,a=-1,o=-1,s=null,i=null,u=[0,1,2,3,4,6],l=[0,1,10],p=r.numTables-1;p>=0;p-=1)if(s=se.getUShort(e,t+4+8*p),i=se.getUShort(e,t+4+8*p+2),3===s&&l.includes(i)||0===s&&u.includes(i)||1===s&&0===i){if(o>0)continue;if(o=se.getULong(e,t+4+8*p+4),n)break}else if(0===s&&5===i)if(a=se.getULong(e,t+4+8*p+4),14!==(n=new se.Parser(e,t+a)).parseUShort())a=-1,n=null;else if(o>0)break;if(-1===o)throw new Error("No valid cmap sub-tables found.");var c=new se.Parser(e,t+o);if(r.format=c.parseUShort(),0===r.format)!function(e,t,r,n){e.length=t.parseUShort(),e.language=t.parseUShort()-1;for(var a=t.parseByteList(e.length),o=Object.assign({},a),s=ve(r,n,e.language),i=F[s],u=0;u<i.length;u++)o[i.charCodeAt(u)]=a[128+u];e.glyphIndexMap=o}(r,c,s,i);else if(12===r.format||13===r.format)!function(e,t,r){var n;t.parseUShort(),e.length=t.parseULong(),e.language=t.parseULong(),e.groupCount=n=t.parseULong(),e.glyphIndexMap={};for(var a=0;a<n;a+=1)for(var o=t.parseULong(),s=t.parseULong(),i=t.parseULong(),u=o;u<=s;u+=1)e.glyphIndexMap[u]=i,12===r&&i++}(r,c,r.format);else{if(4!==r.format)throw new Error("Only format 0 (platformId 1, encodingId 0), 4, 12 and 14 cmap tables are supported (found format "+r.format+", platformId "+s+", encodingId "+i+").");!function(e,t,r,n,a){var o;e.length=t.parseUShort(),e.language=t.parseUShort(),e.segCount=o=t.parseUShort()>>1,t.skip("uShort",3),e.glyphIndexMap={};for(var s=new se.Parser(r,n+a+14),i=new se.Parser(r,n+a+16+2*o),u=new se.Parser(r,n+a+16+4*o),l=new se.Parser(r,n+a+16+6*o),p=n+a+16+8*o,c=0;c<o-1;c+=1)for(var h=void 0,f=s.parseUShort(),d=i.parseUShort(),v=u.parseShort(),g=l.parseUShort(),m=d;m<=f;m+=1)0!==g?(p=l.offset+l.relativeOffset-2,p+=g,p+=2*(m-d),0!==(h=se.getUShort(r,p))&&(h=h+v&65535)):h=m+v&65535,e.glyphIndexMap[m]=h}(r,c,e,t,o)}return r},make:function(e){var t,r=!0;for(t=e.length-1;t>0;t-=1){if(e.get(t).unicode>65535){console.log("Adding CMAP format 12 (needed!)"),r=!1;break}}var n=[{name:"version",type:"USHORT",value:0},{name:"numTables",type:"USHORT",value:r?1:2},{name:"platformID",type:"USHORT",value:3},{name:"encodingID",type:"USHORT",value:1},{name:"offset",type:"ULONG",value:r?12:20}];r||n.push({name:"cmap12PlatformID",type:"USHORT",value:3},{name:"cmap12EncodingID",type:"USHORT",value:10},{name:"cmap12Offset",type:"ULONG",value:0}),n.push({name:"format",type:"USHORT",value:4},{name:"cmap4Length",type:"USHORT",value:0},{name:"language",type:"USHORT",value:0},{name:"segCountX2",type:"USHORT",value:0},{name:"searchRange",type:"USHORT",value:0},{name:"entrySelector",type:"USHORT",value:0},{name:"rangeShift",type:"USHORT",value:0});var a=new J.Table("cmap",n);for(a.segments=[],t=0;t<e.length;t+=1)for(var o=e.get(t),s=0;s<o.unicodes.length;s+=1)Se(a,o.unicodes[s],t);a.segments.sort((function(e,t){return e.start-t.start})),function(e){e.segments.push({end:65535,start:65535,delta:1,offset:0})}(a);var i=a.segments.length,u=0,l=[],p=[],c=[],h=[],f=[],d=[];for(t=0;t<i;t+=1){var v=a.segments[t];v.end<=65535&&v.start<=65535?(l.push({name:"end_"+t,type:"USHORT",value:v.end}),p.push({name:"start_"+t,type:"USHORT",value:v.start}),c.push({name:"idDelta_"+t,type:"SHORT",value:v.delta}),h.push({name:"idRangeOffset_"+t,type:"USHORT",value:v.offset}),void 0!==v.glyphId&&f.push({name:"glyph_"+t,type:"USHORT",value:v.glyphId})):u+=1,r||void 0===v.glyphIndex||(d.push({name:"cmap12Start_"+t,type:"ULONG",value:v.start}),d.push({name:"cmap12End_"+t,type:"ULONG",value:v.end}),d.push({name:"cmap12Glyph_"+t,type:"ULONG",value:v.glyphIndex}))}a.segCountX2=2*(i-u),a.searchRange=2*Math.pow(2,Math.floor(Math.log(i-u)/Math.log(2))),a.entrySelector=Math.log(a.searchRange/2)/Math.log(2),a.rangeShift=a.segCountX2-a.searchRange;for(var g=0;g<l.length;g++)a.fields.push(l[g]);a.fields.push({name:"reservedPad",type:"USHORT",value:0});for(var m=0;m<p.length;m++)a.fields.push(p[m]);for(var y=0;y<c.length;y++)a.fields.push(c[y]);for(var b=0;b<h.length;b++)a.fields.push(h[b]);for(var S=0;S<f.length;S++)a.fields.push(f[S]);if(a.cmap4Length=14+2*l.length+2+2*p.length+2*c.length+2*h.length+2*f.length,!r){var x=16+4*d.length;a.cmap12Offset=20+a.cmap4Length,a.fields.push({name:"cmap12Format",type:"USHORT",value:12},{name:"cmap12Reserved",type:"USHORT",value:0},{name:"cmap12Length",type:"ULONG",value:x},{name:"cmap12Language",type:"ULONG",value:0},{name:"cmap12nGroups",type:"ULONG",value:d.length/3});for(var T=0;T<d.length;T++)a.fields.push(d[T])}return a}},Te=[".notdef","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","endash","dagger","daggerdbl","periodcentered","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","questiondown","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","ring","cedilla","hungarumlaut","ogonek","caron","emdash","AE","ordfeminine","Lslash","Oslash","OE","ordmasculine","ae","dotlessi","lslash","oslash","oe","germandbls","onesuperior","logicalnot","mu","trademark","Eth","onehalf","plusminus","Thorn","onequarter","divide","brokenbar","degree","thorn","threequarters","twosuperior","registered","minus","eth","multiply","threesuperior","copyright","Aacute","Acircumflex","Adieresis","Agrave","Aring","Atilde","Ccedilla","Eacute","Ecircumflex","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Ntilde","Oacute","Ocircumflex","Odieresis","Ograve","Otilde","Scaron","Uacute","Ucircumflex","Udieresis","Ugrave","Yacute","Ydieresis","Zcaron","aacute","acircumflex","adieresis","agrave","aring","atilde","ccedilla","eacute","ecircumflex","edieresis","egrave","iacute","icircumflex","idieresis","igrave","ntilde","oacute","ocircumflex","odieresis","ograve","otilde","scaron","uacute","ucircumflex","udieresis","ugrave","yacute","ydieresis","zcaron","exclamsmall","Hungarumlautsmall","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","266 ff","onedotenleader","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","commasuperior","threequartersemdash","periodsuperior","questionsmall","asuperior","bsuperior","centsuperior","dsuperior","esuperior","isuperior","lsuperior","msuperior","nsuperior","osuperior","rsuperior","ssuperior","tsuperior","ff","ffi","ffl","parenleftinferior","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","exclamdownsmall","centoldstyle","Lslashsmall","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","Dotaccentsmall","Macronsmall","figuredash","hypheninferior","Ogoneksmall","Ringsmall","Cedillasmall","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","zerosuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall","001.000","001.001","001.002","001.003","Black","Bold","Book","Light","Medium","Regular","Roman","Semibold"],Ue=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","","endash","dagger","daggerdbl","periodcentered","","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","","questiondown","","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","","ring","cedilla","","hungarumlaut","ogonek","caron","emdash","","","","","","","","","","","","","","","","","AE","","ordfeminine","","","","","Lslash","Oslash","OE","ordmasculine","","","","","","ae","","","","dotlessi","","","lslash","oslash","oe","germandbls"],ke=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclamsmall","Hungarumlautsmall","","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","comma","hyphen","period","fraction","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","colon","semicolon","commasuperior","threequartersemdash","periodsuperior","questionsmall","","asuperior","bsuperior","centsuperior","dsuperior","esuperior","","","isuperior","","","lsuperior","msuperior","nsuperior","osuperior","","","rsuperior","ssuperior","tsuperior","","ff","fi","fl","ffi","ffl","parenleftinferior","","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdownsmall","centoldstyle","Lslashsmall","","","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","","Dotaccentsmall","","","Macronsmall","","","figuredash","hypheninferior","","","Ogoneksmall","Ringsmall","Cedillasmall","","","","onequarter","onehalf","threequarters","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","","","zerosuperior","onesuperior","twosuperior","threesuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall"],Oe=[".notdef",".null","nonmarkingreturn","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quotesingle","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","grave","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","Adieresis","Aring","Ccedilla","Eacute","Ntilde","Odieresis","Udieresis","aacute","agrave","acircumflex","adieresis","atilde","aring","ccedilla","eacute","egrave","ecircumflex","edieresis","iacute","igrave","icircumflex","idieresis","ntilde","oacute","ograve","ocircumflex","odieresis","otilde","uacute","ugrave","ucircumflex","udieresis","dagger","degree","cent","sterling","section","bullet","paragraph","germandbls","registered","copyright","trademark","acute","dieresis","notequal","AE","Oslash","infinity","plusminus","lessequal","greaterequal","yen","mu","partialdiff","summation","product","pi","integral","ordfeminine","ordmasculine","Omega","ae","oslash","questiondown","exclamdown","logicalnot","radical","florin","approxequal","Delta","guillemotleft","guillemotright","ellipsis","nonbreakingspace","Agrave","Atilde","Otilde","OE","oe","endash","emdash","quotedblleft","quotedblright","quoteleft","quoteright","divide","lozenge","ydieresis","Ydieresis","fraction","currency","guilsinglleft","guilsinglright","fi","fl","daggerdbl","periodcentered","quotesinglbase","quotedblbase","perthousand","Acircumflex","Ecircumflex","Aacute","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Oacute","Ocircumflex","apple","Ograve","Uacute","Ucircumflex","Ugrave","dotlessi","circumflex","tilde","macron","breve","dotaccent","ring","cedilla","hungarumlaut","ogonek","caron","Lslash","lslash","Scaron","scaron","Zcaron","zcaron","brokenbar","Eth","eth","Yacute","yacute","Thorn","thorn","minus","multiply","onesuperior","twosuperior","threesuperior","onehalf","onequarter","threequarters","franc","Gbreve","gbreve","Idotaccent","Scedilla","scedilla","Cacute","cacute","Ccaron","ccaron","dcroat"];function Re(e){this.font=e}function Ee(e){this.cmap=e}function Le(e,t){this.encoding=e,this.charset=t}function Ce(e){switch(e.version){case 1:this.names=Oe.slice();break;case 2:this.names=new Array(e.numberOfGlyphs);for(var t=0;t<e.numberOfGlyphs;t++)e.glyphNameIndex[t]<Oe.length?this.names[t]=Oe[e.glyphNameIndex[t]]:this.names[t]=e.names[e.glyphNameIndex[t]-Oe.length];break;case 2.5:this.names=new Array(e.numberOfGlyphs);for(var r=0;r<e.numberOfGlyphs;r++)this.names[r]=Oe[r+e.glyphNameIndex[r]];break;default:this.names=[]}}function we(e,t){t.lowMemory?function(e){e._IndexToUnicodeMap={};for(var t=e.tables.cmap.glyphIndexMap,r=Object.keys(t),n=0;n<r.length;n+=1){var a=r[n],o=t[a];void 0===e._IndexToUnicodeMap[o]?e._IndexToUnicodeMap[o]={unicodes:[parseInt(a)]}:e._IndexToUnicodeMap[o].unicodes.push(parseInt(a))}}(e):function(e){for(var t,r=e.tables.cmap.glyphIndexMap,n=Object.keys(r),a=0;a<n.length;a+=1){var o=n[a],s=r[o];(t=e.glyphs.get(s)).addUnicode(parseInt(o))}for(var i=0;i<e.glyphs.length;i+=1)t=e.glyphs.get(i),e.cffEncoding?e.isCIDFont?t.name="gid"+i:t.name=e.cffEncoding.charset[i]:e.glyphNames.names&&(t.name=e.glyphNames.glyphIndexToName(i))}(e)}Re.prototype.charToGlyphIndex=function(e){var t=e.codePointAt(0),r=this.font.glyphs;if(r)for(var n=0;n<r.length;n+=1)for(var a=r.get(n),o=0;o<a.unicodes.length;o+=1)if(a.unicodes[o]===t)return n;return null},Ee.prototype.charToGlyphIndex=function(e){return this.cmap.glyphIndexMap[e.codePointAt(0)]||0},Le.prototype.charToGlyphIndex=function(e){var t=e.codePointAt(0),r=this.encoding[t];return this.charset.indexOf(r)},Ce.prototype.nameToGlyphIndex=function(e){return this.names.indexOf(e)},Ce.prototype.glyphIndexToName=function(e){return this.names[e]};var De={line:function(e,t,r,n,a){e.beginPath(),e.moveTo(t,r),e.lineTo(n,a),e.stroke()}};function Ie(e){this.bindConstructorValues(e)}function Ge(e,t,r){Object.defineProperty(e,t,{get:function(){return e.path,e[r]},set:function(t){e[r]=t},enumerable:!0,configurable:!0})}function Me(e,t){if(this.font=e,this.glyphs={},Array.isArray(t))for(var r=0;r<t.length;r++){var n=t[r];n.path.unitsPerEm=e.unitsPerEm,this.glyphs[r]=n}this.length=t&&t.length||0}Ie.prototype.bindConstructorValues=function(e){var t,r;this.index=e.index||0,this.name=e.name||null,this.unicode=e.unicode||void 0,this.unicodes=e.unicodes||void 0!==e.unicode?[e.unicode]:[],"xMin"in e&&(this.xMin=e.xMin),"yMin"in e&&(this.yMin=e.yMin),"xMax"in e&&(this.xMax=e.xMax),"yMax"in e&&(this.yMax=e.yMax),"advanceWidth"in e&&(this.advanceWidth=e.advanceWidth),Object.defineProperty(this,"path",(t=e.path,r=t||new E,{configurable:!0,get:function(){return"function"==typeof r&&(r=r()),r},set:function(e){r=e}}))},Ie.prototype.addUnicode=function(e){0===this.unicodes.length&&(this.unicode=e),this.unicodes.push(e)},Ie.prototype.getBoundingBox=function(){return this.path.getBoundingBox()},Ie.prototype.getPath=function(e,t,r,n,a){var o,s;e=void 0!==e?e:0,t=void 0!==t?t:0,r=void 0!==r?r:72,n||(n={});var i=n.xScale,u=n.yScale;if(n.hinting&&a&&a.hinting&&(s=this.path&&a.hinting.exec(this,r)),s)o=a.hinting.getCommands(s),e=Math.round(e),t=Math.round(t),i=u=1;else{o=this.path.commands;var l=1/(this.path.unitsPerEm||1e3)*r;void 0===i&&(i=l),void 0===u&&(u=l)}for(var p=new E,c=0;c<o.length;c+=1){var h=o[c];"M"===h.type?p.moveTo(e+h.x*i,t+-h.y*u):"L"===h.type?p.lineTo(e+h.x*i,t+-h.y*u):"Q"===h.type?p.quadraticCurveTo(e+h.x1*i,t+-h.y1*u,e+h.x*i,t+-h.y*u):"C"===h.type?p.curveTo(e+h.x1*i,t+-h.y1*u,e+h.x2*i,t+-h.y2*u,e+h.x*i,t+-h.y*u):"Z"===h.type&&p.closePath()}return p},Ie.prototype.getContours=function(){if(void 0===this.points)return[];for(var e=[],t=[],r=0;r<this.points.length;r+=1){var n=this.points[r];t.push(n),n.lastPointOfContour&&(e.push(t),t=[])}return w.argument(0===t.length,"There are still points left in the current contour."),e},Ie.prototype.getMetrics=function(){for(var e=this.path.commands,t=[],r=[],n=0;n<e.length;n+=1){var a=e[n];"Z"!==a.type&&(t.push(a.x),r.push(a.y)),"Q"!==a.type&&"C"!==a.type||(t.push(a.x1),r.push(a.y1)),"C"===a.type&&(t.push(a.x2),r.push(a.y2))}var o={xMin:Math.min.apply(null,t),yMin:Math.min.apply(null,r),xMax:Math.max.apply(null,t),yMax:Math.max.apply(null,r),leftSideBearing:this.leftSideBearing};return isFinite(o.xMin)||(o.xMin=0),isFinite(o.xMax)||(o.xMax=this.advanceWidth),isFinite(o.yMin)||(o.yMin=0),isFinite(o.yMax)||(o.yMax=0),o.rightSideBearing=this.advanceWidth-o.leftSideBearing-(o.xMax-o.xMin),o},Ie.prototype.draw=function(e,t,r,n,a){this.getPath(t,r,n,a).draw(e)},Ie.prototype.drawPoints=function(e,t,r,n){function a(t,r,n,a){e.beginPath();for(var o=0;o<t.length;o+=1)e.moveTo(r+t[o].x*a,n+t[o].y*a),e.arc(r+t[o].x*a,n+t[o].y*a,2,0,2*Math.PI,!1);e.closePath(),e.fill()}t=void 0!==t?t:0,r=void 0!==r?r:0,n=void 0!==n?n:24;for(var o=1/this.path.unitsPerEm*n,s=[],i=[],u=this.path,l=0;l<u.commands.length;l+=1){var p=u.commands[l];void 0!==p.x&&s.push({x:p.x,y:-p.y}),void 0!==p.x1&&i.push({x:p.x1,y:-p.y1}),void 0!==p.x2&&i.push({x:p.x2,y:-p.y2})}e.fillStyle="blue",a(s,t,r,o),e.fillStyle="red",a(i,t,r,o)},Ie.prototype.drawMetrics=function(e,t,r,n){var a;t=void 0!==t?t:0,r=void 0!==r?r:0,n=void 0!==n?n:24,a=1/this.path.unitsPerEm*n,e.lineWidth=1,e.strokeStyle="black",De.line(e,t,-1e4,t,1e4),De.line(e,-1e4,r,1e4,r);var o=this.xMin||0,s=this.yMin||0,i=this.xMax||0,u=this.yMax||0,l=this.advanceWidth||0;e.strokeStyle="blue",De.line(e,t+o*a,-1e4,t+o*a,1e4),De.line(e,t+i*a,-1e4,t+i*a,1e4),De.line(e,-1e4,r+-s*a,1e4,r+-s*a),De.line(e,-1e4,r+-u*a,1e4,r+-u*a),e.strokeStyle="green",De.line(e,t+l*a,-1e4,t+l*a,1e4)},Me.prototype.get=function(e){if(void 0===this.glyphs[e]&&"number"==typeof e){this.font._push(e),"function"==typeof this.glyphs[e]&&(this.glyphs[e]=this.glyphs[e]());var t=this.glyphs[e],r=this.font._IndexToUnicodeMap[e];if(r)for(var n=0;n<r.unicodes.length;n++)t.addUnicode(r.unicodes[n]);this.font.cffEncoding?this.font.isCIDFont?t.name="gid"+e:t.name=this.font.cffEncoding.charset[e]:this.font.glyphNames.names&&(t.name=this.font.glyphNames.glyphIndexToName(e)),this.glyphs[e].advanceWidth=this.font._hmtxTableData[e].advanceWidth,this.glyphs[e].leftSideBearing=this.font._hmtxTableData[e].leftSideBearing}else"function"==typeof this.glyphs[e]&&(this.glyphs[e]=this.glyphs[e]());return this.glyphs[e]},Me.prototype.push=function(e,t){this.glyphs[e]=t,this.length++};var Be={GlyphSet:Me,glyphLoader:function(e,t){return new Ie({index:t,font:e})},ttfGlyphLoader:function(e,t,r,n,a,o){return function(){var s=new Ie({index:t,font:e});return s.path=function(){r(s,n,a);var t=o(e.glyphs,s);return t.unitsPerEm=e.unitsPerEm,t},Ge(s,"xMin","_xMin"),Ge(s,"xMax","_xMax"),Ge(s,"yMin","_yMin"),Ge(s,"yMax","_yMax"),s}},cffGlyphLoader:function(e,t,r,n){return function(){var a=new Ie({index:t,font:e});return a.path=function(){var t=r(e,a,n);return t.unitsPerEm=e.unitsPerEm,t},a}}};function Fe(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r+=1)if(!Fe(e[r],t[r]))return!1;return!0}return!1}function Pe(e){return e.length<1240?107:e.length<33900?1131:32768}function Ae(e,t,r){var n,a,o=[],s=[],i=se.getCard16(e,t);if(0!==i){var u=se.getByte(e,t+2);n=t+(i+1)*u+2;for(var l=t+3,p=0;p<i+1;p+=1)o.push(se.getOffset(e,l,u)),l+=u;a=n+o[i]}else a=t+2;for(var c=0;c<o.length-1;c+=1){var h=se.getBytes(e,n+o[c],n+o[c+1]);r&&(h=r(h)),s.push(h)}return{objects:s,startOffset:t,endOffset:a}}function Ne(e,t){if(28===t)return e.parseByte()<<8|e.parseByte();if(29===t)return e.parseByte()<<24|e.parseByte()<<16|e.parseByte()<<8|e.parseByte();if(30===t)return function(e){for(var t="",r=["0","1","2","3","4","5","6","7","8","9",".","E","E-",null,"-"];;){var n=e.parseByte(),a=n>>4,o=15&n;if(15===a)break;if(t+=r[a],15===o)break;t+=r[o]}return parseFloat(t)}(e);if(t>=32&&t<=246)return t-139;if(t>=247&&t<=250)return 256*(t-247)+e.parseByte()+108;if(t>=251&&t<=254)return 256*-(t-251)-e.parseByte()-108;throw new Error("Invalid b0 "+t)}function He(e,t,r){t=void 0!==t?t:0;var n=new se.Parser(e,t),a=[],o=[];for(r=void 0!==r?r:e.length;n.relativeOffset<r;){var s=n.parseByte();s<=21?(12===s&&(s=1200+n.parseByte()),a.push([s,o]),o=[]):o.push(Ne(n,s))}return function(e){for(var t={},r=0;r<e.length;r+=1){var n=e[r][0],a=e[r][1],o=void 0;if(o=1===a.length?a[0]:a,t.hasOwnProperty(n)&&!isNaN(t[n]))throw new Error("Object "+t+" already has key "+n);t[n]=o}return t}(a)}function ze(e,t){return t=t<=390?Te[t]:e[t-391]}function We(e,t,r){for(var n,a={},o=0;o<t.length;o+=1){var s=t[o];if(Array.isArray(s.type)){var i=[];i.length=s.type.length;for(var u=0;u<s.type.length;u++)void 0===(n=void 0!==e[s.op]?e[s.op][u]:void 0)&&(n=void 0!==s.value&&void 0!==s.value[u]?s.value[u]:null),"SID"===s.type[u]&&(n=ze(r,n)),i[u]=n;a[s.name]=i}else void 0===(n=e[s.op])&&(n=void 0!==s.value?s.value:null),"SID"===s.type&&(n=ze(r,n)),a[s.name]=n}return a}var qe=[{name:"version",op:0,type:"SID"},{name:"notice",op:1,type:"SID"},{name:"copyright",op:1200,type:"SID"},{name:"fullName",op:2,type:"SID"},{name:"familyName",op:3,type:"SID"},{name:"weight",op:4,type:"SID"},{name:"isFixedPitch",op:1201,type:"number",value:0},{name:"italicAngle",op:1202,type:"number",value:0},{name:"underlinePosition",op:1203,type:"number",value:-100},{name:"underlineThickness",op:1204,type:"number",value:50},{name:"paintType",op:1205,type:"number",value:0},{name:"charstringType",op:1206,type:"number",value:2},{name:"fontMatrix",op:1207,type:["real","real","real","real","real","real"],value:[.001,0,0,.001,0,0]},{name:"uniqueId",op:13,type:"number"},{name:"fontBBox",op:5,type:["number","number","number","number"],value:[0,0,0,0]},{name:"strokeWidth",op:1208,type:"number",value:0},{name:"xuid",op:14,type:[],value:null},{name:"charset",op:15,type:"offset",value:0},{name:"encoding",op:16,type:"offset",value:0},{name:"charStrings",op:17,type:"offset",value:0},{name:"private",op:18,type:["number","offset"],value:[0,0]},{name:"ros",op:1230,type:["SID","SID","number"]},{name:"cidFontVersion",op:1231,type:"number",value:0},{name:"cidFontRevision",op:1232,type:"number",value:0},{name:"cidFontType",op:1233,type:"number",value:0},{name:"cidCount",op:1234,type:"number",value:8720},{name:"uidBase",op:1235,type:"number"},{name:"fdArray",op:1236,type:"offset"},{name:"fdSelect",op:1237,type:"offset"},{name:"fontName",op:1238,type:"SID"}],_e=[{name:"subrs",op:19,type:"offset",value:0},{name:"defaultWidthX",op:20,type:"number",value:0},{name:"nominalWidthX",op:21,type:"number",value:0}];function Xe(e,t){return We(He(e,0,e.byteLength),qe,t)}function Ve(e,t,r,n){return We(He(e,t,r),_e,n)}function je(e,t,r,n){for(var a=[],o=0;o<r.length;o+=1){var s=Xe(new DataView(new Uint8Array(r[o]).buffer),n);s._subrs=[],s._subrsBias=0,s._defaultWidthX=0,s._nominalWidthX=0;var i=s.private[0],u=s.private[1];if(0!==i&&0!==u){var l=Ve(e,u+t,i,n);if(s._defaultWidthX=l.defaultWidthX,s._nominalWidthX=l.nominalWidthX,0!==l.subrs){var p=Ae(e,u+l.subrs+t);s._subrs=p.objects,s._subrsBias=Pe(s._subrs)}s._privateDict=l}a.push(s)}return a}function Ye(e,t,r){var n,a,o,s,i,u,l,p,c=new E,h=[],f=0,d=!1,v=!1,g=0,m=0;if(e.isCIDFont){var y=e.tables.cff.topDict._fdSelect[t.index],b=e.tables.cff.topDict._fdArray[y];i=b._subrs,u=b._subrsBias,l=b._defaultWidthX,p=b._nominalWidthX}else i=e.tables.cff.topDict._subrs,u=e.tables.cff.topDict._subrsBias,l=e.tables.cff.topDict._defaultWidthX,p=e.tables.cff.topDict._nominalWidthX;var S=l;function x(e,t){v&&c.closePath(),c.moveTo(e,t),v=!0}function T(){h.length%2!=0&&!d&&(S=h.shift()+p),f+=h.length>>1,h.length=0,d=!0}return function r(l){for(var y,b,U,k,O,R,E,L,C,w,D,I,G=0;G<l.length;){var M=l[G];switch(G+=1,M){case 1:case 3:case 18:case 23:T();break;case 4:h.length>1&&!d&&(S=h.shift()+p,d=!0),m+=h.pop(),x(g,m);break;case 5:for(;h.length>0;)g+=h.shift(),m+=h.shift(),c.lineTo(g,m);break;case 6:for(;h.length>0&&(g+=h.shift(),c.lineTo(g,m),0!==h.length);)m+=h.shift(),c.lineTo(g,m);break;case 7:for(;h.length>0&&(m+=h.shift(),c.lineTo(g,m),0!==h.length);)g+=h.shift(),c.lineTo(g,m);break;case 8:for(;h.length>0;)n=g+h.shift(),a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),g=o+h.shift(),m=s+h.shift(),c.curveTo(n,a,o,s,g,m);break;case 10:O=h.pop()+u,(R=i[O])&&r(R);break;case 11:return;case 12:switch(M=l[G],G+=1,M){case 35:n=g+h.shift(),a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),E=o+h.shift(),L=s+h.shift(),C=E+h.shift(),w=L+h.shift(),D=C+h.shift(),I=w+h.shift(),g=D+h.shift(),m=I+h.shift(),h.shift(),c.curveTo(n,a,o,s,E,L),c.curveTo(C,w,D,I,g,m);break;case 34:n=g+h.shift(),a=m,o=n+h.shift(),s=a+h.shift(),E=o+h.shift(),L=s,C=E+h.shift(),w=s,D=C+h.shift(),I=m,g=D+h.shift(),c.curveTo(n,a,o,s,E,L),c.curveTo(C,w,D,I,g,m);break;case 36:n=g+h.shift(),a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),E=o+h.shift(),L=s,C=E+h.shift(),w=s,D=C+h.shift(),I=w+h.shift(),g=D+h.shift(),c.curveTo(n,a,o,s,E,L),c.curveTo(C,w,D,I,g,m);break;case 37:n=g+h.shift(),a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),E=o+h.shift(),L=s+h.shift(),C=E+h.shift(),w=L+h.shift(),D=C+h.shift(),I=w+h.shift(),Math.abs(D-g)>Math.abs(I-m)?g=D+h.shift():m=I+h.shift(),c.curveTo(n,a,o,s,E,L),c.curveTo(C,w,D,I,g,m);break;default:console.log("Glyph "+t.index+": unknown operator 1200"+M),h.length=0}break;case 14:h.length>0&&!d&&(S=h.shift()+p,d=!0),v&&(c.closePath(),v=!1);break;case 19:case 20:T(),G+=f+7>>3;break;case 21:h.length>2&&!d&&(S=h.shift()+p,d=!0),m+=h.pop(),x(g+=h.pop(),m);break;case 22:h.length>1&&!d&&(S=h.shift()+p,d=!0),x(g+=h.pop(),m);break;case 24:for(;h.length>2;)n=g+h.shift(),a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),g=o+h.shift(),m=s+h.shift(),c.curveTo(n,a,o,s,g,m);g+=h.shift(),m+=h.shift(),c.lineTo(g,m);break;case 25:for(;h.length>6;)g+=h.shift(),m+=h.shift(),c.lineTo(g,m);n=g+h.shift(),a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),g=o+h.shift(),m=s+h.shift(),c.curveTo(n,a,o,s,g,m);break;case 26:for(h.length%2&&(g+=h.shift());h.length>0;)n=g,a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),g=o,m=s+h.shift(),c.curveTo(n,a,o,s,g,m);break;case 27:for(h.length%2&&(m+=h.shift());h.length>0;)n=g+h.shift(),a=m,o=n+h.shift(),s=a+h.shift(),g=o+h.shift(),m=s,c.curveTo(n,a,o,s,g,m);break;case 28:y=l[G],b=l[G+1],h.push((y<<24|b<<16)>>16),G+=2;break;case 29:O=h.pop()+e.gsubrsBias,(R=e.gsubrs[O])&&r(R);break;case 30:for(;h.length>0&&(n=g,a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),g=o+h.shift(),m=s+(1===h.length?h.shift():0),c.curveTo(n,a,o,s,g,m),0!==h.length);)n=g+h.shift(),a=m,o=n+h.shift(),s=a+h.shift(),m=s+h.shift(),g=o+(1===h.length?h.shift():0),c.curveTo(n,a,o,s,g,m);break;case 31:for(;h.length>0&&(n=g+h.shift(),a=m,o=n+h.shift(),s=a+h.shift(),m=s+h.shift(),g=o+(1===h.length?h.shift():0),c.curveTo(n,a,o,s,g,m),0!==h.length);)n=g,a=m+h.shift(),o=n+h.shift(),s=a+h.shift(),g=o+h.shift(),m=s+(1===h.length?h.shift():0),c.curveTo(n,a,o,s,g,m);break;default:M<32?console.log("Glyph "+t.index+": unknown operator "+M):M<247?h.push(M-139):M<251?(y=l[G],G+=1,h.push(256*(M-247)+y+108)):M<255?(y=l[G],G+=1,h.push(256*-(M-251)-y-108)):(y=l[G],b=l[G+1],U=l[G+2],k=l[G+3],G+=4,h.push((y<<24|b<<16|U<<8|k)/65536))}}}(r),t.advanceWidth=S,c}function Ze(e,t){var r,n=Te.indexOf(e);return n>=0&&(r=n),(n=t.indexOf(e))>=0?r=n+Te.length:(r=Te.length+t.length,t.push(e)),r}function Qe(e,t,r){for(var n={},a=0;a<e.length;a+=1){var o=e[a],s=t[o.name];void 0===s||Fe(s,o.value)||("SID"===o.type&&(s=Ze(s,r)),n[o.op]={name:o.name,type:o.type,value:s})}return n}function Ke(e,t){var r=new J.Record("Top DICT",[{name:"dict",type:"DICT",value:{}}]);return r.dict=Qe(qe,e,t),r}function Je(e){var t=new J.Record("Top DICT INDEX",[{name:"topDicts",type:"INDEX",value:[]}]);return t.topDicts=[{name:"topDict_0",type:"TABLE",value:e}],t}function $e(e){var t=[],r=e.path;t.push({name:"width",type:"NUMBER",value:e.advanceWidth});for(var n=0,a=0,o=0;o<r.commands.length;o+=1){var s=void 0,i=void 0,u=r.commands[o];if("Q"===u.type){var l=1/3,p=2/3;u={type:"C",x:u.x,y:u.y,x1:Math.round(l*n+p*u.x1),y1:Math.round(l*a+p*u.y1),x2:Math.round(l*u.x+p*u.x1),y2:Math.round(l*u.y+p*u.y1)}}if("M"===u.type)s=Math.round(u.x-n),i=Math.round(u.y-a),t.push({name:"dx",type:"NUMBER",value:s}),t.push({name:"dy",type:"NUMBER",value:i}),t.push({name:"rmoveto",type:"OP",value:21}),n=Math.round(u.x),a=Math.round(u.y);else if("L"===u.type)s=Math.round(u.x-n),i=Math.round(u.y-a),t.push({name:"dx",type:"NUMBER",value:s}),t.push({name:"dy",type:"NUMBER",value:i}),t.push({name:"rlineto",type:"OP",value:5}),n=Math.round(u.x),a=Math.round(u.y);else if("C"===u.type){var c=Math.round(u.x1-n),h=Math.round(u.y1-a),f=Math.round(u.x2-u.x1),d=Math.round(u.y2-u.y1);s=Math.round(u.x-u.x2),i=Math.round(u.y-u.y2),t.push({name:"dx1",type:"NUMBER",value:c}),t.push({name:"dy1",type:"NUMBER",value:h}),t.push({name:"dx2",type:"NUMBER",value:f}),t.push({name:"dy2",type:"NUMBER",value:d}),t.push({name:"dx",type:"NUMBER",value:s}),t.push({name:"dy",type:"NUMBER",value:i}),t.push({name:"rrcurveto",type:"OP",value:8}),n=Math.round(u.x),a=Math.round(u.y)}}return t.push({name:"endchar",type:"OP",value:14}),t}var et={parse:function(e,t,r,n){r.tables.cff={};var a=function(e,t){var r={};return r.formatMajor=se.getCard8(e,t),r.formatMinor=se.getCard8(e,t+1),r.size=se.getCard8(e,t+2),r.offsetSize=se.getCard8(e,t+3),r.startOffset=t,r.endOffset=t+4,r}(e,t),o=Ae(e,a.endOffset,se.bytesToString),s=Ae(e,o.endOffset),i=Ae(e,s.endOffset,se.bytesToString),u=Ae(e,i.endOffset);r.gsubrs=u.objects,r.gsubrsBias=Pe(r.gsubrs);var l=je(e,t,s.objects,i.objects);if(1!==l.length)throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = "+l.length);var p=l[0];if(r.tables.cff.topDict=p,p._privateDict&&(r.defaultWidthX=p._privateDict.defaultWidthX,r.nominalWidthX=p._privateDict.nominalWidthX),void 0!==p.ros[0]&&void 0!==p.ros[1]&&(r.isCIDFont=!0),r.isCIDFont){var c=p.fdArray,h=p.fdSelect;if(0===c||0===h)throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");var f=Ae(e,c+=t),d=je(e,t,f.objects,i.objects);p._fdArray=d,h+=t,p._fdSelect=function(e,t,r,n){var a,o=[],s=new se.Parser(e,t),i=s.parseCard8();if(0===i)for(var u=0;u<r;u++){if((a=s.parseCard8())>=n)throw new Error("CFF table CID Font FDSelect has bad FD index value "+a+" (FD count "+n+")");o.push(a)}else{if(3!==i)throw new Error("CFF Table CID Font FDSelect table has unsupported format "+i);var l,p=s.parseCard16(),c=s.parseCard16();if(0!==c)throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID "+c);for(var h=0;h<p;h++){if(a=s.parseCard8(),l=s.parseCard16(),a>=n)throw new Error("CFF table CID Font FDSelect has bad FD index value "+a+" (FD count "+n+")");if(l>r)throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID "+l);for(;c<l;c++)o.push(a);c=l}if(l!==r)throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID "+l)}return o}(e,h,r.numGlyphs,d.length)}var v,g=t+p.private[1],m=Ve(e,g,p.private[0],i.objects);if(r.defaultWidthX=m.defaultWidthX,r.nominalWidthX=m.nominalWidthX,0!==m.subrs){var y=g+m.subrs,b=Ae(e,y);r.subrs=b.objects,r.subrsBias=Pe(r.subrs)}else r.subrs=[],r.subrsBias=0;n.lowMemory?(v=function(e,t){var r,n,a=[],o=se.getCard16(e,t);if(0!==o){var s=se.getByte(e,t+2);r=t+(o+1)*s+2;for(var i=t+3,u=0;u<o+1;u+=1)a.push(se.getOffset(e,i,s)),i+=s;n=r+a[o]}else n=t+2;return{offsets:a,startOffset:t,endOffset:n}}(e,t+p.charStrings),r.nGlyphs=v.offsets.length):(v=Ae(e,t+p.charStrings),r.nGlyphs=v.objects.length);var S=function(e,t,r,n){var a,o,s=new se.Parser(e,t);r-=1;var i=[".notdef"],u=s.parseCard8();if(0===u)for(var l=0;l<r;l+=1)a=s.parseSID(),i.push(ze(n,a));else if(1===u)for(;i.length<=r;){a=s.parseSID(),o=s.parseCard8();for(var p=0;p<=o;p+=1)i.push(ze(n,a)),a+=1}else{if(2!==u)throw new Error("Unknown charset format "+u);for(;i.length<=r;){a=s.parseSID(),o=s.parseCard16();for(var c=0;c<=o;c+=1)i.push(ze(n,a)),a+=1}}return i}(e,t+p.charset,r.nGlyphs,i.objects);if(0===p.encoding?r.cffEncoding=new Le(Ue,S):1===p.encoding?r.cffEncoding=new Le(ke,S):r.cffEncoding=function(e,t,r){var n,a={},o=new se.Parser(e,t),s=o.parseCard8();if(0===s)for(var i=o.parseCard8(),u=0;u<i;u+=1)a[n=o.parseCard8()]=u;else{if(1!==s)throw new Error("Unknown encoding format "+s);var l=o.parseCard8();n=1;for(var p=0;p<l;p+=1)for(var c=o.parseCard8(),h=o.parseCard8(),f=c;f<=c+h;f+=1)a[f]=n,n+=1}return new Le(a,r)}(e,t+p.encoding,S),r.encoding=r.encoding||r.cffEncoding,r.glyphs=new Be.GlyphSet(r),n.lowMemory)r._push=function(n){var a=function(e,t,r,n,a){var o=se.getCard16(r,n),s=0;0!==o&&(s=n+(o+1)*se.getByte(r,n+2)+2);var i=se.getBytes(r,s+t[e],s+t[e+1]);return a&&(i=a(i)),i}(n,v.offsets,e,t+p.charStrings);r.glyphs.push(n,Be.cffGlyphLoader(r,n,Ye,a))};else for(var x=0;x<r.nGlyphs;x+=1){var T=v.objects[x];r.glyphs.push(x,Be.cffGlyphLoader(r,x,Ye,T))}},make:function(e,t){for(var r,n=new J.Table("CFF ",[{name:"header",type:"RECORD"},{name:"nameIndex",type:"RECORD"},{name:"topDictIndex",type:"RECORD"},{name:"stringIndex",type:"RECORD"},{name:"globalSubrIndex",type:"RECORD"},{name:"charsets",type:"RECORD"},{name:"charStringsIndex",type:"RECORD"},{name:"privateDict",type:"RECORD"}]),a=1/t.unitsPerEm,o={version:t.version,fullName:t.fullName,familyName:t.familyName,weight:t.weightName,fontBBox:t.fontBBox||[0,0,0,0],fontMatrix:[a,0,0,a,0,0],charset:999,encoding:0,charStrings:999,private:[0,999]},s=[],i=1;i<e.length;i+=1)r=e.get(i),s.push(r.name);var u=[];n.header=new J.Record("Header",[{name:"major",type:"Card8",value:1},{name:"minor",type:"Card8",value:0},{name:"hdrSize",type:"Card8",value:4},{name:"major",type:"Card8",value:1}]),n.nameIndex=function(e){var t=new J.Record("Name INDEX",[{name:"names",type:"INDEX",value:[]}]);t.names=[];for(var r=0;r<e.length;r+=1)t.names.push({name:"name_"+r,type:"NAME",value:e[r]});return t}([t.postScriptName]);var l=Ke(o,u);n.topDictIndex=Je(l),n.globalSubrIndex=new J.Record("Global Subr INDEX",[{name:"subrs",type:"INDEX",value:[]}]),n.charsets=function(e,t){for(var r=new J.Record("Charsets",[{name:"format",type:"Card8",value:0}]),n=0;n<e.length;n+=1){var a=Ze(e[n],t);r.fields.push({name:"glyph_"+n,type:"SID",value:a})}return r}(s,u),n.charStringsIndex=function(e){for(var t=new J.Record("CharStrings INDEX",[{name:"charStrings",type:"INDEX",value:[]}]),r=0;r<e.length;r+=1){var n=e.get(r),a=$e(n);t.charStrings.push({name:n.name,type:"CHARSTRING",value:a})}return t}(e),n.privateDict=function(e,t){var r=new J.Record("Private DICT",[{name:"dict",type:"DICT",value:{}}]);return r.dict=Qe(_e,e,t),r}({},u),n.stringIndex=function(e){var t=new J.Record("String INDEX",[{name:"strings",type:"INDEX",value:[]}]);t.strings=[];for(var r=0;r<e.length;r+=1)t.strings.push({name:"string_"+r,type:"STRING",value:e[r]});return t}(u);var p=n.header.sizeOf()+n.nameIndex.sizeOf()+n.topDictIndex.sizeOf()+n.stringIndex.sizeOf()+n.globalSubrIndex.sizeOf();return o.charset=p,o.encoding=0,o.charStrings=o.charset+n.charsets.sizeOf(),o.private[1]=o.charStrings+n.charStringsIndex.sizeOf(),l=Ke(o,u),n.topDictIndex=Je(l),n}};var tt={parse:function(e,t){var r={},n=new se.Parser(e,t);return r.version=n.parseVersion(),r.fontRevision=Math.round(1e3*n.parseFixed())/1e3,r.checkSumAdjustment=n.parseULong(),r.magicNumber=n.parseULong(),w.argument(1594834165===r.magicNumber,"Font header has wrong magic number."),r.flags=n.parseUShort(),r.unitsPerEm=n.parseUShort(),r.created=n.parseLongDateTime(),r.modified=n.parseLongDateTime(),r.xMin=n.parseShort(),r.yMin=n.parseShort(),r.xMax=n.parseShort(),r.yMax=n.parseShort(),r.macStyle=n.parseUShort(),r.lowestRecPPEM=n.parseUShort(),r.fontDirectionHint=n.parseShort(),r.indexToLocFormat=n.parseShort(),r.glyphDataFormat=n.parseShort(),r},make:function(e){var t=Math.round((new Date).getTime()/1e3)+2082844800,r=t;return e.createdTimestamp&&(r=e.createdTimestamp+2082844800),new J.Table("head",[{name:"version",type:"FIXED",value:65536},{name:"fontRevision",type:"FIXED",value:65536},{name:"checkSumAdjustment",type:"ULONG",value:0},{name:"magicNumber",type:"ULONG",value:1594834165},{name:"flags",type:"USHORT",value:0},{name:"unitsPerEm",type:"USHORT",value:1e3},{name:"created",type:"LONGDATETIME",value:r},{name:"modified",type:"LONGDATETIME",value:t},{name:"xMin",type:"SHORT",value:0},{name:"yMin",type:"SHORT",value:0},{name:"xMax",type:"SHORT",value:0},{name:"yMax",type:"SHORT",value:0},{name:"macStyle",type:"USHORT",value:0},{name:"lowestRecPPEM",type:"USHORT",value:0},{name:"fontDirectionHint",type:"SHORT",value:2},{name:"indexToLocFormat",type:"SHORT",value:0},{name:"glyphDataFormat",type:"SHORT",value:0}],e)}};var rt={parse:function(e,t){var r={},n=new se.Parser(e,t);return r.version=n.parseVersion(),r.ascender=n.parseShort(),r.descender=n.parseShort(),r.lineGap=n.parseShort(),r.advanceWidthMax=n.parseUShort(),r.minLeftSideBearing=n.parseShort(),r.minRightSideBearing=n.parseShort(),r.xMaxExtent=n.parseShort(),r.caretSlopeRise=n.parseShort(),r.caretSlopeRun=n.parseShort(),r.caretOffset=n.parseShort(),n.relativeOffset+=8,r.metricDataFormat=n.parseShort(),r.numberOfHMetrics=n.parseUShort(),r},make:function(e){return new J.Table("hhea",[{name:"version",type:"FIXED",value:65536},{name:"ascender",type:"FWORD",value:0},{name:"descender",type:"FWORD",value:0},{name:"lineGap",type:"FWORD",value:0},{name:"advanceWidthMax",type:"UFWORD",value:0},{name:"minLeftSideBearing",type:"FWORD",value:0},{name:"minRightSideBearing",type:"FWORD",value:0},{name:"xMaxExtent",type:"FWORD",value:0},{name:"caretSlopeRise",type:"SHORT",value:1},{name:"caretSlopeRun",type:"SHORT",value:0},{name:"caretOffset",type:"SHORT",value:0},{name:"reserved1",type:"SHORT",value:0},{name:"reserved2",type:"SHORT",value:0},{name:"reserved3",type:"SHORT",value:0},{name:"reserved4",type:"SHORT",value:0},{name:"metricDataFormat",type:"SHORT",value:0},{name:"numberOfHMetrics",type:"USHORT",value:0}],e)}};var nt={parse:function(e,t,r,n,a,o,s){s.lowMemory?function(e,t,r,n,a){var o,s;e._hmtxTableData={};for(var i=new se.Parser(t,r),u=0;u<a;u+=1)u<n&&(o=i.parseUShort(),s=i.parseShort()),e._hmtxTableData[u]={advanceWidth:o,leftSideBearing:s}}(e,t,r,n,a):function(e,t,r,n,a){for(var o,s,i=new se.Parser(e,t),u=0;u<n;u+=1){u<r&&(o=i.parseUShort(),s=i.parseShort());var l=a.get(u);l.advanceWidth=o,l.leftSideBearing=s}}(t,r,n,a,o)},make:function(e){for(var t=new J.Table("hmtx",[]),r=0;r<e.length;r+=1){var n=e.get(r),a=n.advanceWidth||0,o=n.leftSideBearing||0;t.fields.push({name:"advanceWidth_"+r,type:"USHORT",value:a}),t.fields.push({name:"leftSideBearing_"+r,type:"SHORT",value:o})}return t}};var at={make:function(e){for(var t=new J.Table("ltag",[{name:"version",type:"ULONG",value:1},{name:"flags",type:"ULONG",value:0},{name:"numTags",type:"ULONG",value:e.length}]),r="",n=12+4*e.length,a=0;a<e.length;++a){var o=r.indexOf(e[a]);o<0&&(o=r.length,r+=e[a]),t.fields.push({name:"offset "+a,type:"USHORT",value:n+o}),t.fields.push({name:"length "+a,type:"USHORT",value:e[a].length})}return t.fields.push({name:"stringPool",type:"CHARARRAY",value:r}),t},parse:function(e,t){var r=new se.Parser(e,t),n=r.parseULong();w.argument(1===n,"Unsupported ltag table version."),r.skip("uLong",1);for(var a=r.parseULong(),o=[],s=0;s<a;s++){for(var i="",u=t+r.parseUShort(),l=r.parseUShort(),p=u;p<u+l;++p)i+=String.fromCharCode(e.getInt8(p));o.push(i)}return o}};var ot={parse:function(e,t){var r={},n=new se.Parser(e,t);return r.version=n.parseVersion(),r.numGlyphs=n.parseUShort(),1===r.version&&(r.maxPoints=n.parseUShort(),r.maxContours=n.parseUShort(),r.maxCompositePoints=n.parseUShort(),r.maxCompositeContours=n.parseUShort(),r.maxZones=n.parseUShort(),r.maxTwilightPoints=n.parseUShort(),r.maxStorage=n.parseUShort(),r.maxFunctionDefs=n.parseUShort(),r.maxInstructionDefs=n.parseUShort(),r.maxStackElements=n.parseUShort(),r.maxSizeOfInstructions=n.parseUShort(),r.maxComponentElements=n.parseUShort(),r.maxComponentDepth=n.parseUShort()),r},make:function(e){return new J.Table("maxp",[{name:"version",type:"FIXED",value:20480},{name:"numGlyphs",type:"USHORT",value:e}])}},st=[{begin:0,end:127},{begin:128,end:255},{begin:256,end:383},{begin:384,end:591},{begin:592,end:687},{begin:688,end:767},{begin:768,end:879},{begin:880,end:1023},{begin:11392,end:11519},{begin:1024,end:1279},{begin:1328,end:1423},{begin:1424,end:1535},{begin:42240,end:42559},{begin:1536,end:1791},{begin:1984,end:2047},{begin:2304,end:2431},{begin:2432,end:2559},{begin:2560,end:2687},{begin:2688,end:2815},{begin:2816,end:2943},{begin:2944,end:3071},{begin:3072,end:3199},{begin:3200,end:3327},{begin:3328,end:3455},{begin:3584,end:3711},{begin:3712,end:3839},{begin:4256,end:4351},{begin:6912,end:7039},{begin:4352,end:4607},{begin:7680,end:7935},{begin:7936,end:8191},{begin:8192,end:8303},{begin:8304,end:8351},{begin:8352,end:8399},{begin:8400,end:8447},{begin:8448,end:8527},{begin:8528,end:8591},{begin:8592,end:8703},{begin:8704,end:8959},{begin:8960,end:9215},{begin:9216,end:9279},{begin:9280,end:9311},{begin:9312,end:9471},{begin:9472,end:9599},{begin:9600,end:9631},{begin:9632,end:9727},{begin:9728,end:9983},{begin:9984,end:10175},{begin:12288,end:12351},{begin:12352,end:12447},{begin:12448,end:12543},{begin:12544,end:12591},{begin:12592,end:12687},{begin:43072,end:43135},{begin:12800,end:13055},{begin:13056,end:13311},{begin:44032,end:55215},{begin:55296,end:57343},{begin:67840,end:67871},{begin:19968,end:40959},{begin:57344,end:63743},{begin:12736,end:12783},{begin:64256,end:64335},{begin:64336,end:65023},{begin:65056,end:65071},{begin:65040,end:65055},{begin:65104,end:65135},{begin:65136,end:65279},{begin:65280,end:65519},{begin:65520,end:65535},{begin:3840,end:4095},{begin:1792,end:1871},{begin:1920,end:1983},{begin:3456,end:3583},{begin:4096,end:4255},{begin:4608,end:4991},{begin:5024,end:5119},{begin:5120,end:5759},{begin:5760,end:5791},{begin:5792,end:5887},{begin:6016,end:6143},{begin:6144,end:6319},{begin:10240,end:10495},{begin:40960,end:42127},{begin:5888,end:5919},{begin:66304,end:66351},{begin:66352,end:66383},{begin:66560,end:66639},{begin:118784,end:119039},{begin:119808,end:120831},{begin:1044480,end:1048573},{begin:65024,end:65039},{begin:917504,end:917631},{begin:6400,end:6479},{begin:6480,end:6527},{begin:6528,end:6623},{begin:6656,end:6687},{begin:11264,end:11359},{begin:11568,end:11647},{begin:19904,end:19967},{begin:43008,end:43055},{begin:65536,end:65663},{begin:65856,end:65935},{begin:66432,end:66463},{begin:66464,end:66527},{begin:66640,end:66687},{begin:66688,end:66735},{begin:67584,end:67647},{begin:68096,end:68191},{begin:119552,end:119647},{begin:73728,end:74751},{begin:119648,end:119679},{begin:7040,end:7103},{begin:7168,end:7247},{begin:7248,end:7295},{begin:43136,end:43231},{begin:43264,end:43311},{begin:43312,end:43359},{begin:43520,end:43615},{begin:65936,end:65999},{begin:66e3,end:66047},{begin:66208,end:66271},{begin:127024,end:127135}];var it={parse:function(e,t){var r={},n=new se.Parser(e,t);r.version=n.parseUShort(),r.xAvgCharWidth=n.parseShort(),r.usWeightClass=n.parseUShort(),r.usWidthClass=n.parseUShort(),r.fsType=n.parseUShort(),r.ySubscriptXSize=n.parseShort(),r.ySubscriptYSize=n.parseShort(),r.ySubscriptXOffset=n.parseShort(),r.ySubscriptYOffset=n.parseShort(),r.ySuperscriptXSize=n.parseShort(),r.ySuperscriptYSize=n.parseShort(),r.ySuperscriptXOffset=n.parseShort(),r.ySuperscriptYOffset=n.parseShort(),r.yStrikeoutSize=n.parseShort(),r.yStrikeoutPosition=n.parseShort(),r.sFamilyClass=n.parseShort(),r.panose=[];for(var a=0;a<10;a++)r.panose[a]=n.parseByte();return r.ulUnicodeRange1=n.parseULong(),r.ulUnicodeRange2=n.parseULong(),r.ulUnicodeRange3=n.parseULong(),r.ulUnicodeRange4=n.parseULong(),r.achVendID=String.fromCharCode(n.parseByte(),n.parseByte(),n.parseByte(),n.parseByte()),r.fsSelection=n.parseUShort(),r.usFirstCharIndex=n.parseUShort(),r.usLastCharIndex=n.parseUShort(),r.sTypoAscender=n.parseShort(),r.sTypoDescender=n.parseShort(),r.sTypoLineGap=n.parseShort(),r.usWinAscent=n.parseUShort(),r.usWinDescent=n.parseUShort(),r.version>=1&&(r.ulCodePageRange1=n.parseULong(),r.ulCodePageRange2=n.parseULong()),r.version>=2&&(r.sxHeight=n.parseShort(),r.sCapHeight=n.parseShort(),r.usDefaultChar=n.parseUShort(),r.usBreakChar=n.parseUShort(),r.usMaxContent=n.parseUShort()),r},make:function(e){return new J.Table("OS/2",[{name:"version",type:"USHORT",value:3},{name:"xAvgCharWidth",type:"SHORT",value:0},{name:"usWeightClass",type:"USHORT",value:0},{name:"usWidthClass",type:"USHORT",value:0},{name:"fsType",type:"USHORT",value:0},{name:"ySubscriptXSize",type:"SHORT",value:650},{name:"ySubscriptYSize",type:"SHORT",value:699},{name:"ySubscriptXOffset",type:"SHORT",value:0},{name:"ySubscriptYOffset",type:"SHORT",value:140},{name:"ySuperscriptXSize",type:"SHORT",value:650},{name:"ySuperscriptYSize",type:"SHORT",value:699},{name:"ySuperscriptXOffset",type:"SHORT",value:0},{name:"ySuperscriptYOffset",type:"SHORT",value:479},{name:"yStrikeoutSize",type:"SHORT",value:49},{name:"yStrikeoutPosition",type:"SHORT",value:258},{name:"sFamilyClass",type:"SHORT",value:0},{name:"bFamilyType",type:"BYTE",value:0},{name:"bSerifStyle",type:"BYTE",value:0},{name:"bWeight",type:"BYTE",value:0},{name:"bProportion",type:"BYTE",value:0},{name:"bContrast",type:"BYTE",value:0},{name:"bStrokeVariation",type:"BYTE",value:0},{name:"bArmStyle",type:"BYTE",value:0},{name:"bLetterform",type:"BYTE",value:0},{name:"bMidline",type:"BYTE",value:0},{name:"bXHeight",type:"BYTE",value:0},{name:"ulUnicodeRange1",type:"ULONG",value:0},{name:"ulUnicodeRange2",type:"ULONG",value:0},{name:"ulUnicodeRange3",type:"ULONG",value:0},{name:"ulUnicodeRange4",type:"ULONG",value:0},{name:"achVendID",type:"CHARARRAY",value:"XXXX"},{name:"fsSelection",type:"USHORT",value:0},{name:"usFirstCharIndex",type:"USHORT",value:0},{name:"usLastCharIndex",type:"USHORT",value:0},{name:"sTypoAscender",type:"SHORT",value:0},{name:"sTypoDescender",type:"SHORT",value:0},{name:"sTypoLineGap",type:"SHORT",value:0},{name:"usWinAscent",type:"USHORT",value:0},{name:"usWinDescent",type:"USHORT",value:0},{name:"ulCodePageRange1",type:"ULONG",value:0},{name:"ulCodePageRange2",type:"ULONG",value:0},{name:"sxHeight",type:"SHORT",value:0},{name:"sCapHeight",type:"SHORT",value:0},{name:"usDefaultChar",type:"USHORT",value:0},{name:"usBreakChar",type:"USHORT",value:0},{name:"usMaxContext",type:"USHORT",value:0}],e)},unicodeRanges:st,getUnicodeRange:function(e){for(var t=0;t<st.length;t+=1){var r=st[t];if(e>=r.begin&&e<r.end)return t}return-1}};var ut={parse:function(e,t){var r={},n=new se.Parser(e,t);switch(r.version=n.parseVersion(),r.italicAngle=n.parseFixed(),r.underlinePosition=n.parseShort(),r.underlineThickness=n.parseShort(),r.isFixedPitch=n.parseULong(),r.minMemType42=n.parseULong(),r.maxMemType42=n.parseULong(),r.minMemType1=n.parseULong(),r.maxMemType1=n.parseULong(),r.version){case 1:r.names=Oe.slice();break;case 2:r.numberOfGlyphs=n.parseUShort(),r.glyphNameIndex=new Array(r.numberOfGlyphs);for(var a=0;a<r.numberOfGlyphs;a++)r.glyphNameIndex[a]=n.parseUShort();r.names=[];for(var o=0;o<r.numberOfGlyphs;o++)if(r.glyphNameIndex[o]>=Oe.length){var s=n.parseChar();r.names.push(n.parseString(s))}break;case 2.5:r.numberOfGlyphs=n.parseUShort(),r.offset=new Array(r.numberOfGlyphs);for(var i=0;i<r.numberOfGlyphs;i++)r.offset[i]=n.parseChar()}return r},make:function(){return new J.Table("post",[{name:"version",type:"FIXED",value:196608},{name:"italicAngle",type:"FIXED",value:0},{name:"underlinePosition",type:"FWORD",value:0},{name:"underlineThickness",type:"FWORD",value:0},{name:"isFixedPitch",type:"ULONG",value:0},{name:"minMemType42",type:"ULONG",value:0},{name:"maxMemType42",type:"ULONG",value:0},{name:"minMemType1",type:"ULONG",value:0},{name:"maxMemType1",type:"ULONG",value:0}])}},lt=new Array(9);lt[1]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();return 1===t?{substFormat:1,coverage:this.parsePointer(ae.coverage),deltaGlyphId:this.parseShort()}:2===t?{substFormat:2,coverage:this.parsePointer(ae.coverage),substitute:this.parseOffset16List()}:void w.assert(!1,"0x"+e.toString(16)+": lookup type 1 format must be 1 or 2.")},lt[2]=function(){var e=this.parseUShort();return w.argument(1===e,"GSUB Multiple Substitution Subtable identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(ae.coverage),sequences:this.parseListOfLists()}},lt[3]=function(){var e=this.parseUShort();return w.argument(1===e,"GSUB Alternate Substitution Subtable identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(ae.coverage),alternateSets:this.parseListOfLists()}},lt[4]=function(){var e=this.parseUShort();return w.argument(1===e,"GSUB ligature table identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(ae.coverage),ligatureSets:this.parseListOfLists((function(){return{ligGlyph:this.parseUShort(),components:this.parseUShortList(this.parseUShort()-1)}}))}};var pt={sequenceIndex:ae.uShort,lookupListIndex:ae.uShort};lt[5]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();if(1===t)return{substFormat:t,coverage:this.parsePointer(ae.coverage),ruleSets:this.parseListOfLists((function(){var e=this.parseUShort(),t=this.parseUShort();return{input:this.parseUShortList(e-1),lookupRecords:this.parseRecordList(t,pt)}}))};if(2===t)return{substFormat:t,coverage:this.parsePointer(ae.coverage),classDef:this.parsePointer(ae.classDef),classSets:this.parseListOfLists((function(){var e=this.parseUShort(),t=this.parseUShort();return{classes:this.parseUShortList(e-1),lookupRecords:this.parseRecordList(t,pt)}}))};if(3===t){var r=this.parseUShort(),n=this.parseUShort();return{substFormat:t,coverages:this.parseList(r,ae.pointer(ae.coverage)),lookupRecords:this.parseRecordList(n,pt)}}w.assert(!1,"0x"+e.toString(16)+": lookup type 5 format must be 1, 2 or 3.")},lt[6]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();return 1===t?{substFormat:1,coverage:this.parsePointer(ae.coverage),chainRuleSets:this.parseListOfLists((function(){return{backtrack:this.parseUShortList(),input:this.parseUShortList(this.parseShort()-1),lookahead:this.parseUShortList(),lookupRecords:this.parseRecordList(pt)}}))}:2===t?{substFormat:2,coverage:this.parsePointer(ae.coverage),backtrackClassDef:this.parsePointer(ae.classDef),inputClassDef:this.parsePointer(ae.classDef),lookaheadClassDef:this.parsePointer(ae.classDef),chainClassSet:this.parseListOfLists((function(){return{backtrack:this.parseUShortList(),input:this.parseUShortList(this.parseShort()-1),lookahead:this.parseUShortList(),lookupRecords:this.parseRecordList(pt)}}))}:3===t?{substFormat:3,backtrackCoverage:this.parseList(ae.pointer(ae.coverage)),inputCoverage:this.parseList(ae.pointer(ae.coverage)),lookaheadCoverage:this.parseList(ae.pointer(ae.coverage)),lookupRecords:this.parseRecordList(pt)}:void w.assert(!1,"0x"+e.toString(16)+": lookup type 6 format must be 1, 2 or 3.")},lt[7]=function(){var e=this.parseUShort();w.argument(1===e,"GSUB Extension Substitution subtable identifier-format must be 1");var t=this.parseUShort(),r=new ae(this.data,this.offset+this.parseULong());return{substFormat:1,lookupType:t,extension:lt[t].call(r)}},lt[8]=function(){var e=this.parseUShort();return w.argument(1===e,"GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(ae.coverage),backtrackCoverage:this.parseList(ae.pointer(ae.coverage)),lookaheadCoverage:this.parseList(ae.pointer(ae.coverage)),substitutes:this.parseUShortList()}};var ct=new Array(9);ct[1]=function(e){return 1===e.substFormat?new J.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new J.Coverage(e.coverage)},{name:"deltaGlyphID",type:"SHORT",value:e.deltaGlyphId}]):new J.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:2},{name:"coverage",type:"TABLE",value:new J.Coverage(e.coverage)}].concat(J.ushortList("substitute",e.substitute)))},ct[2]=function(e){return w.assert(1===e.substFormat,"Lookup type 2 substFormat must be 1."),new J.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new J.Coverage(e.coverage)}].concat(J.tableList("seqSet",e.sequences,(function(e){return new J.Table("sequenceSetTable",J.ushortList("sequence",e))}))))},ct[3]=function(e){return w.assert(1===e.substFormat,"Lookup type 3 substFormat must be 1."),new J.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new J.Coverage(e.coverage)}].concat(J.tableList("altSet",e.alternateSets,(function(e){return new J.Table("alternateSetTable",J.ushortList("alternate",e))}))))},ct[4]=function(e){return w.assert(1===e.substFormat,"Lookup type 4 substFormat must be 1."),new J.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new J.Coverage(e.coverage)}].concat(J.tableList("ligSet",e.ligatureSets,(function(e){return new J.Table("ligatureSetTable",J.tableList("ligature",e,(function(e){return new J.Table("ligatureTable",[{name:"ligGlyph",type:"USHORT",value:e.ligGlyph}].concat(J.ushortList("component",e.components,e.components.length+1)))})))}))))},ct[6]=function(e){if(1===e.substFormat){var t=new J.Table("chainContextTable",[{name:"substFormat",type:"USHORT",value:e.substFormat},{name:"coverage",type:"TABLE",value:new J.Coverage(e.coverage)}].concat(J.tableList("chainRuleSet",e.chainRuleSets,(function(e){return new J.Table("chainRuleSetTable",J.tableList("chainRule",e,(function(e){var t=J.ushortList("backtrackGlyph",e.backtrack,e.backtrack.length).concat(J.ushortList("inputGlyph",e.input,e.input.length+1)).concat(J.ushortList("lookaheadGlyph",e.lookahead,e.lookahead.length)).concat(J.ushortList("substitution",[],e.lookupRecords.length));return e.lookupRecords.forEach((function(e,r){t=t.concat({name:"sequenceIndex"+r,type:"USHORT",value:e.sequenceIndex}).concat({name:"lookupListIndex"+r,type:"USHORT",value:e.lookupListIndex})})),new J.Table("chainRuleTable",t)})))}))));return t}if(2===e.substFormat)w.assert(!1,"lookup type 6 format 2 is not yet supported.");else if(3===e.substFormat){var r=[{name:"substFormat",type:"USHORT",value:e.substFormat}];return r.push({name:"backtrackGlyphCount",type:"USHORT",value:e.backtrackCoverage.length}),e.backtrackCoverage.forEach((function(e,t){r.push({name:"backtrackCoverage"+t,type:"TABLE",value:new J.Coverage(e)})})),r.push({name:"inputGlyphCount",type:"USHORT",value:e.inputCoverage.length}),e.inputCoverage.forEach((function(e,t){r.push({name:"inputCoverage"+t,type:"TABLE",value:new J.Coverage(e)})})),r.push({name:"lookaheadGlyphCount",type:"USHORT",value:e.lookaheadCoverage.length}),e.lookaheadCoverage.forEach((function(e,t){r.push({name:"lookaheadCoverage"+t,type:"TABLE",value:new J.Coverage(e)})})),r.push({name:"substitutionCount",type:"USHORT",value:e.lookupRecords.length}),e.lookupRecords.forEach((function(e,t){r=r.concat({name:"sequenceIndex"+t,type:"USHORT",value:e.sequenceIndex}).concat({name:"lookupListIndex"+t,type:"USHORT",value:e.lookupListIndex})})),new J.Table("chainContextTable",r)}w.assert(!1,"lookup type 6 format must be 1, 2 or 3.")};var ht={parse:function(e,t){var r=new ae(e,t=t||0),n=r.parseVersion(1);return w.argument(1===n||1.1===n,"Unsupported GSUB table version."),1===n?{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(lt)}:{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(lt),variations:r.parseFeatureVariationsList()}},make:function(e){return new J.Table("GSUB",[{name:"version",type:"ULONG",value:65536},{name:"scripts",type:"TABLE",value:new J.ScriptList(e.scripts)},{name:"features",type:"TABLE",value:new J.FeatureList(e.features)},{name:"lookups",type:"TABLE",value:new J.LookupList(e.lookups,ct)}])}},ft=new Array(10);ft[1]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();return 1===t?{posFormat:1,coverage:this.parsePointer(ae.coverage),value:this.parseValueRecord()}:2===t?{posFormat:2,coverage:this.parsePointer(ae.coverage),values:this.parseValueRecordList()}:void w.assert(!1,"0x"+e.toString(16)+": GPOS lookup type 1 format must be 1 or 2.")},ft[2]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();w.assert(1===t||2===t,"0x"+e.toString(16)+": GPOS lookup type 2 format must be 1 or 2.");var r=this.parsePointer(ae.coverage),n=this.parseUShort(),a=this.parseUShort();if(1===t)return{posFormat:t,coverage:r,valueFormat1:n,valueFormat2:a,pairSets:this.parseList(ae.pointer(ae.list((function(){return{secondGlyph:this.parseUShort(),value1:this.parseValueRecord(n),value2:this.parseValueRecord(a)}}))))};if(2===t){var o=this.parsePointer(ae.classDef),s=this.parsePointer(ae.classDef),i=this.parseUShort(),u=this.parseUShort();return{posFormat:t,coverage:r,valueFormat1:n,valueFormat2:a,classDef1:o,classDef2:s,class1Count:i,class2Count:u,classRecords:this.parseList(i,ae.list(u,(function(){return{value1:this.parseValueRecord(n),value2:this.parseValueRecord(a)}})))}}},ft[3]=function(){return{error:"GPOS Lookup 3 not supported"}},ft[4]=function(){return{error:"GPOS Lookup 4 not supported"}},ft[5]=function(){return{error:"GPOS Lookup 5 not supported"}},ft[6]=function(){return{error:"GPOS Lookup 6 not supported"}},ft[7]=function(){return{error:"GPOS Lookup 7 not supported"}},ft[8]=function(){return{error:"GPOS Lookup 8 not supported"}},ft[9]=function(){return{error:"GPOS Lookup 9 not supported"}};var dt={parse:function(e,t){var r=new ae(e,t=t||0),n=r.parseVersion(1);return w.argument(1===n||1.1===n,"Unsupported GPOS table version "+n),1===n?{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(ft)}:{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(ft),variations:r.parseFeatureVariationsList()}},make:function(e){var t=Object.entries(e);t.sort((function(e,t){var r=parseInt(e[0].match(/\d+/)[0]),n=parseInt(e[0].match(/\d+$/)[0]),a=parseInt(t[0].match(/\d+/)[0]),o=parseInt(t[0].match(/\d+$/)[0]);return r<a?-1:r>a?1:n<o?-1:1}));for(var r=t.length,n=[],a=[],o=0;o<r;o++){var s=parseInt(t[o][0].match(/\d+/)[0]),i=parseInt(t[o][0].match(/\d+$/)[0]);s!==n[n.length-1]&&(n.push(s),a[n.length-1]=[]),a[n.length-1].push([i,t[o][1]])}for(var u=new J.Table("GPOS",[{name:"majorVersion",type:"USHORT",value:1},{name:"minorVersion",type:"USHORT",value:0},{name:"scriptListOffset",type:"USHORT",value:10},{name:"featureListOffset",type:"USHORT",value:48},{name:"lookupListOffset",type:"USHORT",value:62},{name:"scriptCount",type:"USHORT",value:2},{name:"scriptTag",type:"TAG",value:"DFLT"},{name:"scriptOffset",type:"USHORT",value:14},{name:"scriptTag2",type:"TAG",value:"latn"},{name:"scriptOffset2",type:"USHORT",value:26},{name:"defaultLangSysOffset",type:"USHORT",value:4},{name:"langSysCount",type:"USHORT",value:0},{name:"lookupOrderOffset",type:"USHORT",value:0},{name:"requiredFeatureIndex",type:"USHORT",value:65535},{name:"featureIndexCount",type:"USHORT",value:1},{name:"featureIndex",type:"USHORT",value:0},{name:"defaultLangSysOffset2",type:"USHORT",value:4},{name:"langSysCount2",type:"USHORT",value:0},{name:"lookupOrderOffset2",type:"USHORT",value:0},{name:"requiredFeatureIndex2",type:"USHORT",value:65535},{name:"featureIndexCount2",type:"USHORT",value:1},{name:"featureIndex2",type:"USHORT",value:0},{name:"featureCount",type:"USHORT",value:1},{name:"featureTag",type:"TAG",value:"kern"},{name:"featureOffset",type:"USHORT",value:8},{name:"featureParamsOffset",type:"USHORT",value:0},{name:"lookupIndexCount",type:"USHORT",value:1},{name:"lookupListIndices",type:"USHORT",value:0},{name:"lookupCount",type:"USHORT",value:1},{name:"lookupOffset",type:"USHORT",value:4},{name:"lookupType",type:"USHORT",value:2},{name:"lookupFlag",type:"USHORT",value:0},{name:"subTableCount",type:"USHORT",value:1},{name:"lookupOffset2",type:"USHORT",value:8},{name:"posFormat",type:"USHORT",value:1},{name:"coverageOffset",type:"USHORT",value:10+4*n.length+4*r},{name:"valueFormat1",type:"USHORT",value:4},{name:"valueFormat2",type:"USHORT",value:0},{name:"pairSetCount",type:"USHORT",value:n.length}]),l=10+2*n.length,p=0;p<n.length;p++)u.fields.push({name:"pairSetOffsets",type:"USHORT",value:l}),l=l+2+4*a[p].length;for(var c=0;c<a.length;c++){u.fields.push({name:"pairValueCount",type:"USHORT",value:a[c].length});for(var h=0;h<a[c].length;h++)u.fields.push({name:"secondGlyph",type:"USHORT",value:a[c][h][0]}),u.fields.push({name:"valueRecord1",type:"USHORT",value:a[c][h][1]})}u.fields.push({name:"coverageFormat",type:"USHORT",value:1}),u.fields.push({name:"glyphCount",type:"USHORT",value:n.length});for(var f=0;f<n.length;f++)u.fields.push({name:"UppercasePGlyphID",type:"USHORT",value:n[f]});return u}};var vt={parse:function(e,t){var r=new se.Parser(e,t),n=r.parseULong();w.argument(1===n,"Unsupported META table version."),r.parseULong(),r.parseULong();for(var a=r.parseULong(),o={},s=0;s<a;s++){var i=r.parseTag(),u=r.parseULong(),l=r.parseULong(),p=I.UTF8(e,t+u,l);o[i]=p}return o},make:function(e){var t=Object.keys(e).length,r="",n=16+12*t,a=new J.Table("meta",[{name:"version",type:"ULONG",value:1},{name:"flags",type:"ULONG",value:0},{name:"offset",type:"ULONG",value:n},{name:"numTags",type:"ULONG",value:t}]);for(var o in e){var s=r.length;r+=e[o],a.fields.push({name:"tag "+o,type:"TAG",value:o}),a.fields.push({name:"offset "+o,type:"ULONG",value:n+s}),a.fields.push({name:"length "+o,type:"ULONG",value:e[o].length})}return a.fields.push({name:"stringPool",type:"CHARARRAY",value:r}),a}};var gt={parse:function(e,t){var r=new ae(e,t),n=r.parseUShort();w.argument(0===n,"Only COLRv0 supported.");var a=r.parseUShort(),o=r.parseOffset32(),s=r.parseOffset32(),i=r.parseUShort();r.relativeOffset=o;var u=r.parseRecordList(a,{glyphID:ae.uShort,firstLayerIndex:ae.uShort,numLayers:ae.uShort});return r.relativeOffset=s,{version:n,baseGlyphRecords:u,layerRecords:r.parseRecordList(i,{glyphID:ae.uShort,paletteIndex:ae.uShort})}},make:function(e){var t=e.version;void 0===t&&(t=0);var r=e.baseGlyphRecords;void 0===r&&(r=[]);var n=e.layerRecords;void 0===n&&(n=[]),w.argument(0===t,"Only COLRv0 supported.");var a=14,o=a+6*r.length;return new J.Table("COLR",[{name:"version",type:"USHORT",value:t},{name:"numBaseGlyphRecords",type:"USHORT",value:r.length},{name:"baseGlyphRecordsOffset",type:"ULONG",value:a},{name:"layerRecordsOffset",type:"ULONG",value:o},{name:"numLayerRecords",type:"USHORT",value:n.length}].concat(r.map((function(e,t){return[{name:"glyphID_"+t,type:"USHORT",value:e.glyphID},{name:"firstLayerIndex_"+t,type:"USHORT",value:e.firstLayerIndex},{name:"numLayers_"+t,type:"USHORT",value:e.numLayers}]})).flat(),n.map((function(e,t){return[{name:"LayerGlyphID_"+t,type:"USHORT",value:e.glyphID},{name:"paletteIndex_"+t,type:"USHORT",value:e.paletteIndex}]})).flat()))}};var mt={parse:function(e,t){var r=new ae(e,t),n=r.parseShort(),a=r.parseShort(),o=r.parseShort(),s=r.parseShort(),i=r.parseOffset32(),u=r.parseUShortList(o);return r.relativeOffset=i,{version:n,numPaletteEntries:a,colorRecords:r.parseULongList(s),colorRecordIndices:u}},make:function(e){var t=e.version;void 0===t&&(t=0);var r=e.numPaletteEntries;void 0===r&&(r=0);var n=e.colorRecords;void 0===n&&(n=[]);var a=e.colorRecordIndices;return void 0===a&&(a=[0]),w.argument(0===t,"Only CPALv0 are supported."),w.argument(n.length,"No colorRecords given."),w.argument(a.length,"No colorRecordIndices given."),a.length>1&&w.argument(r,"Can't infer numPaletteEntries on multiple colorRecordIndices"),new J.Table("CPAL",[{name:"version",type:"USHORT",value:t},{name:"numPaletteEntries",type:"USHORT",value:r||n.length},{name:"numPalettes",type:"USHORT",value:a.length},{name:"numColorRecords",type:"USHORT",value:n.length},{name:"colorRecordsArrayOffset",type:"ULONG",value:12+2*a.length}].concat(a.map((function(e,t){return{name:"colorRecordIndices_"+t,type:"USHORT",value:e}})),n.map((function(e,t){return{name:"colorRecords_"+t,type:"ULONG",value:e}}))))}};function yt(e){return Math.log(e)/Math.log(2)|0}function bt(e){for(;e.length%4!=0;)e.push(0);for(var t=0,r=0;r<e.length;r+=4)t+=(e[r]<<24)+(e[r+1]<<16)+(e[r+2]<<8)+e[r+3];return t%=Math.pow(2,32)}function St(e,t,r,n){return new J.Record("Table Record",[{name:"tag",type:"TAG",value:void 0!==e?e:""},{name:"checkSum",type:"ULONG",value:void 0!==t?t:0},{name:"offset",type:"ULONG",value:void 0!==r?r:0},{name:"length",type:"ULONG",value:void 0!==n?n:0}])}function xt(e){var t=new J.Table("sfnt",[{name:"version",type:"TAG",value:"OTTO"},{name:"numTables",type:"USHORT",value:0},{name:"searchRange",type:"USHORT",value:0},{name:"entrySelector",type:"USHORT",value:0},{name:"rangeShift",type:"USHORT",value:0}]);t.tables=e,t.numTables=e.length;var r=Math.pow(2,yt(t.numTables));t.searchRange=16*r,t.entrySelector=yt(r),t.rangeShift=16*t.numTables-t.searchRange;for(var n=[],a=[],o=t.sizeOf()+St().sizeOf()*t.numTables;o%4!=0;)o+=1,a.push({name:"padding",type:"BYTE",value:0});for(var s=0;s<e.length;s+=1){var i=e[s];w.argument(4===i.tableName.length,"Table name"+i.tableName+" is invalid.");var u=i.sizeOf(),l=St(i.tableName,bt(i.encode()),o,u);for(n.push({name:l.tag+" Table Record",type:"RECORD",value:l}),a.push({name:i.tableName+" table",type:"RECORD",value:i}),o+=u,w.argument(!isNaN(o),"Something went wrong calculating the offset.");o%4!=0;)o+=1,a.push({name:"padding",type:"BYTE",value:0})}return n.sort((function(e,t){return e.value.tag>t.value.tag?1:-1})),t.fields=t.fields.concat(n),t.fields=t.fields.concat(a),t}function Tt(e,t,r){for(var n=0;n<t.length;n+=1){var a=e.charToGlyphIndex(t[n]);if(a>0)return e.glyphs.get(a).getMetrics()}return r}function Ut(e){for(var t=0,r=0;r<e.length;r+=1)t+=e[r];return t/e.length}var kt={make:xt,fontToTable:function(e){for(var t,r=[],n=[],a=[],o=[],s=[],i=[],u=[],l=0,p=0,c=0,h=0,f=0,d=0;d<e.glyphs.length;d+=1){var v=e.glyphs.get(d),g=0|v.unicode;if(isNaN(v.advanceWidth))throw new Error("Glyph "+v.name+" ("+d+"): advanceWidth is not a number.");(t>g||void 0===t)&&g>0&&(t=g),l<g&&(l=g);var m=it.getUnicodeRange(g);if(m<32)p|=1<<m;else if(m<64)c|=1<<m-32;else if(m<96)h|=1<<m-64;else{if(!(m<123))throw new Error("Unicode ranges bits > 123 are reserved for internal usage");f|=1<<m-96}if(".notdef"!==v.name){var y=v.getMetrics();r.push(y.xMin),n.push(y.yMin),a.push(y.xMax),o.push(y.yMax),i.push(y.leftSideBearing),u.push(y.rightSideBearing),s.push(v.advanceWidth)}}var b={xMin:Math.min.apply(null,r),yMin:Math.min.apply(null,n),xMax:Math.max.apply(null,a),yMax:Math.max.apply(null,o),advanceWidthMax:Math.max.apply(null,s),advanceWidthAvg:Ut(s),minLeftSideBearing:Math.min.apply(null,i),maxLeftSideBearing:Math.max.apply(null,i),minRightSideBearing:Math.min.apply(null,u)};b.ascender=e.ascender,b.descender=e.descender;var S=tt.make({flags:3,unitsPerEm:e.unitsPerEm,xMin:b.xMin,yMin:b.yMin,xMax:b.xMax,yMax:b.yMax,lowestRecPPEM:3,createdTimestamp:e.createdTimestamp}),x=rt.make({ascender:b.ascender,descender:b.descender,advanceWidthMax:b.advanceWidthMax,minLeftSideBearing:b.minLeftSideBearing,minRightSideBearing:b.minRightSideBearing,xMaxExtent:b.maxLeftSideBearing+(b.xMax-b.xMin),numberOfHMetrics:e.glyphs.length}),T=ot.make(e.glyphs.length),U=it.make(Object.assign({xAvgCharWidth:Math.round(b.advanceWidthAvg),usFirstCharIndex:t,usLastCharIndex:l,ulUnicodeRange1:p,ulUnicodeRange2:c,ulUnicodeRange3:h,ulUnicodeRange4:f,sTypoAscender:b.ascender,sTypoDescender:b.descender,sTypoLineGap:0,usWinAscent:b.yMax,usWinDescent:Math.abs(b.yMin),ulCodePageRange1:1,sxHeight:Tt(e,"xyvw",{yMax:Math.round(b.ascender/2)}).yMax,sCapHeight:Tt(e,"HIKLEFJMNTZBDPRAGOQSUVWXY",b).yMax,usDefaultChar:e.hasChar(" ")?32:0,usBreakChar:e.hasChar(" ")?32:0},e.tables.os2)),k=nt.make(e.glyphs),O=xe.make(e.glyphs),R=e.getEnglishName("fontFamily"),E=e.getEnglishName("fontSubfamily"),L=R+" "+E,C=e.getEnglishName("postScriptName");C||(C=R.replace(/\s/g,"")+"-"+E);var w={};for(var D in e.names)w[D]=e.names[D];w.uniqueID||(w.uniqueID={en:e.getEnglishName("manufacturer")+":"+L}),w.postScriptName||(w.postScriptName={en:C}),w.preferredFamily||(w.preferredFamily=e.names.fontFamily),w.preferredSubfamily||(w.preferredSubfamily=e.names.fontSubfamily);var I=[],G=be.make(w,I),M=I.length>0?at.make(I):void 0,B=ut.make(),F=et.make(e.glyphs,{version:e.getEnglishName("version"),fullName:L,familyName:R,weightName:E,postScriptName:C,unitsPerEm:e.unitsPerEm,fontBBox:[0,b.yMin,b.ascender,b.advanceWidthMax]}),P=e.metas&&Object.keys(e.metas).length>0?vt.make(e.metas):void 0,A=[S,x,T,U,G,O,B,F,k];M&&A.push(M),e.tables.gsub&&A.push(ht.make(e.tables.gsub)),e.kerningPairs&&Object.keys(e.kerningPairs).length>0&&A.push(dt.make(e.kerningPairs)),e.tables.cpal&&A.push(mt.make(e.tables.cpal)),e.tables.colr&&A.push(gt.make(e.tables.colr)),P&&A.push(P);for(var N=xt(A),H=bt(N.encode()),z=N.fields,W=!1,q=0;q<z.length;q+=1)if("head table"===z[q].name){z[q].value.checkSumAdjustment=2981146554-H,W=!0;break}if(!W)throw new Error("Could not find head table with checkSum to adjust.");return N},computeCheckSum:bt};function Ot(e,t){for(var r=0,n=e.length-1;r<=n;){var a=r+n>>>1,o=e[a].tag;if(o===t)return a;o<t?r=a+1:n=a-1}return-r-1}function Rt(e,t){for(var r=0,n=e.length-1;r<=n;){var a=r+n>>>1,o=e[a];if(o===t)return a;o<t?r=a+1:n=a-1}return-r-1}function Et(e,t){for(var r,n=0,a=e.length-1;n<=a;){var o=n+a>>>1,s=(r=e[o]).start;if(s===t)return r;s<t?n=o+1:a=o-1}if(n>0)return t>(r=e[n-1]).end?0:r}function Lt(e,t){this.font=e,this.tableName=t}function Ct(e){Lt.call(this,e,"gpos")}function wt(e){Lt.call(this,e,"gsub")}function Dt(e,t){var r=e.length;if(r!==t.length)return!1;for(var n=0;n<r;n++)if(e[n]!==t[n])return!1;return!0}function It(e,t,r){for(var n=e.subtables,a=0;a<n.length;a++){var o=n[a];if(o.substFormat===t)return o}if(r)return n.push(r),r}function Gt(e){for(var t=new ArrayBuffer(e.length),r=new Uint8Array(t),n=0;n<e.length;++n)r[n]=e[n];return t}function Mt(e,t){if(!e)throw t}function Bt(e,t,r,n,a){var o;return(t&n)>0?(o=e.parseByte(),t&a||(o=-o),o=r+o):o=(t&a)>0?r:r+e.parseShort(),o}function Ft(e,t,r){var n,a,o=new se.Parser(t,r);if(e.numberOfContours=o.parseShort(),e._xMin=o.parseShort(),e._yMin=o.parseShort(),e._xMax=o.parseShort(),e._yMax=o.parseShort(),e.numberOfContours>0){for(var s=e.endPointIndices=[],i=0;i<e.numberOfContours;i+=1)s.push(o.parseUShort());e.instructionLength=o.parseUShort(),e.instructions=[];for(var u=0;u<e.instructionLength;u+=1)e.instructions.push(o.parseByte());var l=s[s.length-1]+1;n=[];for(var p=0;p<l;p+=1)if(a=o.parseByte(),n.push(a),(8&a)>0)for(var c=o.parseByte(),h=0;h<c;h+=1)n.push(a),p+=1;if(w.argument(n.length===l,"Bad flags."),s.length>0){var f,d=[];if(l>0){for(var v=0;v<l;v+=1)a=n[v],(f={}).onCurve=!!(1&a),f.lastPointOfContour=s.indexOf(v)>=0,d.push(f);for(var g=0,m=0;m<l;m+=1)a=n[m],(f=d[m]).x=Bt(o,a,g,2,16),g=f.x;for(var y=0,b=0;b<l;b+=1)a=n[b],(f=d[b]).y=Bt(o,a,y,4,32),y=f.y}e.points=d}else e.points=[]}else if(0===e.numberOfContours)e.points=[];else{e.isComposite=!0,e.points=[],e.components=[];for(var S=!0;S;){n=o.parseUShort();var x={glyphIndex:o.parseUShort(),xScale:1,scale01:0,scale10:0,yScale:1,dx:0,dy:0};(1&n)>0?(2&n)>0?(x.dx=o.parseShort(),x.dy=o.parseShort()):x.matchedPoints=[o.parseUShort(),o.parseUShort()]:(2&n)>0?(x.dx=o.parseChar(),x.dy=o.parseChar()):x.matchedPoints=[o.parseByte(),o.parseByte()],(8&n)>0?x.xScale=x.yScale=o.parseF2Dot14():(64&n)>0?(x.xScale=o.parseF2Dot14(),x.yScale=o.parseF2Dot14()):(128&n)>0&&(x.xScale=o.parseF2Dot14(),x.scale01=o.parseF2Dot14(),x.scale10=o.parseF2Dot14(),x.yScale=o.parseF2Dot14()),e.components.push(x),S=!!(32&n)}if(256&n){e.instructionLength=o.parseUShort(),e.instructions=[];for(var T=0;T<e.instructionLength;T+=1)e.instructions.push(o.parseByte())}}}function Pt(e,t){for(var r=[],n=0;n<e.length;n+=1){var a=e[n],o={x:t.xScale*a.x+t.scale01*a.y+t.dx,y:t.scale10*a.x+t.yScale*a.y+t.dy,onCurve:a.onCurve,lastPointOfContour:a.lastPointOfContour};r.push(o)}return r}function At(e){var t=new E;if(!e)return t;for(var r=function(e){for(var t=[],r=[],n=0;n<e.length;n+=1){var a=e[n];r.push(a),a.lastPointOfContour&&(t.push(r),r=[])}return w.argument(0===r.length,"There are still points left in the current contour."),t}(e),n=0;n<r.length;++n){var a=r[n],o=null,s=a[a.length-1],i=a[0];if(s.onCurve)t.moveTo(s.x,s.y);else if(i.onCurve)t.moveTo(i.x,i.y);else{var u={x:.5*(s.x+i.x),y:.5*(s.y+i.y)};t.moveTo(u.x,u.y)}for(var l=0;l<a.length;++l)if(o=s,s=i,i=a[(l+1)%a.length],s.onCurve)t.lineTo(s.x,s.y);else{var p=i;o.onCurve||(s.x,o.x,s.y,o.y),i.onCurve||(p={x:.5*(s.x+i.x),y:.5*(s.y+i.y)}),t.quadraticCurveTo(s.x,s.y,p.x,p.y)}t.closePath()}return t}function Nt(e,t){if(t.isComposite)for(var r=0;r<t.components.length;r+=1){var n=t.components[r],a=e.get(n.glyphIndex);if(a.getPath(),a.points){var o=void 0;if(void 0===n.matchedPoints)o=Pt(a.points,n);else{if(n.matchedPoints[0]>t.points.length-1||n.matchedPoints[1]>a.points.length-1)throw Error("Matched points out of range in "+t.name);var s=t.points[n.matchedPoints[0]],i=a.points[n.matchedPoints[1]],u={xScale:n.xScale,scale01:n.scale01,scale10:n.scale10,yScale:n.yScale,dx:0,dy:0};i=Pt([i],u)[0],u.dx=s.x-i.x,u.dy=s.y-i.y,o=Pt(a.points,u)}t.points=t.points.concat(o)}}return At(t.points)}Lt.prototype={searchTag:Ot,binSearch:Rt,getTable:function(e){var t=this.font.tables[this.tableName];return!t&&e&&(t=this.font.tables[this.tableName]=this.createDefaultTable()),t},getScriptNames:function(){var e=this.getTable();return e?e.scripts.map((function(e){return e.tag})):[]},getDefaultScriptName:function(){var e=this.getTable();if(e){for(var t=!1,r=0;r<e.scripts.length;r++){var n=e.scripts[r].tag;if("DFLT"===n)return n;"latn"===n&&(t=!0)}return t?"latn":void 0}},getScriptTable:function(e,t){var r=this.getTable(t);if(r){e=e||"DFLT";var n=r.scripts,a=Ot(r.scripts,e);if(a>=0)return n[a].script;if(t){var o={tag:e,script:{defaultLangSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]},langSysRecords:[]}};return n.splice(-1-a,0,o),o.script}}},getLangSysTable:function(e,t,r){var n=this.getScriptTable(e,r);if(n){if(!t||"dflt"===t||"DFLT"===t)return n.defaultLangSys;var a=Ot(n.langSysRecords,t);if(a>=0)return n.langSysRecords[a].langSys;if(r){var o={tag:t,langSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]}};return n.langSysRecords.splice(-1-a,0,o),o.langSys}}},getFeatureTable:function(e,t,r,n){var a=this.getLangSysTable(e,t,n);if(a){for(var o,s=a.featureIndexes,i=this.font.tables[this.tableName].features,u=0;u<s.length;u++)if((o=i[s[u]]).tag===r)return o.feature;if(n){var l=i.length;return w.assert(0===l||r>=i[l-1].tag,"Features must be added in alphabetical order."),o={tag:r,feature:{params:0,lookupListIndexes:[]}},i.push(o),s.push(l),o.feature}}},getLookupTables:function(e,t,r,n,a){var o=this.getFeatureTable(e,t,r,a),s=[];if(o){for(var i,u=o.lookupListIndexes,l=this.font.tables[this.tableName].lookups,p=0;p<u.length;p++)(i=l[u[p]]).lookupType===n&&s.push(i);if(0===s.length&&a){i={lookupType:n,lookupFlag:0,subtables:[],markFilteringSet:void 0};var c=l.length;return l.push(i),u.push(c),[i]}}return s},getGlyphClass:function(e,t){switch(e.format){case 1:return e.startGlyph<=t&&t<e.startGlyph+e.classes.length?e.classes[t-e.startGlyph]:0;case 2:var r=Et(e.ranges,t);return r?r.classId:0}},getCoverageIndex:function(e,t){switch(e.format){case 1:var r=Rt(e.glyphs,t);return r>=0?r:-1;case 2:var n=Et(e.ranges,t);return n?n.index+t-n.start:-1}},expandCoverage:function(e){if(1===e.format)return e.glyphs;for(var t=[],r=e.ranges,n=0;n<r.length;n++)for(var a=r[n],o=a.start,s=a.end,i=o;i<=s;i++)t.push(i);return t}},Ct.prototype=Lt.prototype,Ct.prototype.init=function(){var e=this.getDefaultScriptName();this.defaultKerningTables=this.getKerningTables(e)},Ct.prototype.getKerningValue=function(e,t,r){for(var n=0;n<e.length;n++)for(var a=e[n].subtables,o=0;o<a.length;o++){var s=a[o],i=this.getCoverageIndex(s.coverage,t);if(!(i<0))switch(s.posFormat){case 1:for(var u=s.pairSets[i],l=0;l<u.length;l++){var p=u[l];if(p.secondGlyph===r)return p.value1&&p.value1.xAdvance||0}break;case 2:var c=this.getGlyphClass(s.classDef1,t),h=this.getGlyphClass(s.classDef2,r),f=s.classRecords[c][h];return f.value1&&f.value1.xAdvance||0}}return 0},Ct.prototype.getKerningTables=function(e,t){if(this.font.tables.gpos)return this.getLookupTables(e,t,"kern",2)},wt.prototype=Lt.prototype,wt.prototype.createDefaultTable=function(){return{version:1,scripts:[{tag:"DFLT",script:{defaultLangSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]},langSysRecords:[]}}],features:[],lookups:[]}},wt.prototype.getSingle=function(e,t,r){for(var n=[],a=this.getLookupTables(t,r,e,1),o=0;o<a.length;o++)for(var s=a[o].subtables,i=0;i<s.length;i++){var u=s[i],l=this.expandCoverage(u.coverage),p=void 0;if(1===u.substFormat){var c=u.deltaGlyphId;for(p=0;p<l.length;p++){var h=l[p];n.push({sub:h,by:h+c})}}else{var f=u.substitute;for(p=0;p<l.length;p++)n.push({sub:l[p],by:f[p]})}}return n},wt.prototype.getMultiple=function(e,t,r){for(var n=[],a=this.getLookupTables(t,r,e,2),o=0;o<a.length;o++)for(var s=a[o].subtables,i=0;i<s.length;i++){var u=s[i],l=this.expandCoverage(u.coverage),p=void 0;for(p=0;p<l.length;p++){var c=l[p],h=u.sequences[p];n.push({sub:c,by:h})}}return n},wt.prototype.getAlternates=function(e,t,r){for(var n=[],a=this.getLookupTables(t,r,e,3),o=0;o<a.length;o++)for(var s=a[o].subtables,i=0;i<s.length;i++)for(var u=s[i],l=this.expandCoverage(u.coverage),p=u.alternateSets,c=0;c<l.length;c++)n.push({sub:l[c],by:p[c]});return n},wt.prototype.getLigatures=function(e,t,r){for(var n=[],a=this.getLookupTables(t,r,e,4),o=0;o<a.length;o++)for(var s=a[o].subtables,i=0;i<s.length;i++)for(var u=s[i],l=this.expandCoverage(u.coverage),p=u.ligatureSets,c=0;c<l.length;c++)for(var h=l[c],f=p[c],d=0;d<f.length;d++){var v=f[d];n.push({sub:[h].concat(v.components),by:v.ligGlyph})}return n},wt.prototype.addSingle=function(e,t,r,n){var a=It(this.getLookupTables(r,n,e,1,!0)[0],2,{substFormat:2,coverage:{format:1,glyphs:[]},substitute:[]});w.assert(1===a.coverage.format,"Single: unable to modify coverage table format "+a.coverage.format);var o=t.sub,s=this.binSearch(a.coverage.glyphs,o);s<0&&(s=-1-s,a.coverage.glyphs.splice(s,0,o),a.substitute.splice(s,0,0)),a.substitute[s]=t.by},wt.prototype.addMultiple=function(e,t,r,n){w.assert(t.by instanceof Array&&t.by.length>1,'Multiple: "by" must be an array of two or more ids');var a=It(this.getLookupTables(r,n,e,2,!0)[0],1,{substFormat:1,coverage:{format:1,glyphs:[]},sequences:[]});w.assert(1===a.coverage.format,"Multiple: unable to modify coverage table format "+a.coverage.format);var o=t.sub,s=this.binSearch(a.coverage.glyphs,o);s<0&&(s=-1-s,a.coverage.glyphs.splice(s,0,o),a.sequences.splice(s,0,0)),a.sequences[s]=t.by},wt.prototype.addAlternate=function(e,t,r,n){var a=It(this.getLookupTables(r,n,e,3,!0)[0],1,{substFormat:1,coverage:{format:1,glyphs:[]},alternateSets:[]});w.assert(1===a.coverage.format,"Alternate: unable to modify coverage table format "+a.coverage.format);var o=t.sub,s=this.binSearch(a.coverage.glyphs,o);s<0&&(s=-1-s,a.coverage.glyphs.splice(s,0,o),a.alternateSets.splice(s,0,0)),a.alternateSets[s]=t.by},wt.prototype.addLigature=function(e,t,r,n){var a=this.getLookupTables(r,n,e,4,!0)[0],o=a.subtables[0];o||(o={substFormat:1,coverage:{format:1,glyphs:[]},ligatureSets:[]},a.subtables[0]=o),w.assert(1===o.coverage.format,"Ligature: unable to modify coverage table format "+o.coverage.format);var s=t.sub[0],i=t.sub.slice(1),u={ligGlyph:t.by,components:i},l=this.binSearch(o.coverage.glyphs,s);if(l>=0){for(var p=o.ligatureSets[l],c=0;c<p.length;c++)if(Dt(p[c].components,i))return;p.push(u)}else l=-1-l,o.coverage.glyphs.splice(l,0,s),o.ligatureSets.splice(l,0,[u])},wt.prototype.getFeature=function(e,t,r){if(/ss\d\d/.test(e))return this.getSingle(e,t,r);switch(e){case"aalt":case"salt":return this.getSingle(e,t,r).concat(this.getAlternates(e,t,r));case"dlig":case"liga":case"rlig":return this.getLigatures(e,t,r);case"ccmp":return this.getMultiple(e,t,r).concat(this.getLigatures(e,t,r));case"stch":return this.getMultiple(e,t,r)}},wt.prototype.add=function(e,t,r,n){if(/ss\d\d/.test(e))return this.addSingle(e,t,r,n);switch(e){case"aalt":case"salt":return"number"==typeof t.by?this.addSingle(e,t,r,n):this.addAlternate(e,t,r,n);case"dlig":case"liga":case"rlig":return this.addLigature(e,t,r,n);case"ccmp":return t.by instanceof Array?this.addMultiple(e,t,r,n):this.addLigature(e,t,r,n)}};var Ht,zt,Wt,qt,_t={getPath:At,parse:function(e,t,r,n,a){return a.lowMemory?function(e,t,r,n){var a=new Be.GlyphSet(n);return n._push=function(o){var s=r[o];s!==r[o+1]?a.push(o,Be.ttfGlyphLoader(n,o,Ft,e,t+s,Nt)):a.push(o,Be.glyphLoader(n,o))},a}(e,t,r,n):function(e,t,r,n){for(var a=new Be.GlyphSet(n),o=0;o<r.length-1;o+=1){var s=r[o];s!==r[o+1]?a.push(o,Be.ttfGlyphLoader(n,o,Ft,e,t+s,Nt)):a.push(o,Be.glyphLoader(n,o))}return a}(e,t,r,n)}};function Xt(e){this.font=e,this.getCommands=function(e){return _t.getPath(e).commands},this._fpgmState=this._prepState=void 0,this._errorState=0}function Vt(e){return e}function jt(e){return Math.sign(e)*Math.round(Math.abs(e))}function Yt(e){return Math.sign(e)*Math.round(Math.abs(2*e))/2}function Zt(e){return Math.sign(e)*(Math.round(Math.abs(e)+.5)-.5)}function Qt(e){return Math.sign(e)*Math.ceil(Math.abs(e))}function Kt(e){return Math.sign(e)*Math.floor(Math.abs(e))}var Jt=function(e){var t=this.srPeriod,r=this.srPhase,n=1;return e<0&&(e=-e,n=-1),e+=this.srThreshold-r,e=Math.trunc(e/t)*t,(e+=r)<0?r*n:e*n},$t={x:1,y:0,axis:"x",distance:function(e,t,r,n){return(r?e.xo:e.x)-(n?t.xo:t.x)},interpolate:function(e,t,r,n){var a,o,s,i,u,l,p;if(!n||n===this)return a=e.xo-t.xo,o=e.xo-r.xo,u=t.x-t.xo,l=r.x-r.xo,0===(p=(s=Math.abs(a))+(i=Math.abs(o)))?void(e.x=e.xo+(u+l)/2):void(e.x=e.xo+(u*i+l*s)/p);a=n.distance(e,t,!0,!0),o=n.distance(e,r,!0,!0),u=n.distance(t,t,!1,!0),l=n.distance(r,r,!1,!0),0!==(p=(s=Math.abs(a))+(i=Math.abs(o)))?$t.setRelative(e,e,(u*i+l*s)/p,n,!0):$t.setRelative(e,e,(u+l)/2,n,!0)},normalSlope:Number.NEGATIVE_INFINITY,setRelative:function(e,t,r,n,a){if(n&&n!==this){var o=a?t.xo:t.x,s=a?t.yo:t.y,i=o+r*n.x,u=s+r*n.y;e.x=i+(e.y-u)/n.normalSlope}else e.x=(a?t.xo:t.x)+r},slope:0,touch:function(e){e.xTouched=!0},touched:function(e){return e.xTouched},untouch:function(e){e.xTouched=!1}},er={x:0,y:1,axis:"y",distance:function(e,t,r,n){return(r?e.yo:e.y)-(n?t.yo:t.y)},interpolate:function(e,t,r,n){var a,o,s,i,u,l,p;if(!n||n===this)return a=e.yo-t.yo,o=e.yo-r.yo,u=t.y-t.yo,l=r.y-r.yo,0===(p=(s=Math.abs(a))+(i=Math.abs(o)))?void(e.y=e.yo+(u+l)/2):void(e.y=e.yo+(u*i+l*s)/p);a=n.distance(e,t,!0,!0),o=n.distance(e,r,!0,!0),u=n.distance(t,t,!1,!0),l=n.distance(r,r,!1,!0),0!==(p=(s=Math.abs(a))+(i=Math.abs(o)))?er.setRelative(e,e,(u*i+l*s)/p,n,!0):er.setRelative(e,e,(u+l)/2,n,!0)},normalSlope:0,setRelative:function(e,t,r,n,a){if(n&&n!==this){var o=a?t.xo:t.x,s=a?t.yo:t.y,i=o+r*n.x,u=s+r*n.y;e.y=u+n.normalSlope*(e.x-i)}else e.y=(a?t.yo:t.y)+r},slope:Number.POSITIVE_INFINITY,touch:function(e){e.yTouched=!0},touched:function(e){return e.yTouched},untouch:function(e){e.yTouched=!1}};function tr(e,t){this.x=e,this.y=t,this.axis=void 0,this.slope=t/e,this.normalSlope=-e/t,Object.freeze(this)}function rr(e,t){var r=Math.sqrt(e*e+t*t);return t/=r,1===(e/=r)&&0===t?$t:0===e&&1===t?er:new tr(e,t)}function nr(e,t,r,n){this.x=this.xo=Math.round(64*e)/64,this.y=this.yo=Math.round(64*t)/64,this.lastPointOfContour=r,this.onCurve=n,this.prevPointOnContour=void 0,this.nextPointOnContour=void 0,this.xTouched=!1,this.yTouched=!1,Object.preventExtensions(this)}Object.freeze($t),Object.freeze(er),tr.prototype.distance=function(e,t,r,n){return this.x*$t.distance(e,t,r,n)+this.y*er.distance(e,t,r,n)},tr.prototype.interpolate=function(e,t,r,n){var a,o,s,i,u,l,p;s=n.distance(e,t,!0,!0),i=n.distance(e,r,!0,!0),a=n.distance(t,t,!1,!0),o=n.distance(r,r,!1,!0),0!==(p=(u=Math.abs(s))+(l=Math.abs(i)))?this.setRelative(e,e,(a*l+o*u)/p,n,!0):this.setRelative(e,e,(a+o)/2,n,!0)},tr.prototype.setRelative=function(e,t,r,n,a){n=n||this;var o=a?t.xo:t.x,s=a?t.yo:t.y,i=o+r*n.x,u=s+r*n.y,l=n.normalSlope,p=this.slope,c=e.x,h=e.y;e.x=(p*c-l*i+u-h)/(p-l),e.y=p*(e.x-c)+h},tr.prototype.touch=function(e){e.xTouched=!0,e.yTouched=!0},nr.prototype.nextTouched=function(e){for(var t=this.nextPointOnContour;!e.touched(t)&&t!==this;)t=t.nextPointOnContour;return t},nr.prototype.prevTouched=function(e){for(var t=this.prevPointOnContour;!e.touched(t)&&t!==this;)t=t.prevPointOnContour;return t};var ar=Object.freeze(new nr(0,0)),or={cvCutIn:17/16,deltaBase:9,deltaShift:.125,loop:1,minDis:1,autoFlip:!0};function sr(e,t){switch(this.env=e,this.stack=[],this.prog=t,e){case"glyf":this.zp0=this.zp1=this.zp2=1,this.rp0=this.rp1=this.rp2=0;case"prep":this.fv=this.pv=this.dpv=$t,this.round=jt}}function ir(e){for(var t=e.tZone=new Array(e.gZone.length),r=0;r<t.length;r++)t[r]=new nr(0,0)}function ur(e,t){var r,n=e.prog,a=e.ip,o=1;do{if(88===(r=n[++a]))o++;else if(89===r)o--;else if(64===r)a+=n[a+1]+1;else if(65===r)a+=2*n[a+1]+1;else if(r>=176&&r<=183)a+=r-176+1;else if(r>=184&&r<=191)a+=2*(r-184+1);else if(t&&1===o&&27===r)break}while(o>0);e.ip=a}function lr(e,t){exports.DEBUG&&console.log(t.step,"SVTCA["+e.axis+"]"),t.fv=t.pv=t.dpv=e}function pr(e,t){exports.DEBUG&&console.log(t.step,"SPVTCA["+e.axis+"]"),t.pv=t.dpv=e}function cr(e,t){exports.DEBUG&&console.log(t.step,"SFVTCA["+e.axis+"]"),t.fv=e}function hr(e,t){var r,n,a=t.stack,o=a.pop(),s=a.pop(),i=t.z2[o],u=t.z1[s];exports.DEBUG&&console.log("SPVTL["+e+"]",o,s),e?(r=i.y-u.y,n=u.x-i.x):(r=u.x-i.x,n=u.y-i.y),t.pv=t.dpv=rr(r,n)}function fr(e,t){var r,n,a=t.stack,o=a.pop(),s=a.pop(),i=t.z2[o],u=t.z1[s];exports.DEBUG&&console.log("SFVTL["+e+"]",o,s),e?(r=i.y-u.y,n=u.x-i.x):(r=u.x-i.x,n=u.y-i.y),t.fv=rr(r,n)}function dr(e){exports.DEBUG&&console.log(e.step,"POP[]"),e.stack.pop()}function vr(e,t){var r=t.stack.pop(),n=t.z0[r],a=t.fv,o=t.pv;exports.DEBUG&&console.log(t.step,"MDAP["+e+"]",r);var s=o.distance(n,ar);e&&(s=t.round(s)),a.setRelative(n,ar,s,o),a.touch(n),t.rp0=t.rp1=r}function gr(e,t){var r,n,a,o=t.z2,s=o.length-2;exports.DEBUG&&console.log(t.step,"IUP["+e.axis+"]");for(var i=0;i<s;i++)r=o[i],e.touched(r)||(n=r.prevTouched(e))!==r&&(n===(a=r.nextTouched(e))&&e.setRelative(r,r,e.distance(n,n,!1,!0),e,!0),e.interpolate(r,n,a,e))}function mr(e,t){for(var r=t.stack,n=e?t.rp1:t.rp2,a=(e?t.z0:t.z1)[n],o=t.fv,s=t.pv,i=t.loop,u=t.z2;i--;){var l=r.pop(),p=u[l],c=s.distance(a,a,!1,!0);o.setRelative(p,p,c,s),o.touch(p),exports.DEBUG&&console.log(t.step,(t.loop>1?"loop "+(t.loop-i)+": ":"")+"SHP["+(e?"rp1":"rp2")+"]",l)}t.loop=1}function yr(e,t){var r=t.stack,n=e?t.rp1:t.rp2,a=(e?t.z0:t.z1)[n],o=t.fv,s=t.pv,i=r.pop(),u=t.z2[t.contours[i]],l=u;exports.DEBUG&&console.log(t.step,"SHC["+e+"]",i);var p=s.distance(a,a,!1,!0);do{l!==a&&o.setRelative(l,l,p,s),l=l.nextPointOnContour}while(l!==u)}function br(e,t){var r,n,a=t.stack,o=e?t.rp1:t.rp2,s=(e?t.z0:t.z1)[o],i=t.fv,u=t.pv,l=a.pop();switch(exports.DEBUG&&console.log(t.step,"SHZ["+e+"]",l),l){case 0:r=t.tZone;break;case 1:r=t.gZone;break;default:throw new Error("Invalid zone")}for(var p=u.distance(s,s,!1,!0),c=r.length-2,h=0;h<c;h++)n=r[h],i.setRelative(n,n,p,u)}function Sr(e,t){var r=t.stack,n=r.pop()/64,a=r.pop(),o=t.z1[a],s=t.z0[t.rp0],i=t.fv,u=t.pv;i.setRelative(o,s,n,u),i.touch(o),exports.DEBUG&&console.log(t.step,"MSIRP["+e+"]",n,a),t.rp1=t.rp0,t.rp2=a,e&&(t.rp0=a)}function xr(e,t){var r=t.stack,n=r.pop(),a=r.pop(),o=t.z0[a],s=t.fv,i=t.pv,u=t.cvt[n];exports.DEBUG&&console.log(t.step,"MIAP["+e+"]",n,"(",u,")",a);var l=i.distance(o,ar);e&&(Math.abs(l-u)<t.cvCutIn&&(l=u),l=t.round(l)),s.setRelative(o,ar,l,i),0===t.zp0&&(o.xo=o.x,o.yo=o.y),s.touch(o),t.rp0=t.rp1=a}function Tr(e,t){var r=t.stack,n=r.pop(),a=t.z2[n];exports.DEBUG&&console.log(t.step,"GC["+e+"]",n),r.push(64*t.dpv.distance(a,ar,e,!1))}function Ur(e,t){var r=t.stack,n=r.pop(),a=r.pop(),o=t.z1[n],s=t.z0[a],i=t.dpv.distance(s,o,e,e);exports.DEBUG&&console.log(t.step,"MD["+e+"]",n,a,"->",i),t.stack.push(Math.round(64*i))}function kr(e,t){var r=t.stack,n=r.pop(),a=t.fv,o=t.pv,s=t.ppem,i=t.deltaBase+16*(e-1),u=t.deltaShift,l=t.z0;exports.DEBUG&&console.log(t.step,"DELTAP["+e+"]",n,r);for(var p=0;p<n;p++){var c=r.pop(),h=r.pop();if(i+((240&h)>>4)===s){var f=(15&h)-8;f>=0&&f++,exports.DEBUG&&console.log(t.step,"DELTAPFIX",c,"by",f*u);var d=l[c];a.setRelative(d,d,f*u,o)}}}function Or(e,t){var r=t.stack,n=r.pop();exports.DEBUG&&console.log(t.step,"ROUND[]"),r.push(64*t.round(n/64))}function Rr(e,t){var r=t.stack,n=r.pop(),a=t.ppem,o=t.deltaBase+16*(e-1),s=t.deltaShift;exports.DEBUG&&console.log(t.step,"DELTAC["+e+"]",n,r);for(var i=0;i<n;i++){var u=r.pop(),l=r.pop();if(o+((240&l)>>4)===a){var p=(15&l)-8;p>=0&&p++;var c=p*s;exports.DEBUG&&console.log(t.step,"DELTACFIX",u,"by",c),t.cvt[u]+=c}}}function Er(e,t){var r,n,a=t.stack,o=a.pop(),s=a.pop(),i=t.z2[o],u=t.z1[s];exports.DEBUG&&console.log(t.step,"SDPVTL["+e+"]",o,s),e?(r=i.y-u.y,n=u.x-i.x):(r=u.x-i.x,n=u.y-i.y),t.dpv=rr(r,n)}function Lr(e,t){var r=t.stack,n=t.prog,a=t.ip;exports.DEBUG&&console.log(t.step,"PUSHB["+e+"]");for(var o=0;o<e;o++)r.push(n[++a]);t.ip=a}function Cr(e,t){var r=t.ip,n=t.prog,a=t.stack;exports.DEBUG&&console.log(t.ip,"PUSHW["+e+"]");for(var o=0;o<e;o++){var s=n[++r]<<8|n[++r];32768&s&&(s=-(1+(65535^s))),a.push(s)}t.ip=r}function wr(e,t,r,n,a,o){var s,i,u,l,p=o.stack,c=e&&p.pop(),h=p.pop(),f=o.rp0,d=o.z0[f],v=o.z1[h],g=o.minDis,m=o.fv,y=o.dpv;u=(i=s=y.distance(v,d,!0,!0))>=0?1:-1,i=Math.abs(i),e&&(l=o.cvt[c],n&&Math.abs(i-l)<o.cvCutIn&&(i=l)),r&&i<g&&(i=g),n&&(i=o.round(i)),m.setRelative(v,d,u*i,y),m.touch(v),exports.DEBUG&&console.log(o.step,(e?"MIRP[":"MDRP[")+(t?"M":"m")+(r?">":"_")+(n?"R":"_")+(0===a?"Gr":1===a?"Bl":2===a?"Wh":"")+"]",e?c+"("+o.cvt[c]+","+l+")":"",h,"(d =",s,"->",u*i,")"),o.rp1=o.rp0,o.rp2=h,t&&(o.rp0=h)}function Dr(e){this.char=e,this.state={},this.activeState=null}function Ir(e,t,r){this.contextName=r,this.startIndex=e,this.endOffset=t}function Gr(e,t,r){this.contextName=e,this.openRange=null,this.ranges=[],this.checkStart=t,this.checkEnd=r}function Mr(e,t){this.context=e,this.index=t,this.length=e.length,this.current=e[t],this.backtrack=e.slice(0,t),this.lookahead=e.slice(t+1)}function Br(e){this.eventId=e,this.subscribers=[]}function Fr(e){var t=this,r=["start","end","next","newToken","contextStart","contextEnd","insertToken","removeToken","removeRange","replaceToken","replaceRange","composeRUD","updateContextsRanges"];r.forEach((function(e){Object.defineProperty(t.events,e,{value:new Br(e)})})),e&&r.forEach((function(r){var n=e[r];"function"==typeof n&&t.events[r].subscribe(n)}));["insertToken","removeToken","removeRange","replaceToken","replaceRange","composeRUD"].forEach((function(e){t.events[e].subscribe(t.updateContextsRanges)}))}function Pr(e){this.tokens=[],this.registeredContexts={},this.contextCheckers=[],this.events={},this.registeredModifiers=[],Fr.call(this,e)}function Ar(e){return/[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(e)}function Nr(e){return/[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(e)}function Hr(e){return/[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(e)}function zr(e){return/[A-z]/.test(e)}function Wr(e){this.font=e,this.features={}}function qr(e){this.id=e.id,this.tag=e.tag,this.substitution=e.substitution}function _r(e,t){if(!e)return-1;switch(t.format){case 1:return t.glyphs.indexOf(e);case 2:for(var r=t.ranges,n=0;n<r.length;n++){var a=r[n];if(e>=a.start&&e<=a.end){var o=e-a.start;return a.index+o}}break;default:return-1}return-1}function Xr(e,t){return-1===_r(e,t.coverage)?null:e+t.deltaGlyphId}function Vr(e,t){var r=_r(e,t.coverage);return-1===r?null:t.substitute[r]}function jr(e,t){for(var r=[],n=0;n<e.length;n++){var a=e[n],o=t.current,s=_r(o=Array.isArray(o)?o[0]:o,a);-1!==s&&r.push(s)}return r.length!==e.length?-1:r}function Yr(e,t){var r=t.inputCoverage.length+t.lookaheadCoverage.length+t.backtrackCoverage.length;if(e.context.length<r)return[];var n=jr(t.inputCoverage,e);if(-1===n)return[];var a=t.inputCoverage.length-1;if(e.lookahead.length<t.lookaheadCoverage.length)return[];for(var o=e.lookahead.slice(a);o.length&&Hr(o[0].char);)o.shift();var s=new Mr(o,0),i=jr(t.lookaheadCoverage,s),u=[].concat(e.backtrack);for(u.reverse();u.length&&Hr(u[0].char);)u.shift();if(u.length<t.backtrackCoverage.length)return[];var l=new Mr(u,0),p=jr(t.backtrackCoverage,l),c=[];if(n.length===t.inputCoverage.length&&i.length===t.lookaheadCoverage.length&&p.length===t.backtrackCoverage.length)for(var h=0;h<t.lookupRecords.length;h++)for(var f=t.lookupRecords[h].lookupListIndex,d=this.getLookupByIndex(f),v=0;v<d.subtables.length;v++){var g=d.subtables[v],m=this.getLookupMethod(d,g);if("12"===this.getSubstitutionType(d,g))for(var y=0;y<n.length;y++){var b=m(e.get(y));b&&c.push(b)}}return c}function Zr(e,t){var r,n=_r(e.current,t.coverage);if(-1===n)return null;for(var a=t.ligatureSets[n],o=0;o<a.length;o++){r=a[o];for(var s=0;s<r.components.length;s++){if(e.lookahead[s]!==r.components[s])break;if(s===r.components.length-1)return r}}return null}function Qr(e,t){var r=_r(e,t.coverage);return-1===r?null:t.sequences[r]}Xt.prototype.exec=function(e,t){if("number"!=typeof t)throw new Error("Point size is not a number!");if(!(this._errorState>2)){var r=this.font,n=this._prepState;if(!n||n.ppem!==t){var a=this._fpgmState;if(!a){sr.prototype=or,(a=this._fpgmState=new sr("fpgm",r.tables.fpgm)).funcs=[],a.font=r,exports.DEBUG&&(console.log("---EXEC FPGM---"),a.step=-1);try{zt(a)}catch(e){return console.log("Hinting error in FPGM:"+e),void(this._errorState=3)}}sr.prototype=a,(n=this._prepState=new sr("prep",r.tables.prep)).ppem=t;var o=r.tables.cvt;if(o)for(var s=n.cvt=new Array(o.length),i=t/r.unitsPerEm,u=0;u<o.length;u++)s[u]=o[u]*i;else n.cvt=[];exports.DEBUG&&(console.log("---EXEC PREP---"),n.step=-1);try{zt(n)}catch(e){this._errorState<2&&console.log("Hinting error in PREP:"+e),this._errorState=2}}if(!(this._errorState>1))try{return Wt(e,n)}catch(e){return this._errorState<1&&(console.log("Hinting error:"+e),console.log("Note: further hinting errors are silenced")),void(this._errorState=1)}}},Wt=function(e,t){var r,n,a,o=t.ppem/t.font.unitsPerEm,s=o,i=e.components;if(sr.prototype=t,i){var u=t.font;n=[],r=[];for(var l=0;l<i.length;l++){var p=i[l],c=u.glyphs.get(p.glyphIndex);a=new sr("glyf",c.instructions),exports.DEBUG&&(console.log("---EXEC COMP "+l+"---"),a.step=-1),qt(c,a,o,s);for(var h=Math.round(p.dx*o),f=Math.round(p.dy*s),d=a.gZone,v=a.contours,g=0;g<d.length;g++){var m=d[g];m.xTouched=m.yTouched=!1,m.xo=m.x=m.x+h,m.yo=m.y=m.y+f}var y=n.length;n.push.apply(n,d);for(var b=0;b<v.length;b++)r.push(v[b]+y)}e.instructions&&!a.inhibitGridFit&&((a=new sr("glyf",e.instructions)).gZone=a.z0=a.z1=a.z2=n,a.contours=r,n.push(new nr(0,0),new nr(Math.round(e.advanceWidth*o),0)),exports.DEBUG&&(console.log("---EXEC COMPOSITE---"),a.step=-1),zt(a),n.length-=2)}else a=new sr("glyf",e.instructions),exports.DEBUG&&(console.log("---EXEC GLYPH---"),a.step=-1),qt(e,a,o,s),n=a.gZone;return n},qt=function(e,t,r,n){for(var a,o,s,i=e.points||[],u=i.length,l=t.gZone=t.z0=t.z1=t.z2=[],p=t.contours=[],c=0;c<u;c++)a=i[c],l[c]=new nr(a.x*r,a.y*n,a.lastPointOfContour,a.onCurve);for(var h=0;h<u;h++)a=l[h],o||(o=a,p.push(h)),a.lastPointOfContour?(a.nextPointOnContour=o,o.prevPointOnContour=a,o=void 0):(s=l[h+1],a.nextPointOnContour=s,s.prevPointOnContour=a);if(!t.inhibitGridFit){if(exports.DEBUG){console.log("PROCESSING GLYPH",t.stack);for(var f=0;f<u;f++)console.log(f,l[f].x,l[f].y)}if(l.push(new nr(0,0),new nr(Math.round(e.advanceWidth*r),0)),zt(t),l.length-=2,exports.DEBUG){console.log("FINISHED GLYPH",t.stack);for(var d=0;d<u;d++)console.log(d,l[d].x,l[d].y)}}},zt=function(e){var t=e.prog;if(t){var r,n=t.length;for(e.ip=0;e.ip<n;e.ip++){if(exports.DEBUG&&e.step++,!(r=Ht[t[e.ip]]))throw new Error("unknown instruction: 0x"+Number(t[e.ip]).toString(16));r(e)}}},Ht=[lr.bind(void 0,er),lr.bind(void 0,$t),pr.bind(void 0,er),pr.bind(void 0,$t),cr.bind(void 0,er),cr.bind(void 0,$t),hr.bind(void 0,0),hr.bind(void 0,1),fr.bind(void 0,0),fr.bind(void 0,1),function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"SPVFS[]",r,n),e.pv=e.dpv=rr(n,r)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"SPVFS[]",r,n),e.fv=rr(n,r)},function(e){var t=e.stack,r=e.pv;exports.DEBUG&&console.log(e.step,"GPV[]"),t.push(16384*r.x),t.push(16384*r.y)},function(e){var t=e.stack,r=e.fv;exports.DEBUG&&console.log(e.step,"GFV[]"),t.push(16384*r.x),t.push(16384*r.y)},function(e){e.fv=e.pv,exports.DEBUG&&console.log(e.step,"SFVTPV[]")},function(e){var t=e.stack,r=t.pop(),n=t.pop(),a=t.pop(),o=t.pop(),s=t.pop(),i=e.z0,u=e.z1,l=i[r],p=i[n],c=u[a],h=u[o],f=e.z2[s];exports.DEBUG&&console.log("ISECT[], ",r,n,a,o,s);var d=l.x,v=l.y,g=p.x,m=p.y,y=c.x,b=c.y,S=h.x,x=h.y,T=(d-g)*(b-x)-(v-m)*(y-S),U=d*m-v*g,k=y*x-b*S;f.x=(U*(y-S)-k*(d-g))/T,f.y=(U*(b-x)-k*(v-m))/T},function(e){e.rp0=e.stack.pop(),exports.DEBUG&&console.log(e.step,"SRP0[]",e.rp0)},function(e){e.rp1=e.stack.pop(),exports.DEBUG&&console.log(e.step,"SRP1[]",e.rp1)},function(e){e.rp2=e.stack.pop(),exports.DEBUG&&console.log(e.step,"SRP2[]",e.rp2)},function(e){var t=e.stack.pop();switch(exports.DEBUG&&console.log(e.step,"SZP0[]",t),e.zp0=t,t){case 0:e.tZone||ir(e),e.z0=e.tZone;break;case 1:e.z0=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){var t=e.stack.pop();switch(exports.DEBUG&&console.log(e.step,"SZP1[]",t),e.zp1=t,t){case 0:e.tZone||ir(e),e.z1=e.tZone;break;case 1:e.z1=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){var t=e.stack.pop();switch(exports.DEBUG&&console.log(e.step,"SZP2[]",t),e.zp2=t,t){case 0:e.tZone||ir(e),e.z2=e.tZone;break;case 1:e.z2=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){var t=e.stack.pop();switch(exports.DEBUG&&console.log(e.step,"SZPS[]",t),e.zp0=e.zp1=e.zp2=t,t){case 0:e.tZone||ir(e),e.z0=e.z1=e.z2=e.tZone;break;case 1:e.z0=e.z1=e.z2=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){e.loop=e.stack.pop(),exports.DEBUG&&console.log(e.step,"SLOOP[]",e.loop)},function(e){exports.DEBUG&&console.log(e.step,"RTG[]"),e.round=jt},function(e){exports.DEBUG&&console.log(e.step,"RTHG[]"),e.round=Zt},function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"SMD[]",t),e.minDis=t/64},function(e){exports.DEBUG&&console.log(e.step,"ELSE[]"),ur(e,!1)},function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"JMPR[]",t),e.ip+=t-1},function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"SCVTCI[]",t),e.cvCutIn=t/64},void 0,void 0,function(e){var t=e.stack;exports.DEBUG&&console.log(e.step,"DUP[]"),t.push(t[t.length-1])},dr,function(e){exports.DEBUG&&console.log(e.step,"CLEAR[]"),e.stack.length=0},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"SWAP[]"),t.push(r),t.push(n)},function(e){var t=e.stack;exports.DEBUG&&console.log(e.step,"DEPTH[]"),t.push(t.length)},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"CINDEX[]",r),t.push(t[t.length-r])},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"MINDEX[]",r),t.push(t.splice(t.length-r,1)[0])},void 0,void 0,void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"LOOPCALL[]",r,n);var a=e.ip,o=e.prog;e.prog=e.funcs[r];for(var s=0;s<n;s++)zt(e),exports.DEBUG&&console.log(++e.step,s+1<n?"next loopcall":"done loopcall",s);e.ip=a,e.prog=o},function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"CALL[]",t);var r=e.ip,n=e.prog;e.prog=e.funcs[t],zt(e),e.ip=r,e.prog=n,exports.DEBUG&&console.log(++e.step,"returning from",t)},function(e){if("fpgm"!==e.env)throw new Error("FDEF not allowed here");var t=e.stack,r=e.prog,n=e.ip,a=t.pop(),o=n;for(exports.DEBUG&&console.log(e.step,"FDEF[]",a);45!==r[++n];);e.ip=n,e.funcs[a]=r.slice(o+1,n)},void 0,vr.bind(void 0,0),vr.bind(void 0,1),gr.bind(void 0,er),gr.bind(void 0,$t),mr.bind(void 0,0),mr.bind(void 0,1),yr.bind(void 0,0),yr.bind(void 0,1),br.bind(void 0,0),br.bind(void 0,1),function(e){for(var t=e.stack,r=e.loop,n=e.fv,a=t.pop()/64,o=e.z2;r--;){var s=t.pop(),i=o[s];exports.DEBUG&&console.log(e.step,(e.loop>1?"loop "+(e.loop-r)+": ":"")+"SHPIX[]",s,a),n.setRelative(i,i,a),n.touch(i)}e.loop=1},function(e){for(var t=e.stack,r=e.rp1,n=e.rp2,a=e.loop,o=e.z0[r],s=e.z1[n],i=e.fv,u=e.dpv,l=e.z2;a--;){var p=t.pop(),c=l[p];exports.DEBUG&&console.log(e.step,(e.loop>1?"loop "+(e.loop-a)+": ":"")+"IP[]",p,r,"<->",n),i.interpolate(c,o,s,u),i.touch(c)}e.loop=1},Sr.bind(void 0,0),Sr.bind(void 0,1),function(e){for(var t=e.stack,r=e.rp0,n=e.z0[r],a=e.loop,o=e.fv,s=e.pv,i=e.z1;a--;){var u=t.pop(),l=i[u];exports.DEBUG&&console.log(e.step,(e.loop>1?"loop "+(e.loop-a)+": ":"")+"ALIGNRP[]",u),o.setRelative(l,n,0,s),o.touch(l)}e.loop=1},function(e){exports.DEBUG&&console.log(e.step,"RTDG[]"),e.round=Yt},xr.bind(void 0,0),xr.bind(void 0,1),function(e){var t=e.prog,r=e.ip,n=e.stack,a=t[++r];exports.DEBUG&&console.log(e.step,"NPUSHB[]",a);for(var o=0;o<a;o++)n.push(t[++r]);e.ip=r},function(e){var t=e.ip,r=e.prog,n=e.stack,a=r[++t];exports.DEBUG&&console.log(e.step,"NPUSHW[]",a);for(var o=0;o<a;o++){var s=r[++t]<<8|r[++t];32768&s&&(s=-(1+(65535^s))),n.push(s)}e.ip=t},function(e){var t=e.stack,r=e.store;r||(r=e.store=[]);var n=t.pop(),a=t.pop();exports.DEBUG&&console.log(e.step,"WS",n,a),r[a]=n},function(e){var t=e.stack,r=e.store,n=t.pop();exports.DEBUG&&console.log(e.step,"RS",n);var a=r&&r[n]||0;t.push(a)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"WCVTP",r,n),e.cvt[n]=r/64},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"RCVT",r),t.push(64*e.cvt[r])},Tr.bind(void 0,0),Tr.bind(void 0,1),void 0,Ur.bind(void 0,0),Ur.bind(void 0,1),function(e){exports.DEBUG&&console.log(e.step,"MPPEM[]"),e.stack.push(e.ppem)},void 0,function(e){exports.DEBUG&&console.log(e.step,"FLIPON[]"),e.autoFlip=!0},void 0,void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"LT[]",r,n),t.push(n<r?1:0)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"LTEQ[]",r,n),t.push(n<=r?1:0)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"GT[]",r,n),t.push(n>r?1:0)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"GTEQ[]",r,n),t.push(n>=r?1:0)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"EQ[]",r,n),t.push(r===n?1:0)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"NEQ[]",r,n),t.push(r!==n?1:0)},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"ODD[]",r),t.push(Math.trunc(r)%2?1:0)},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"EVEN[]",r),t.push(Math.trunc(r)%2?0:1)},function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"IF[]",t),t||(ur(e,!0),exports.DEBUG&&console.log(e.step,"EIF[]"))},function(e){exports.DEBUG&&console.log(e.step,"EIF[]")},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"AND[]",r,n),t.push(r&&n?1:0)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"OR[]",r,n),t.push(r||n?1:0)},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"NOT[]",r),t.push(r?0:1)},kr.bind(void 0,1),function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"SDB[]",t),e.deltaBase=t},function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"SDS[]",t),e.deltaShift=Math.pow(.5,t)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"ADD[]",r,n),t.push(n+r)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"SUB[]",r,n),t.push(n-r)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"DIV[]",r,n),t.push(64*n/r)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"MUL[]",r,n),t.push(n*r/64)},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"ABS[]",r),t.push(Math.abs(r))},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"NEG[]",r),t.push(-r)},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"FLOOR[]",r),t.push(64*Math.floor(r/64))},function(e){var t=e.stack,r=t.pop();exports.DEBUG&&console.log(e.step,"CEILING[]",r),t.push(64*Math.ceil(r/64))},Or.bind(void 0,0),Or.bind(void 0,1),Or.bind(void 0,2),Or.bind(void 0,3),void 0,void 0,void 0,void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"WCVTF[]",r,n),e.cvt[n]=r*e.ppem/e.font.unitsPerEm},kr.bind(void 0,2),kr.bind(void 0,3),Rr.bind(void 0,1),Rr.bind(void 0,2),Rr.bind(void 0,3),function(e){var t,r=e.stack.pop();switch(exports.DEBUG&&console.log(e.step,"SROUND[]",r),e.round=Jt,192&r){case 0:t=.5;break;case 64:t=1;break;case 128:t=2;break;default:throw new Error("invalid SROUND value")}switch(e.srPeriod=t,48&r){case 0:e.srPhase=0;break;case 16:e.srPhase=.25*t;break;case 32:e.srPhase=.5*t;break;case 48:e.srPhase=.75*t;break;default:throw new Error("invalid SROUND value")}r&=15,e.srThreshold=0===r?0:(r/8-.5)*t},function(e){var t,r=e.stack.pop();switch(exports.DEBUG&&console.log(e.step,"S45ROUND[]",r),e.round=Jt,192&r){case 0:t=Math.sqrt(2)/2;break;case 64:t=Math.sqrt(2);break;case 128:t=2*Math.sqrt(2);break;default:throw new Error("invalid S45ROUND value")}switch(e.srPeriod=t,48&r){case 0:e.srPhase=0;break;case 16:e.srPhase=.25*t;break;case 32:e.srPhase=.5*t;break;case 48:e.srPhase=.75*t;break;default:throw new Error("invalid S45ROUND value")}r&=15,e.srThreshold=0===r?0:(r/8-.5)*t},void 0,void 0,function(e){exports.DEBUG&&console.log(e.step,"ROFF[]"),e.round=Vt},void 0,function(e){exports.DEBUG&&console.log(e.step,"RUTG[]"),e.round=Qt},function(e){exports.DEBUG&&console.log(e.step,"RDTG[]"),e.round=Kt},dr,dr,void 0,void 0,void 0,void 0,void 0,function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"SCANCTRL[]",t)},Er.bind(void 0,0),Er.bind(void 0,1),function(e){var t=e.stack,r=t.pop(),n=0;exports.DEBUG&&console.log(e.step,"GETINFO[]",r),1&r&&(n=35),32&r&&(n|=4096),t.push(n)},void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop(),a=t.pop();exports.DEBUG&&console.log(e.step,"ROLL[]"),t.push(n),t.push(r),t.push(a)},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"MAX[]",r,n),t.push(Math.max(n,r))},function(e){var t=e.stack,r=t.pop(),n=t.pop();exports.DEBUG&&console.log(e.step,"MIN[]",r,n),t.push(Math.min(n,r))},function(e){var t=e.stack.pop();exports.DEBUG&&console.log(e.step,"SCANTYPE[]",t)},function(e){var t=e.stack.pop(),r=e.stack.pop();switch(exports.DEBUG&&console.log(e.step,"INSTCTRL[]",t,r),t){case 1:return void(e.inhibitGridFit=!!r);case 2:return void(e.ignoreCvt=!!r);default:throw new Error("invalid INSTCTRL[] selector")}},void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,Lr.bind(void 0,1),Lr.bind(void 0,2),Lr.bind(void 0,3),Lr.bind(void 0,4),Lr.bind(void 0,5),Lr.bind(void 0,6),Lr.bind(void 0,7),Lr.bind(void 0,8),Cr.bind(void 0,1),Cr.bind(void 0,2),Cr.bind(void 0,3),Cr.bind(void 0,4),Cr.bind(void 0,5),Cr.bind(void 0,6),Cr.bind(void 0,7),Cr.bind(void 0,8),wr.bind(void 0,0,0,0,0,0),wr.bind(void 0,0,0,0,0,1),wr.bind(void 0,0,0,0,0,2),wr.bind(void 0,0,0,0,0,3),wr.bind(void 0,0,0,0,1,0),wr.bind(void 0,0,0,0,1,1),wr.bind(void 0,0,0,0,1,2),wr.bind(void 0,0,0,0,1,3),wr.bind(void 0,0,0,1,0,0),wr.bind(void 0,0,0,1,0,1),wr.bind(void 0,0,0,1,0,2),wr.bind(void 0,0,0,1,0,3),wr.bind(void 0,0,0,1,1,0),wr.bind(void 0,0,0,1,1,1),wr.bind(void 0,0,0,1,1,2),wr.bind(void 0,0,0,1,1,3),wr.bind(void 0,0,1,0,0,0),wr.bind(void 0,0,1,0,0,1),wr.bind(void 0,0,1,0,0,2),wr.bind(void 0,0,1,0,0,3),wr.bind(void 0,0,1,0,1,0),wr.bind(void 0,0,1,0,1,1),wr.bind(void 0,0,1,0,1,2),wr.bind(void 0,0,1,0,1,3),wr.bind(void 0,0,1,1,0,0),wr.bind(void 0,0,1,1,0,1),wr.bind(void 0,0,1,1,0,2),wr.bind(void 0,0,1,1,0,3),wr.bind(void 0,0,1,1,1,0),wr.bind(void 0,0,1,1,1,1),wr.bind(void 0,0,1,1,1,2),wr.bind(void 0,0,1,1,1,3),wr.bind(void 0,1,0,0,0,0),wr.bind(void 0,1,0,0,0,1),wr.bind(void 0,1,0,0,0,2),wr.bind(void 0,1,0,0,0,3),wr.bind(void 0,1,0,0,1,0),wr.bind(void 0,1,0,0,1,1),wr.bind(void 0,1,0,0,1,2),wr.bind(void 0,1,0,0,1,3),wr.bind(void 0,1,0,1,0,0),wr.bind(void 0,1,0,1,0,1),wr.bind(void 0,1,0,1,0,2),wr.bind(void 0,1,0,1,0,3),wr.bind(void 0,1,0,1,1,0),wr.bind(void 0,1,0,1,1,1),wr.bind(void 0,1,0,1,1,2),wr.bind(void 0,1,0,1,1,3),wr.bind(void 0,1,1,0,0,0),wr.bind(void 0,1,1,0,0,1),wr.bind(void 0,1,1,0,0,2),wr.bind(void 0,1,1,0,0,3),wr.bind(void 0,1,1,0,1,0),wr.bind(void 0,1,1,0,1,1),wr.bind(void 0,1,1,0,1,2),wr.bind(void 0,1,1,0,1,3),wr.bind(void 0,1,1,1,0,0),wr.bind(void 0,1,1,1,0,1),wr.bind(void 0,1,1,1,0,2),wr.bind(void 0,1,1,1,0,3),wr.bind(void 0,1,1,1,1,0),wr.bind(void 0,1,1,1,1,1),wr.bind(void 0,1,1,1,1,2),wr.bind(void 0,1,1,1,1,3)],Dr.prototype.setState=function(e,t){return this.state[e]=t,this.activeState={key:e,value:this.state[e]},this.activeState},Dr.prototype.getState=function(e){return this.state[e]||null},Pr.prototype.inboundIndex=function(e){return e>=0&&e<this.tokens.length},Pr.prototype.composeRUD=function(e){var t=this,r=e.map((function(e){return t[e[0]].apply(t,e.slice(1).concat(true))})),n=function(e){return"object"==typeof e&&e.hasOwnProperty("FAIL")};if(r.every(n))return{FAIL:"composeRUD: one or more operations hasn't completed successfully",report:r.filter(n)};this.dispatch("composeRUD",[r.filter((function(e){return!n(e)}))])},Pr.prototype.replaceRange=function(e,t,r,n){t=null!==t?t:this.tokens.length;var a=r.every((function(e){return e instanceof Dr}));if(!isNaN(e)&&this.inboundIndex(e)&&a){var o=this.tokens.splice.apply(this.tokens,[e,t].concat(r));return n||this.dispatch("replaceToken",[e,t,r]),[o,r]}return{FAIL:"replaceRange: invalid tokens or startIndex."}},Pr.prototype.replaceToken=function(e,t,r){if(!isNaN(e)&&this.inboundIndex(e)&&t instanceof Dr){var n=this.tokens.splice(e,1,t);return r||this.dispatch("replaceToken",[e,t]),[n[0],t]}return{FAIL:"replaceToken: invalid token or index."}},Pr.prototype.removeRange=function(e,t,r){t=isNaN(t)?this.tokens.length:t;var n=this.tokens.splice(e,t);return r||this.dispatch("removeRange",[n,e,t]),n},Pr.prototype.removeToken=function(e,t){if(!isNaN(e)&&this.inboundIndex(e)){var r=this.tokens.splice(e,1);return t||this.dispatch("removeToken",[r,e]),r}return{FAIL:"removeToken: invalid token index."}},Pr.prototype.insertToken=function(e,t,r){return e.every((function(e){return e instanceof Dr}))?(this.tokens.splice.apply(this.tokens,[t,0].concat(e)),r||this.dispatch("insertToken",[e,t]),e):{FAIL:"insertToken: invalid token(s)."}},Pr.prototype.registerModifier=function(e,t,r){this.events.newToken.subscribe((function(n,a){var o=[n,a],s=[n,a];if(null===t||!0===t.apply(this,o)){var i=r.apply(this,s);n.setState(e,i)}})),this.registeredModifiers.push(e)},Br.prototype.subscribe=function(e){return"function"==typeof e?this.subscribers.push(e)-1:{FAIL:"invalid '"+this.eventId+"' event handler"}},Br.prototype.unsubscribe=function(e){this.subscribers.splice(e,1)},Mr.prototype.setCurrentIndex=function(e){this.index=e,this.current=this.context[e],this.backtrack=this.context.slice(0,e),this.lookahead=this.context.slice(e+1)},Mr.prototype.get=function(e){switch(!0){case 0===e:return this.current;case e<0&&Math.abs(e)<=this.backtrack.length:return this.backtrack.slice(e)[0];case e>0&&e<=this.lookahead.length:return this.lookahead[e-1];default:return null}},Pr.prototype.rangeToText=function(e){if(e instanceof Ir)return this.getRangeTokens(e).map((function(e){return e.char})).join("")},Pr.prototype.getText=function(){return this.tokens.map((function(e){return e.char})).join("")},Pr.prototype.getContext=function(e){var t=this.registeredContexts[e];return t||null},Pr.prototype.on=function(e,t){var r=this.events[e];return r?r.subscribe(t):null},Pr.prototype.dispatch=function(e,t){var r=this,n=this.events[e];n instanceof Br&&n.subscribers.forEach((function(e){e.apply(r,t||[])}))},Pr.prototype.registerContextChecker=function(e,t,r){if(this.getContext(e))return{FAIL:"context name '"+e+"' is already registered."};if("function"!=typeof t)return{FAIL:"missing context start check."};if("function"!=typeof r)return{FAIL:"missing context end check."};var n=new Gr(e,t,r);return this.registeredContexts[e]=n,this.contextCheckers.push(n),n},Pr.prototype.getRangeTokens=function(e){var t=e.startIndex+e.endOffset;return[].concat(this.tokens.slice(e.startIndex,t))},Pr.prototype.getContextRanges=function(e){var t=this.getContext(e);return t?t.ranges:{FAIL:"context checker '"+e+"' is not registered."}},Pr.prototype.resetContextsRanges=function(){var e=this.registeredContexts;for(var t in e){if(e.hasOwnProperty(t))e[t].ranges=[]}},Pr.prototype.updateContextsRanges=function(){this.resetContextsRanges();for(var e=this.tokens.map((function(e){return e.char})),t=0;t<e.length;t++){var r=new Mr(e,t);this.runContextCheck(r)}this.dispatch("updateContextsRanges",[this.registeredContexts])},Pr.prototype.setEndOffset=function(e,t){var r=new Ir(this.getContext(t).openRange.startIndex,e,t),n=this.getContext(t).ranges;return r.rangeId=t+"."+n.length,n.push(r),this.getContext(t).openRange=null,r},Pr.prototype.runContextCheck=function(e){var t=this,r=e.index;this.contextCheckers.forEach((function(n){var a=n.contextName,o=t.getContext(a).openRange;if(!o&&n.checkStart(e)&&(o=new Ir(r,null,a),t.getContext(a).openRange=o,t.dispatch("contextStart",[a,r])),o&&n.checkEnd(e)){var s=r-o.startIndex+1,i=t.setEndOffset(s,a);t.dispatch("contextEnd",[a,i])}}))},Pr.prototype.tokenize=function(e){this.tokens=[],this.resetContextsRanges();var t=Array.from(e);this.dispatch("start");for(var r=0;r<t.length;r++){var n=t[r],a=new Mr(t,r);this.dispatch("next",[a]),this.runContextCheck(a);var o=new Dr(n);this.tokens.push(o),this.dispatch("newToken",[o,a])}return this.dispatch("end",[this.tokens]),this.tokens},Wr.prototype.getDefaultScriptFeaturesIndexes=function(){for(var e=this.font.tables.gsub.scripts,t=0;t<e.length;t++){var r=e[t];if("DFLT"===r.tag)return r.script.defaultLangSys.featureIndexes}return[]},Wr.prototype.getScriptFeaturesIndexes=function(e){if(!this.font.tables.gsub)return[];if(!e)return this.getDefaultScriptFeaturesIndexes();for(var t=this.font.tables.gsub.scripts,r=0;r<t.length;r++){var n=t[r];if(n.tag===e&&n.script.defaultLangSys)return n.script.defaultLangSys.featureIndexes;var a=n.langSysRecords;if(a)for(var o=0;o<a.length;o++){var s=a[o];if(s.tag===e)return s.langSys.featureIndexes}}return this.getDefaultScriptFeaturesIndexes()},Wr.prototype.mapTagsToFeatures=function(e,t){for(var r={},n=0;n<e.length;n++){var a=e[n].tag,o=e[n].feature;r[a]=o}this.features[t].tags=r},Wr.prototype.getScriptFeatures=function(e){var t=this.features[e];if(this.features.hasOwnProperty(e))return t;var r=this.getScriptFeaturesIndexes(e);if(!r)return null;var n=this.font.tables.gsub;return t=r.map((function(e){return n.features[e]})),this.features[e]=t,this.mapTagsToFeatures(t,e),t},Wr.prototype.getSubstitutionType=function(e,t){return e.lookupType.toString()+t.substFormat.toString()},Wr.prototype.getLookupMethod=function(e,t){var r=this;switch(this.getSubstitutionType(e,t)){case"11":return function(e){return Xr.apply(r,[e,t])};case"12":return function(e){return Vr.apply(r,[e,t])};case"63":return function(e){return Yr.apply(r,[e,t])};case"41":return function(e){return Zr.apply(r,[e,t])};case"21":return function(e){return Qr.apply(r,[e,t])};default:throw new Error("lookupType: "+e.lookupType+" - substFormat: "+t.substFormat+" is not yet supported")}},Wr.prototype.lookupFeature=function(e){var t=e.contextParams,r=t.index,n=this.getFeature({tag:e.tag,script:e.script});if(!n)return new Error("font '"+this.font.names.fullName.en+"' doesn't support feature '"+e.tag+"' for script '"+e.script+"'.");for(var a=this.getFeatureLookups(n),o=[].concat(t.context),s=0;s<a.length;s++)for(var i=a[s],u=this.getLookupSubtables(i),l=0;l<u.length;l++){var p=u[l],c=this.getSubstitutionType(i,p),h=this.getLookupMethod(i,p),f=void 0;switch(c){case"11":(f=h(t.current))&&o.splice(r,1,new qr({id:11,tag:e.tag,substitution:f}));break;case"12":(f=h(t.current))&&o.splice(r,1,new qr({id:12,tag:e.tag,substitution:f}));break;case"63":f=h(t),Array.isArray(f)&&f.length&&o.splice(r,1,new qr({id:63,tag:e.tag,substitution:f}));break;case"41":(f=h(t))&&o.splice(r,1,new qr({id:41,tag:e.tag,substitution:f}));break;case"21":(f=h(t.current))&&o.splice(r,1,new qr({id:21,tag:e.tag,substitution:f}))}t=new Mr(o,r),Array.isArray(f)&&!f.length||(f=null)}return o.length?o:null},Wr.prototype.supports=function(e){if(!e.script)return!1;this.getScriptFeatures(e.script);var t=this.features.hasOwnProperty(e.script);if(!e.tag)return t;var r=this.features[e.script].some((function(t){return t.tag===e.tag}));return t&&r},Wr.prototype.getLookupSubtables=function(e){return e.subtables||null},Wr.prototype.getLookupByIndex=function(e){return this.font.tables.gsub.lookups[e]||null},Wr.prototype.getFeatureLookups=function(e){return e.lookupListIndexes.map(this.getLookupByIndex.bind(this))},Wr.prototype.getFeature=function(e){if(!this.font)return{FAIL:"No font was found"};this.features.hasOwnProperty(e.script)||this.getScriptFeatures(e.script);var t=this.features[e.script];return t?t.tags[e.tag]?this.features[e.script].tags[e.tag]:null:{FAIL:"No feature for script "+e.script}};var Kr={startCheck:function(e){var t=e.current,r=e.get(-1);return null===r&&Ar(t)||!Ar(r)&&Ar(t)},endCheck:function(e){var t=e.get(1);return null===t||!Ar(t)}};var Jr={startCheck:function(e){var t=e.current,r=e.get(-1);return(Ar(t)||Hr(t))&&!Ar(r)},endCheck:function(e){var t=e.get(1);switch(!0){case null===t:return!0;case!Ar(t)&&!Hr(t):var r=/\s/.test(t);if(!r)return!0;if(r){var n;if(n=e.lookahead.some((function(e){return Ar(e)||Hr(e)})),!n)return!0}break;default:return!1}}};var $r={11:function(e,t,r){t[r].setState(e.tag,e.substitution)},12:function(e,t,r){t[r].setState(e.tag,e.substitution)},63:function(e,t,r){e.substitution.forEach((function(n,a){t[r+a].setState(e.tag,n)}))},41:function(e,t,r){var n=t[r];n.setState(e.tag,e.substitution.ligGlyph);for(var a=e.substitution.components.length,o=0;o<a;o++)(n=t[r+o+1]).setState("deleted",!0)}};function en(e,t,r){e instanceof qr&&$r[e.id]&&$r[e.id](e,t,r)}function tn(e){var t=this,r="arab",n=this.featuresTags[r],a=this.tokenizer.getRangeTokens(e);if(1!==a.length){var o=new Mr(a.map((function(e){return e.getState("glyphIndex")})),0),s=new Mr(a.map((function(e){return e.char})),0);a.forEach((function(e,i){if(!Hr(e.char)){o.setCurrentIndex(i),s.setCurrentIndex(i);var u,l=0;switch(function(e){for(var t=[].concat(e.backtrack),r=t.length-1;r>=0;r--){var n=t[r],a=Nr(n),o=Hr(n);if(!a&&!o)return!0;if(a)return!1}return!1}(s)&&(l|=1),function(e){if(Nr(e.current))return!1;for(var t=0;t<e.lookahead.length;t++)if(!Hr(e.lookahead[t]))return!0;return!1}(s)&&(l|=2),l){case 1:u="fina";break;case 2:u="init";break;case 3:u="medi"}if(-1!==n.indexOf(u)){var p=t.query.lookupFeature({tag:u,script:r,contextParams:o});if(p instanceof Error)return console.info(p.message);p.forEach((function(e,t){e instanceof qr&&(en(e,a,t),o.context[t]=e.substitution)}))}}}))}}function rn(e,t){return new Mr(e.map((function(e){return e.activeState.value})),t||0)}function nn(e){var t=this,r=this.tokenizer.getRangeTokens(e),n=rn(r);n.context.forEach((function(e,a){n.setCurrentIndex(a);var o=t.query.lookupFeature({tag:"rlig",script:"arab",contextParams:n});o.length&&(o.forEach((function(e){return en(e,r,a)})),n=rn(r))}))}var an={startCheck:function(e){var t=e.current,r=e.get(-1);return null===r&&zr(t)||!zr(r)&&zr(t)},endCheck:function(e){var t=e.get(1);return null===t||!zr(t)}};function on(e,t){return new Mr(e.map((function(e){return e.activeState.value})),t||0)}function sn(e){var t=this,r=this.tokenizer.getRangeTokens(e),n=on(r);n.context.forEach((function(e,a){n.setCurrentIndex(a);var o=t.query.lookupFeature({tag:"liga",script:"latn",contextParams:n});o.length&&(o.forEach((function(e){return en(e,r,a)})),n=on(r))}))}function un(e){this.baseDir=e||"ltr",this.tokenizer=new Pr,this.featuresTags={}}function ln(e){var t=this.contextChecks[e+"Check"];return this.tokenizer.registerContextChecker(e,t.startCheck,t.endCheck)}function pn(){return ln.call(this,"latinWord"),ln.call(this,"arabicWord"),ln.call(this,"arabicSentence"),this.tokenizer.tokenize(this.text)}function cn(){var e=this;this.tokenizer.getContextRanges("arabicSentence").forEach((function(t){var r=e.tokenizer.getRangeTokens(t);e.tokenizer.replaceRange(t.startIndex,t.endOffset,r.reverse())}))}function hn(){if(-1===this.tokenizer.registeredModifiers.indexOf("glyphIndex"))throw new Error("glyphIndex modifier is required to apply arabic presentation features.")}function fn(){var e=this;this.featuresTags.hasOwnProperty("arab")&&(hn.call(this),this.tokenizer.getContextRanges("arabicWord").forEach((function(t){tn.call(e,t)})))}function dn(){var e=this,t="arab";this.featuresTags.hasOwnProperty(t)&&(-1!==this.featuresTags[t].indexOf("rlig")&&(hn.call(this),this.tokenizer.getContextRanges("arabicWord").forEach((function(t){nn.call(e,t)}))))}function vn(){var e=this,t="latn";this.featuresTags.hasOwnProperty(t)&&(-1!==this.featuresTags[t].indexOf("liga")&&(hn.call(this),this.tokenizer.getContextRanges("latinWord").forEach((function(t){sn.call(e,t)}))))}function gn(e){(e=e||{}).tables=e.tables||{},e.empty||(Mt(e.familyName,"When creating a new Font object, familyName is required."),Mt(e.styleName,"When creating a new Font object, styleName is required."),Mt(e.unitsPerEm,"When creating a new Font object, unitsPerEm is required."),Mt(e.ascender,"When creating a new Font object, ascender is required."),Mt(e.descender<=0,"When creating a new Font object, negative descender value is required."),this.names={fontFamily:{en:e.familyName||" "},fontSubfamily:{en:e.styleName||" "},fullName:{en:e.fullName||e.familyName+" "+e.styleName},postScriptName:{en:e.postScriptName||(e.familyName+e.styleName).replace(/\s/g,"")},designer:{en:e.designer||" "},designerURL:{en:e.designerURL||" "},manufacturer:{en:e.manufacturer||" "},manufacturerURL:{en:e.manufacturerURL||" "},license:{en:e.license||" "},licenseURL:{en:e.licenseURL||" "},version:{en:e.version||"Version 0.1"},description:{en:e.description||" "},copyright:{en:e.copyright||" "},trademark:{en:e.trademark||" "}},this.unitsPerEm=e.unitsPerEm||1e3,this.ascender=e.ascender,this.descender=e.descender,this.createdTimestamp=e.createdTimestamp,this.tables=Object.assign(e.tables,{os2:Object.assign({usWeightClass:e.weightClass||this.usWeightClasses.MEDIUM,usWidthClass:e.widthClass||this.usWidthClasses.MEDIUM,fsSelection:e.fsSelection||this.fsSelectionValues.REGULAR},e.tables.os2)})),this.supported=!0,this.glyphs=new Be.GlyphSet(this,e.glyphs||[]),this.encoding=new Re(this),this.position=new Ct(this),this.substitution=new wt(this),this.tables=this.tables||{},this._push=null,this._hmtxTableData={},Object.defineProperty(this,"hinting",{get:function(){return this._hinting?this._hinting:"truetype"===this.outlinesFormat?this._hinting=new Xt(this):void 0}})}function mn(e,t){var r=JSON.stringify(e),n=256;for(var a in t){var o=parseInt(a);if(o&&!(o<256)){if(JSON.stringify(t[a])===r)return o;n<=o&&(n=o+1)}}return t[n]=e,n}function yn(e,t,r){var n=mn(t.name,r);return[{name:"tag_"+e,type:"TAG",value:t.tag},{name:"minValue_"+e,type:"FIXED",value:t.minValue<<16},{name:"defaultValue_"+e,type:"FIXED",value:t.defaultValue<<16},{name:"maxValue_"+e,type:"FIXED",value:t.maxValue<<16},{name:"flags_"+e,type:"USHORT",value:0},{name:"nameID_"+e,type:"USHORT",value:n}]}function bn(e,t,r){var n={},a=new se.Parser(e,t);return n.tag=a.parseTag(),n.minValue=a.parseFixed(),n.defaultValue=a.parseFixed(),n.maxValue=a.parseFixed(),a.skip("uShort",1),n.name=r[a.parseUShort()]||{},n}function Sn(e,t,r,n){for(var a=[{name:"nameID_"+e,type:"USHORT",value:mn(t.name,n)},{name:"flags_"+e,type:"USHORT",value:0}],o=0;o<r.length;++o){var s=r[o].tag;a.push({name:"axis_"+e+" "+s,type:"FIXED",value:t.coordinates[s]<<16})}return a}function xn(e,t,r,n){var a={},o=new se.Parser(e,t);a.name=n[o.parseUShort()]||{},o.skip("uShort",1),a.coordinates={};for(var s=0;s<r.length;++s)a.coordinates[r[s].tag]=o.parseFixed();return a}un.prototype.setText=function(e){this.text=e},un.prototype.contextChecks={latinWordCheck:an,arabicWordCheck:Kr,arabicSentenceCheck:Jr},un.prototype.registerFeatures=function(e,t){var r=this,n=t.filter((function(t){return r.query.supports({script:e,tag:t})}));this.featuresTags.hasOwnProperty(e)?this.featuresTags[e]=this.featuresTags[e].concat(n):this.featuresTags[e]=n},un.prototype.applyFeatures=function(e,t){if(!e)throw new Error("No valid font was provided to apply features");this.query||(this.query=new Wr(e));for(var r=0;r<t.length;r++){var n=t[r];this.query.supports({script:n.script})&&this.registerFeatures(n.script,n.tags)}},un.prototype.registerModifier=function(e,t,r){this.tokenizer.registerModifier(e,t,r)},un.prototype.checkContextReady=function(e){return!!this.tokenizer.getContext(e)},un.prototype.applyFeaturesToContexts=function(){this.checkContextReady("arabicWord")&&(fn.call(this),dn.call(this)),this.checkContextReady("latinWord")&&vn.call(this),this.checkContextReady("arabicSentence")&&cn.call(this)},un.prototype.processText=function(e){this.text&&this.text===e||(this.setText(e),pn.call(this),this.applyFeaturesToContexts())},un.prototype.getBidiText=function(e){return this.processText(e),this.tokenizer.getText()},un.prototype.getTextGlyphs=function(e){this.processText(e);for(var t=[],r=0;r<this.tokenizer.tokens.length;r++){var n=this.tokenizer.tokens[r];if(!n.state.deleted){var a=n.activeState.value;t.push(Array.isArray(a)?a[0]:a)}}return t},gn.prototype.hasChar=function(e){return null!==this.encoding.charToGlyphIndex(e)},gn.prototype.charToGlyphIndex=function(e){return this.encoding.charToGlyphIndex(e)},gn.prototype.charToGlyph=function(e){var t=this.charToGlyphIndex(e),r=this.glyphs.get(t);return r||(r=this.glyphs.get(0)),r},gn.prototype.updateFeatures=function(e){return this.defaultRenderOptions.features.map((function(t){return"latn"===t.script?{script:"latn",tags:t.tags.filter((function(t){return e[t]}))}:t}))},gn.prototype.stringToGlyphs=function(e,t){var r=this,n=new un;n.registerModifier("glyphIndex",null,(function(e){return r.charToGlyphIndex(e.char)}));var a=t?this.updateFeatures(t.features):this.defaultRenderOptions.features;n.applyFeatures(this,a);for(var o=n.getTextGlyphs(e),s=o.length,i=new Array(s),u=this.glyphs.get(0),l=0;l<s;l+=1)i[l]=this.glyphs.get(o[l])||u;return i},gn.prototype.nameToGlyphIndex=function(e){return this.glyphNames.nameToGlyphIndex(e)},gn.prototype.nameToGlyph=function(e){var t=this.nameToGlyphIndex(e),r=this.glyphs.get(t);return r||(r=this.glyphs.get(0)),r},gn.prototype.glyphIndexToName=function(e){return this.glyphNames.glyphIndexToName?this.glyphNames.glyphIndexToName(e):""},gn.prototype.getKerningValue=function(e,t){e=e.index||e,t=t.index||t;var r=this.position.defaultKerningTables;return r?this.position.getKerningValue(r,e,t):this.kerningPairs&&this.kerningPairs[e+","+t]||0},gn.prototype.defaultRenderOptions={kerning:!0,features:[{script:"arab",tags:["init","medi","fina","rlig"]},{script:"latn",tags:["liga","rlig"]}]},gn.prototype.forEachGlyph=function(e,t,r,n,a,o){t=void 0!==t?t:0,r=void 0!==r?r:0,n=void 0!==n?n:72,a=Object.assign({},this.defaultRenderOptions,a);var s,i=1/this.unitsPerEm*n,u=this.stringToGlyphs(e,a);if(a.kerning){var l=a.script||this.position.getDefaultScriptName();s=this.position.getKerningTables(l,a.language)}for(var p=0;p<u.length;p+=1){var c=u[p];if(o.call(this,c,t,r,n,a),c.advanceWidth&&(t+=c.advanceWidth*i),a.kerning&&p<u.length-1)t+=(s?this.position.getKerningValue(s,c.index,u[p+1].index):this.getKerningValue(c,u[p+1]))*i;a.letterSpacing?t+=a.letterSpacing*n:a.tracking&&(t+=a.tracking/1e3*n)}return t},gn.prototype.getPath=function(e,t,r,n,a){var o=new E;return this.forEachGlyph(e,t,r,n,a,(function(e,t,r,n){var s=e.getPath(t,r,n,a,this);o.extend(s)})),o},gn.prototype.getPaths=function(e,t,r,n,a){var o=[];return this.forEachGlyph(e,t,r,n,a,(function(e,t,r,n){var s=e.getPath(t,r,n,a,this);o.push(s)})),o},gn.prototype.getAdvanceWidth=function(e,t,r){return this.forEachGlyph(e,0,0,t,r,(function(){}))},gn.prototype.draw=function(e,t,r,n,a,o){this.getPath(t,r,n,a,o).draw(e)},gn.prototype.drawPoints=function(e,t,r,n,a,o){this.forEachGlyph(t,r,n,a,o,(function(t,r,n,a){t.drawPoints(e,r,n,a)}))},gn.prototype.drawMetrics=function(e,t,r,n,a,o){this.forEachGlyph(t,r,n,a,o,(function(t,r,n,a){t.drawMetrics(e,r,n,a)}))},gn.prototype.getEnglishName=function(e){var t=this.names[e];if(t)return t.en},gn.prototype.validate=function(){var e=this;function t(t){var r=e.getEnglishName(t);r&&r.trim().length}t("fontFamily"),t("weightName"),t("manufacturer"),t("copyright"),t("version"),this.unitsPerEm},gn.prototype.toTables=function(){return kt.fontToTable(this)},gn.prototype.toBuffer=function(){return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."),this.toArrayBuffer()},gn.prototype.toArrayBuffer=function(){for(var e=this.toTables().encode(),t=new ArrayBuffer(e.length),r=new Uint8Array(t),n=0;n<e.length;n++)r[n]=e[n];return t},gn.prototype.download=function(e){var t=this.getEnglishName("fontFamily"),r=this.getEnglishName("fontSubfamily");e=e||t.replace(/\s/g,"")+"-"+r+".otf";var n=this.toArrayBuffer();if("undefined"!=typeof window)if(window.URL=window.URL||window.webkitURL,window.URL){var a=new DataView(n),o=new Blob([a],{type:"font/opentype"}),s=document.createElement("a");s.href=window.URL.createObjectURL(o),s.download=e;var i=document.createEvent("MouseEvents");i.initEvent("click",!0,!1),s.dispatchEvent(i)}else console.warn("Font file could not be downloaded. Try using a different browser.");else{var u=require("fs"),l=function(e){for(var t=Buffer.alloc(e.byteLength),r=new Uint8Array(e),n=0;n<t.length;++n)t[n]=r[n];return t}(n);u.writeFileSync(e,l)}},gn.prototype.fsSelectionValues={ITALIC:1,UNDERSCORE:2,NEGATIVE:4,OUTLINED:8,STRIKEOUT:16,BOLD:32,REGULAR:64,USER_TYPO_METRICS:128,WWS:256,OBLIQUE:512},gn.prototype.usWidthClasses={ULTRA_CONDENSED:1,EXTRA_CONDENSED:2,CONDENSED:3,SEMI_CONDENSED:4,MEDIUM:5,SEMI_EXPANDED:6,EXPANDED:7,EXTRA_EXPANDED:8,ULTRA_EXPANDED:9},gn.prototype.usWeightClasses={THIN:100,EXTRA_LIGHT:200,LIGHT:300,NORMAL:400,MEDIUM:500,SEMI_BOLD:600,BOLD:700,EXTRA_BOLD:800,BLACK:900};var Tn={make:function(e,t){var r=new J.Table("fvar",[{name:"version",type:"ULONG",value:65536},{name:"offsetToData",type:"USHORT",value:0},{name:"countSizePairs",type:"USHORT",value:2},{name:"axisCount",type:"USHORT",value:e.axes.length},{name:"axisSize",type:"USHORT",value:20},{name:"instanceCount",type:"USHORT",value:e.instances.length},{name:"instanceSize",type:"USHORT",value:4+4*e.axes.length}]);r.offsetToData=r.sizeOf();for(var n=0;n<e.axes.length;n++)r.fields=r.fields.concat(yn(n,e.axes[n],t));for(var a=0;a<e.instances.length;a++)r.fields=r.fields.concat(Sn(a,e.instances[a],e.axes,t));return r},parse:function(e,t,r){var n=new se.Parser(e,t),a=n.parseULong();w.argument(65536===a,"Unsupported fvar table version.");var o=n.parseOffset16();n.skip("uShort",1);for(var s=n.parseUShort(),i=n.parseUShort(),u=n.parseUShort(),l=n.parseUShort(),p=[],c=0;c<s;c++)p.push(bn(e,t+o+c*i,r));for(var h=[],f=t+o+s*i,d=0;d<u;d++)h.push(xn(e,f+d*l,p,r));return{axes:p,instances:h}}},Un=function(){return{coverage:this.parsePointer(ae.coverage),attachPoints:this.parseList(ae.pointer(ae.uShortList))}},kn=function(){var e=this.parseUShort();return w.argument(1===e||2===e||3===e,"Unsupported CaretValue table version."),1===e?{coordinate:this.parseShort()}:2===e?{pointindex:this.parseShort()}:3===e?{coordinate:this.parseShort()}:void 0},On=function(){return this.parseList(ae.pointer(kn))},Rn=function(){return{coverage:this.parsePointer(ae.coverage),ligGlyphs:this.parseList(ae.pointer(On))}},En=function(){return this.parseUShort(),this.parseList(ae.pointer(ae.coverage))};var Ln={parse:function(e,t){var r=new ae(e,t=t||0),n=r.parseVersion(1);w.argument(1===n||1.2===n||1.3===n,"Unsupported GDEF table version.");var a={version:n,classDef:r.parsePointer(ae.classDef),attachList:r.parsePointer(Un),ligCaretList:r.parsePointer(Rn),markAttachClassDef:r.parsePointer(ae.classDef)};return n>=1.2&&(a.markGlyphSets=r.parsePointer(En)),a}};var Cn={parse:function(e,t){var r=new se.Parser(e,t),n=r.parseUShort();if(0===n)return function(e){var t={};e.skip("uShort");var r=e.parseUShort();w.argument(0===r,"Unsupported kern sub-table version."),e.skip("uShort",2);var n=e.parseUShort();e.skip("uShort",3);for(var a=0;a<n;a+=1){var o=e.parseUShort(),s=e.parseUShort(),i=e.parseShort();t[o+","+s]=i}return t}(r);if(1===n)return function(e){var t={};e.skip("uShort"),e.parseULong()>1&&console.warn("Only the first kern subtable is supported."),e.skip("uLong");var r=255&e.parseUShort();if(e.skip("uShort"),0===r){var n=e.parseUShort();e.skip("uShort",3);for(var a=0;a<n;a+=1){var o=e.parseUShort(),s=e.parseUShort(),i=e.parseShort();t[o+","+s]=i}}return t}(r);throw new Error("Unsupported kern table version ("+n+").")}};var wn={parse:function(e,t,r,n){for(var a=new se.Parser(e,t),o=n?a.parseUShort:a.parseULong,s=[],i=0;i<r+1;i+=1){var u=o.call(a);n&&(u*=2),s.push(u)}return s}};function Dn(e,t){require("fs").readFile(e,(function(e,r){if(e)return t(e.message);t(null,Gt(r))}))}function In(e,t){var r=new XMLHttpRequest;r.open("get",e,!0),r.responseType="arraybuffer",r.onload=function(){return r.response?t(null,r.response):t("Font could not be loaded: "+r.statusText)},r.onerror=function(){t("Font could not be loaded")},r.send()}function Gn(e,t){for(var r=[],n=12,a=0;a<t;a+=1){var o=se.getTag(e,n),s=se.getULong(e,n+4),i=se.getULong(e,n+8),u=se.getULong(e,n+12);r.push({tag:o,checksum:s,offset:i,length:u,compression:!1}),n+=16}return r}function Mn(e,t){if("WOFF"===t.compression){var r=new Uint8Array(e.buffer,t.offset+2,t.compressedLength-2),n=new Uint8Array(t.length);if(k(r,n),n.byteLength!==t.length)throw new Error("Decompression error: "+t.tag+" decompressed length doesn't match recorded length");return{data:new DataView(n.buffer,0),offset:0}}return{data:e,offset:t.offset}}function Bn(e,t){var r,n;t=null==t?{}:t;var a,o,s,i,u,l,p,c,h,f,d,v,g,m=new gn({empty:!0}),y=new DataView(e,0),b=[],S=se.getTag(y,0);if(S===String.fromCharCode(0,1,0,0)||"true"===S||"typ1"===S)m.outlinesFormat="truetype",b=Gn(y,a=se.getUShort(y,4));else if("OTTO"===S)m.outlinesFormat="cff",b=Gn(y,a=se.getUShort(y,4));else{if("wOFF"!==S)throw new Error("Unsupported OpenType signature "+S);var x=se.getTag(y,4);if(x===String.fromCharCode(0,1,0,0))m.outlinesFormat="truetype";else{if("OTTO"!==x)throw new Error("Unsupported OpenType flavor "+S);m.outlinesFormat="cff"}b=function(e,t){for(var r=[],n=44,a=0;a<t;a+=1){var o=se.getTag(e,n),s=se.getULong(e,n+4),i=se.getULong(e,n+8),u=se.getULong(e,n+12),l=void 0;l=i<u&&"WOFF",r.push({tag:o,offset:s,compression:l,compressedLength:i,length:u}),n+=20}return r}(y,a=se.getUShort(y,12))}for(var T=0;T<a;T+=1){var U=b[T],k=void 0;switch(U.tag){case"cmap":k=Mn(y,U),m.tables.cmap=xe.parse(k.data,k.offset),m.encoding=new Ee(m.tables.cmap);break;case"cvt ":k=Mn(y,U),g=new se.Parser(k.data,k.offset),m.tables.cvt=g.parseShortList(U.length/2);break;case"fvar":s=U;break;case"fpgm":k=Mn(y,U),g=new se.Parser(k.data,k.offset),m.tables.fpgm=g.parseByteList(U.length);break;case"head":k=Mn(y,U),m.tables.head=tt.parse(k.data,k.offset),m.unitsPerEm=m.tables.head.unitsPerEm,r=m.tables.head.indexToLocFormat;break;case"hhea":k=Mn(y,U),m.tables.hhea=rt.parse(k.data,k.offset),m.ascender=m.tables.hhea.ascender,m.descender=m.tables.hhea.descender,m.numberOfHMetrics=m.tables.hhea.numberOfHMetrics;break;case"hmtx":c=U;break;case"ltag":k=Mn(y,U),n=at.parse(k.data,k.offset);break;case"COLR":k=Mn(y,U),m.tables.colr=gt.parse(k.data,k.offset);break;case"CPAL":k=Mn(y,U),m.tables.cpal=mt.parse(k.data,k.offset);break;case"maxp":k=Mn(y,U),m.tables.maxp=ot.parse(k.data,k.offset),m.numGlyphs=m.tables.maxp.numGlyphs;break;case"name":d=U;break;case"OS/2":k=Mn(y,U),m.tables.os2=it.parse(k.data,k.offset);break;case"post":k=Mn(y,U),m.tables.post=ut.parse(k.data,k.offset),m.glyphNames=new Ce(m.tables.post);break;case"prep":k=Mn(y,U),g=new se.Parser(k.data,k.offset),m.tables.prep=g.parseByteList(U.length);break;case"glyf":i=U;break;case"loca":f=U;break;case"CFF ":o=U;break;case"kern":h=U;break;case"GDEF":u=U;break;case"GPOS":l=U;break;case"GSUB":p=U;break;case"meta":v=U}}var O=Mn(y,d);if(m.tables.name=be.parse(O.data,O.offset,n),m.names=m.tables.name,i&&f){var R=0===r,E=Mn(y,f),L=wn.parse(E.data,E.offset,m.numGlyphs,R),C=Mn(y,i);m.glyphs=_t.parse(C.data,C.offset,L,m,t)}else{if(!o)throw new Error("Font doesn't contain TrueType or CFF outlines.");var w=Mn(y,o);et.parse(w.data,w.offset,m,t)}var D=Mn(y,c);if(nt.parse(m,D.data,D.offset,m.numberOfHMetrics,m.numGlyphs,m.glyphs,t),we(m,t),h){var I=Mn(y,h);m.kerningPairs=Cn.parse(I.data,I.offset)}else m.kerningPairs={};if(u){var G=Mn(y,u);m.tables.gdef=Ln.parse(G.data,G.offset)}if(l){var M=Mn(y,l);m.tables.gpos=dt.parse(M.data,M.offset),m.position.init()}if(p){var B=Mn(y,p);m.tables.gsub=ht.parse(B.data,B.offset)}if(s){var F=Mn(y,s);m.tables.fvar=Tn.parse(F.data,F.offset,m.names)}if(v){var P=Mn(y,v);m.tables.meta=vt.parse(P.data,P.offset),m.metas=m.tables.meta}return m}function Fn(e,t,r){r=null==r?{}:r;var n="undefined"==typeof window&&!r.isUrl?Dn:In;return new Promise((function(a,o){n(e,(function(e,n){if(e){if(t)return t(e);o(e)}var s;try{s=Bn(n,r)}catch(e){if(t)return t(e,null);o(e)}if(t)return t(null,s);a(s)}))}))}function Pn(e,t){return Bn(Gt(require("fs").readFileSync(e)),t)}var An=Object.freeze({__proto__:null,Font:gn,Glyph:Ie,Path:E,BoundingBox:R,_parse:se,parse:Bn,load:Fn,loadSync:Pn});
//# sourceMappingURL=opentype.module.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".scribe.min.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			315: 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkScribeOCR"] = self["webpackChunkScribeOCR"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(2315);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});